# scripted effects

alias[effect:<scripted_effect>] = bool

# effects

### The scripted effect will draw the value of the right clause via $left_clause$.
alias[effect:<scripted_effect>] = {
    ## cardinality = 0..inf
    $parameter = $parameter_value
}

### Creates a starbase in orbit of the star of the scoped galactic object
## scopes = { planet galactic_object }
alias[effect:create_starbase] = {
    ## cardinality = 0..1
    owner = scope_group[target_country]
    ## cardinality = 1..1
    size = <ship_size.starbase>
    ## cardinality = 0..1
    design= <global_ship_design>
    ## cardinality = 0..100
    module = <starbase_module>
    ## cardinality = 0..100
    building = <starbase_building>
    ## cardinality = 0..1
    ## push_scope = starbase
    effect = single_alias_right[effect_clause]
}

### Prevents enclosed effects from being displayed in tooltip
## scopes = any
alias[effect:hidden_effect] = single_alias_right[effect_clause]

### Executes enclosed effects if limit criteria are met
## scopes = any
alias[effect:if] = {
    ## cardinality = ~1..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met
### if = { limit = { <triggers> } <effects> }
## scopes = any
alias[effect:else_if] = {
    ## cardinality = ~1..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met
### if = { limit = { <triggers> } <effects> }
## scopes = any
alias[effect:else] = {
    alias_name[effect] = alias_match_left[effect]
}

### Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain
## scopes = any
alias[effect:save_event_target_as] = value_set[event_target]
### Saves the current scope as an arbitrarily-named target to be referenced later, accessible globally until cleared
## scopes = any
alias[effect:save_global_event_target_as] = value_set[global_event_target]

### Fires a ship event for the scoped ship, with optional DAYS and RANDOM delay
## scopes = { ship }
alias[effect:ship_event] = {
    id = <event.scopeless>
    id = <event.ship>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a country event for the scoped country, with optional DAYS and RANDOM delay
## scopes = { country }
alias[effect:country_event] = {
    id = <event.scopeless>
    id = <event.country>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a first contact event for the scoped first contact site, with optional DAYS and RANDOM delay
## scopes = { first_contact }
alias[effect:first_contact_event] = {
    id = <event.scopeless>
    id = <event.first_contact>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires an observer event for all observers.
## scopes = any
alias[effect:observer_event] = {
    id = <event.scopeless>
    id = <event.observer>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a pop_group faction event for the scoped pop_group faction, with optional DAYS and RANDOM delay
## scopes = { pop_faction }
alias[effect:pop_faction_event] = {
    id = <event.scopeless>
    id = <event.pop_faction>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a pop_group event for the scoped pop_group, with optional DAYS and RANDOM delay
## scopes = { pop_group }
alias[effect:pop_group_event] = {
    id = <event.scopeless>
    id = <event.pop_group>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a fleet event for the scoped fleet, with optional DAYS and RANDOM delay
## scopes = { fleet }
alias[effect:fleet_event] = {
    id = <event.scopeless>
    id = <event.fleet>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a planet event for the scoped planet, with optional DAYS and RANDOM delay
## scopes = { planet }
alias[effect:planet_event] = {
    id = <event.scopeless>
    id = <event.planet>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a leader event for the scoped leader, with optional DAYS and RANDOM delay
## scopes = { leader }
alias[effect:leader_event] = {
    id = <event.scopeless>
    id = <event.leader>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a situation event for the scoped situation, with optional DAYS and RANDOM delay
## scopes = { situation }
alias[effect:situation_event] = {
    id = <event.scopeless>
    id = <event.situation>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires an agreement event for the scoped agreement, with optional DAYS and RANDOM delay
## scopes = { agreement }
alias[effect:agreement_event] = {
    id = <event.scopeless>
    id = <event.agreement>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a starbase event for the scoped starbase, with optional DAYS and RANDOM delay
## scopes = { starbase }
alias[effect:starbase_event] = {
    id = <event.scopeless>
    id = <event.starbase>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires a system event for the scoped system, with optional DAYS and RANDOM delay
## scopes = { system }
alias[effect:system_event] = {
    id = <event.scopeless>
    id = <event.system>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fires an espionage operation event for the scoped espionage operation, with optional DAYS and RANDOM delay
## scopes = { espionage_operation }
alias[effect:espionage_operation_event] = {
    id = <event.scopeless>
    id = <event.espionage_operation>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Adds a specific modifier to the scoped object for a set duration
## scopes = { megastructure planet country ship pop_group fleet galactic_object pop_faction federation starbase spy_network espionage_operation astral_rift }
alias[effect:add_modifier] = {
    modifier = <static_modifier>
    # severity = info
    ## cardinality = 0..1
    enum[days_months_year] = int
    ## cardinality = 0..1
    mult = value_field
    ## cardinality = 0..1
    multiplier = value_field
    ## cardinality = 0..1
    time_multiplier = value_field
    ## cardinality = 0..1
    clear_on_owner_change = yes
}

### Displays a specific localization string in tooltip
## scopes = any
alias[effect:custom_tooltip] = localisation

### Adds a specific opinion modifier for the scoped country towards target country
## scopes = { country }
alias[effect:add_opinion_modifier] = {
    who = scope_group[target_country]
    modifier = <opinion_modifier>
}
### Removes a specific opinion modifier towards target country or any country from the scoped country
## scopes = { country }
alias[effect:remove_opinion_modifier] = {
    who = scope_group[target_country]
    modifier = <opinion_modifier>
}

### Removes a specific modifier from the scope object
## scopes = { megastructure planet country ship pop_group fleet galactic_object pop_faction federation starbase spy_network espionage_operation astral_rift }
alias[effect:remove_modifier] = <static_modifier>

# flags

### Sets an arbitrarily-named flag on the scoped country
## scopes = { country }
alias[effect:set_country_flag] = value_set[country_flag]
### Sets an arbitrarily-named flag on the scoped planet
## scopes = { planet }
alias[effect:set_planet_flag] = value_set[planet_flag]
### Sets an arbitrarily-named flag on the scoped pop_group's faction/pop_group faction
## scopes = { pop_group pop_faction }
alias[effect:set_pop_faction_flag] = value_set[pop_faction_flag]
### Sets an arbitrarily-named flag on the scoped system
## scopes = { galactic_object }
alias[effect:set_star_flag] = value_set[star_flag]
### Sets an arbitrarily-named flag on the scoped species
## scopes = { species }
alias[effect:set_species_flag] = value_set[species_flag]
### Sets an arbitrarily-named flag on the scoped pop_group
## scopes = { pop_group }
alias[effect:set_pop_group_flag] = value_set[pop_group_flag]
### Sets an arbitrarily-named flag on the scoped fleet
## scopes = { fleet }
alias[effect:set_fleet_flag] = value_set[fleet_flag]
### Sets an arbitrarily-named flag on the scoped ship
## scopes = { ship }
alias[effect:set_ship_flag] = value_set[ship_flag]
### Sets an arbitrarily-named global flag
## scopes = any
alias[effect:set_global_flag] = value_set[global_flag]
### Sets an arbitrarily-named flag on the scoped leader
## scopes = { leader }
alias[effect:set_leader_flag] = value_set[leader_flag]
### Sets an arbitrarily-named flag on the scoped ambient object
## scopes = { ambient_object }
alias[effect:set_ambient_object_flag] = value_set[ambient_object_flag]
### Sets an arbitrarily-named flag on the scoped mega structure
## scopes = { megastructure }
alias[effect:set_megastructure_flag] = value_set[megastructure_flag]
### Sets an arbitrarily-named flag on the scoped deposit
## scopes = { deposit }
alias[effect:set_deposit_flag] = value_set[deposit_flag]
### Sets an arbitrarily-named flag on the scoped sector
## scopes = { sector }
alias[effect:set_sector_flag] = value_set[sector_flag]
### Sets an arbitrarily-named flag on the scoped arc site
## scopes = { archaeological_site }
alias[effect:set_archaeology_flag] = value_set[archaeology_flag]
### Sets an arbitrarily-named flag on the scoped starbase
## scopes = { starbase }
alias[effect:set_starbase_flag] = value_set[starbase_flag]
### Sets an arbitrarily-named flag on the scoped spy network
## scopes = { spy_network }
alias[effect:set_spynetwork_flag] = value_set[spynetwork_flag]
### Sets an arbitrarily-named flag on the scoped espionage asset
## scopes = { espionage_asset }
alias[effect:set_espionage_asset_flag] = value_set[espionage_asset_flag]
### Sets an arbitrarily-named flag on the scoped war
## scopes = { war }
alias[effect:set_war_flag] = value_set[war_flag]
### Sets an arbitrarily-named flag on the scoped army
## scopes = { army }
alias[effect:set_army_flag] = value_set[army_flag]
### Sets an arbitrarily-named flag on the scoped situation
## scopes = { situation }
alias[effect:set_situation_flag] = value_set[situation_flag]
### Sets an arbitrarily-named flag on the scoped agreement
## scopes = { agreement }
alias[effect:set_agreement_flag] = value_set[agreement_flag]

### Removes a flag from the scoped country
## scopes = { country }
## severity = warning
alias[effect:remove_country_flag] = value[country_flag]
### Removes a flag from the scoped planet
## scopes = { planet }
## severity = warning
alias[effect:remove_planet_flag] = value[planet_flag]
### Removes a flag from the scoped pop_group's faction/pop_group faction
## scopes = { pop_group pop_faction }
## severity = warning
alias[effect:remove_pop_faction_flag] = value[pop_faction_flag]
### Removes a flag from the scoped system
## scopes = { galactic_object }
## severity = warning
alias[effect:remove_star_flag] = value[star_flag]
### Removes a flag from the scoped species
## scopes = { species }
## severity = warning
alias[effect:remove_species_flag] = value[species_flag]
### Removes a flag from the scoped pop_group
## scopes = { pop_group }
## severity = warning
alias[effect:remove_pop_group_flag] = value[pop_group_flag]
### Removes a flag from the scoped fleet
## scopes = { fleet }
## severity = warning
alias[effect:remove_fleet_flag] = value[fleet_flag]
### Removes a flag from the scoped ship
## scopes = { ship }
## severity = warning
alias[effect:remove_ship_flag] = value[ship_flag]
### Removes a global flag
## scopes = any
## severity = warning
alias[effect:remove_global_flag] = value[global_flag]
### Removes a flag from the scoped leader
## scopes = { leader }
## severity = warning
alias[effect:remove_leader_flag] = value[leader_flag]
### Removes a flag from the scoped ambient object
## scopes = { ambient_object }
## severity = warning
alias[effect:remove_ambient_object_flag] = value[ambient_object_flag]
### Removes a flag from the scoped mega structure
## scopes = { megastructure }
## severity = warning
alias[effect:remove_megastructure_flag] = value[megastructure_flag]
### Removes a flag from the scoped deposit
## scopes = { deposit }
## severity = warning
alias[effect:remove_deposit_flag] = value[deposit_flag]
### Removes a flag from the scoped sector
## scopes = { sector }
## severity = warning
alias[effect:remove_sector_flag] = value[sector_flag]
### Removes a flag from the scoped arc site
## scopes = { archaeological_site }
## severity = warning
alias[effect:remove_archaeology_flag] = value[archaeology_flag]
### Removes a flag from the scoped starbase
## scopes = { starbase }
## severity = warning
alias[effect:remove_starbase_flag] = value[starbase_flag]
### Removes a flag from the scoped spy network
## scopes = { spy_network }
## severity = warning
alias[effect:remove_spynetwork_flag] = value[spynetwork_flag]
### Removes a flag from the scoped espionage asset
## scopes = { espionage_asset }
## severity = warning
alias[effect:remove_espionage_asset_flag] = value[espionage_asset_flag]
### Removes a flag from the scoped war
## scopes = { war }
## severity = warning
alias[effect:remove_war_flag] = value[war_flag]
### Removes a flag from the scoped army
## scopes = { army }
## severity = warning
alias[effect:remove_army_flag] = value[army_flag]
### Removes a flag from the scoped situation
## scopes = { situation }
## severity = warning
alias[effect:remove_situation_flag] = value[situation_flag]
### Removes a flag from the scoped agreement
## scopes = { agreement }
## severity = warning
alias[effect:remove_agreement_flag] = value[agreement_flag]

### Sets an arbitrarily-named flag on the scoped country for a set duration
## scopes = { country }
alias[effect:set_timed_country_flag] = {
    flag = value_set[country_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped planet for a set duration
## scopes = { planet }
alias[effect:set_timed_planet_flag] = {
    flag = value_set[planet_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped pop_group faction for a set duration
## scopes = { pop_group pop_faction }
alias[effect:set_timed_pop_faction_flag] = {
    flag = value_set[pop_faction_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped system for a set duration
## scopes = { galactic_object }
alias[effect:set_timed_star_flag] = {
    flag = value_set[star_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped species for a set duration
## scopes = { species }
alias[effect:set_timed_species_flag] = {
    flag = value_set[species_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped pop_group for a set duration
## scopes = { pop_group }
alias[effect:set_timed_pop_group_flag] = {
    flag = value_set[pop_group_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped fleet for a set duration
## scopes = { fleet }
alias[effect:set_timed_fleet_flag] = {
    flag = value_set[fleet_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped ship for a set duration
## scopes = { ship }
alias[effect:set_timed_ship_flag] = {
    flag = value_set[ship_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named global flag for a set duration
## scopes = any
alias[effect:set_timed_global_flag] = {
    flag = value_set[global_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped leader for a set duration
## scopes = { leader }
alias[effect:set_timed_leader_flag] = {
    flag = value_set[leader_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped ambient object for a set duration
## scopes = { fleet }
alias[effect:set_timed_ambient_object_flag] = {
    flag = value_set[ambient_object_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped mega structure for a set duration
## scopes = { megastructure }
alias[effect:set_timed_megastructure_flag] = {
    flag = value_set[megastructure_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped deposit for a set duration
## scopes = { deposit }
alias[effect:set_timed_deposit_flag] = {
    flag = value_set[deposit_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped sector for a set duration
## scopes = { sector }
alias[effect:set_timed_sector_flag] = {
    flag = value_set[sector_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped arc site for a set duration
## scopes = { archaeological_site }
alias[effect:set_timed_archaeology_flag] = {
    flag = value_set[archaeology_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped starbase for a set duration
## scopes = { starbase }
alias[effect:set_timed_starbase_flag] = {
    flag = value_set[starbase_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped spy network for a set duration
## scopes = { spy_network }
alias[effect:set_timed_spynetwork_flag] = {
    flag = value_set[spynetwork_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped espionage asset for a set duration
## scopes = { espionage_asset }
alias[effect:set_timed_espionage_asset_flag] = {
    flag = value_set[espionage_asset_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped war for a set duration
## scopes = { war }
alias[effect:set_timed_war_flag] = {
    flag = value_set[war_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped army for a set duration
## scopes = { army }
alias[effect:set_timed_army_flag] = {
    flag = value_set[army_flag]
    enum[days_months_year] = int_value_field
}
### Sets an arbitrarily-named flag on the scoped situation for a set duration
## scopes = { situation }
alias[effect:set_timed_situation_flag] = {
    flag = value_set[situation_flag]
    enum[days_months_year] = int_value_field
}

### Sets an arbitrarily-named flag on the scoped agreement for a set duration
## scopes = { agreement }
alias[effect:set_timed_agreement_flag] = {
    flag = value_set[agreement_flag]
    enum[days_months_year] = int_value_field
}

### Removes a mega structure.
## scopes = any
alias[effect:remove_megastructure] = scope[megastructure]

### Sets the purge type for the entire planet
## scopes = any
alias[effect:set_planet_purge_type] = <purge_type>

### Sets a relation flag for the scoped country towards target country
## scopes = { country }
alias[effect:set_relation_flag] = {
    who = scope_group[target_country]
    flag = value_set[relation_flag]
}
### Sets an arbitrarily-named flag for the scoped country towards target country for a set duration
## scopes = { country }
alias[effect:set_timed_relation_flag] = {
    who = scope_group[target_country]
    flag = value_set[relation_flag]
    enum[days_months_year] = int_value_field
}
### Removes a specific relation flag towards target country from the scoped country
## scopes = { country }
## severity = warning
alias[effect:remove_relation_flag] = {
    who = scope_group[target_country]
    flag = value[relation_flag]
}

### Change the scoped country's government authority and/or civics
## scopes = { country }
alias[effect:change_government] = random
### Change the scoped country's government authority and/or civics
## scopes = { country }
alias[effect:change_government] = <authority>
### Change the scoped country's government authority and/or civics
## scopes = { country }
alias[effect:change_government] = {
    ## cardinality = 0..1
    authority = random
    ## cardinality = 0..1
    authority = <authority>
    ## cardinality = 0..1
    ### random includes starting civics
    civics = random
    ## cardinality = 0..1
    civics = {
        ## cardinality = 0..inf
        civic = <civic_or_origin.civic>
        ## cardinality = 0..inf
        civic = random
    }
    ## cardinality = 0..1
    cooldown = bool
    ## cardinality = 0..1
    remove_invalid_civics = yes
}

#ideally, "heir" should only be if type = ruler
### Kills the scoped leader or leader of the scoped country/fleet/ship/planet/army
## scopes = { planet country ship fleet leader army }
alias[effect:kill_leader] = {
    ### if left out will kill scoped leader, can be used multiple times
    ## cardinality = 0..1
    class = <leader_class>
    ### if left out will kill scoped leader, can be used multiple times
    ## cardinality = 0..1
    class = random
    ### if left out will kill scoped leader, can be used multiple times
    ## cardinality = 0..1
    class = random_ruler
    ### see leader class for list of abilities, will kill leader that has this ability, can be used multiple times
    ## cardinality = 0..1
    ability = scalar # TODO PLS 1.2.4+
    ## cardinality = 0..1
    show_notification = bool
    ## cardinality = 0..1
    ruler = bool
    ### if added to type = ruler, will kill heir instead
    ## cardinality = 0..1
    heir = bool
    ## cardinality = 0..1
    ### default: no; if yes, fires on_leader_fired instead of on_leader_death
    fire = yes
}

### Shifts an empire towards a specific ethic, adjusting afterwards to keep number of ethics points consistent
## scopes = { country }
alias[effect:shift_ethic] = <ethic>
### Adds a specific ethic to the scoped country
## scopes = { country }
alias[effect:country_add_ethic] = <ethic>
### Adds a specific ethic to the scoped country
## scopes = { country }
alias[effect:country_add_ethic] = random
### Removes a specific ethic from the scoped country
## scopes = { country }
alias[effect:country_remove_ethic] = <ethic>
### Instantly destroys the scoped pop_group
## scopes = any
alias[effect:kill_pop_group] = {
    pop_group = scope[pop_group]
    ## cardinality = 0..1
    amount = int_value_field
    ## cardinality = 0..1
    percentage = float[0.0..1.0]
    ###If set, the amount will be randomized in [max(1, size - random), size + random].
    ## cardinality = 0..1
    random = int_value_field
}
# alias[effect:enslave_pop] = bool	#deprecated
### Destroys the colony on the scoped planet
## scopes = { planet }
alias[effect:destroy_colony] = yes
#alias[effect:set_ruined] = bool

### Picks one random set of effects from a list, influenced by relative weight
## scopes = any
alias[effect:random_list] = {
    ## cardinality = 1..inf
    int = {
        ## cardinality = 0..inf
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
        ## cardinality = 0..inf
        alias_name[effect] = alias_match_left[effect]
    }
}

### Picks one random set of effects from a list, influenced by relative weight once per event scope.
### Works like a random list, but the tooltip will only show the option that actually happens.
## scopes = any
alias[effect:locked_random_list] = {
    ## cardinality = 1..inf
    int = {
        ## cardinality = 0..inf
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
        ## cardinality = 0..inf
        alias_name[effect] = alias_match_left[effect]
    }
}

### All enclosed effects may or may not be executed depending on set chance
## scopes = any
alias[effect:random] = {
    chance = int_value_field[1...99]
    ## cardinality = 1..inf
    alias_name[effect] = alias_match_left[effect]
}

### Creates a new fleet from empire designs up to specified fraction of naval cap
## scopes = { country }
alias[effect:create_fleet_from_naval_cap] = value_field
### Creates a new fleet from empire designs up to specified fraction of naval cap
## scopes = { country }
alias[effect:create_fleet_from_naval_cap] = {
    fraction = value_field
    ship_owner_type = country
    ship_owner_type = federation
    ship_owner_type = galactic_community
}

### Reduces the hull points of the scoped ship by a specific amount
## scopes = { ship }
alias[effect:reduce_hp] = int_value_field
### Reduces the hull points of the scoped ship by a relative amount
## scopes = { ship }
alias[effect:reduce_hp_percent] = value_field[0..100]
### Reduces the shield points of the scoped ship by a specific amount
## scopes = { ship }
alias[effect:reduce_shield] = int_value_field
### Damages ship by a specific amount
## scopes = { ship }
alias[effect:damage_ship] = int_value_field
### Damages scoped army by a specific amount
## scopes = { army }
alias[effect:damage_army] = int_value_field
### Exiles the scoped country/fleet/army/pop_group faction's leader and saves them with a custom name
## scopes = { country fleet leader army }
alias[effect:exile_leader_as] = value_set[exiled_leader]
### Adds a sum of experience points to the scoped leader
## scopes = { leader }
alias[effect:add_experience] = int_value_field
### Sets scoped leader as non/recruitable
## scopes = { leader }
alias[effect:recruitable] = bool
### Assigns target leader to the scoped country/fleet/army/pop_group faction/sector
## scopes = { planet country fleet army }
alias[effect:assign_leader] = scope_group[target_leader]
### Unassigns scoped leader from their post or unassigns leader from the scoped planet/ship/fleet/army
## scopes = { ship fleet leader army }
alias[effect:unassign_leader] = scope_group[target_leader]
### Adds claims on target system
## scopes = { galactic_object }
alias[effect:add_claims] = {
    who = scope_group[target_country]
    ## cardinality = 0..1
    num_of_claims = int
    ## cardinality = 0..1
    show_notification = bool
}

### Instantly sets the owner of the scoped planet/fleet/army/starbase to target country
## scopes = { megastructure planet fleet leader army starbase }
alias[effect:set_owner] = scope_group[target_country]
### Instantly sets the planet/fleet's controller to target country
## scopes = { planet fleet }
alias[effect:set_controller] = scope_group[target_country]
### Sets the fleet/ambient object's location, can be fine-tuned
## scopes = { fleet ambient_object }
alias[effect:set_location] = scope_group[spatial_object]
### Sets the fleet/ambient object's location, can be fine-tuned
## scopes = { fleet ambient_object }
alias[effect:set_location] = {
    target = scope_group[spatial_object]
    ## cardinality = 0..1
    distance = float #No variables here atm
    ## cardinality = 0..1
    distance = { min = float max = float }
    ## cardinality = 0..1
    angle = int[0..360]
    ## cardinality = 0..1
    angle = random
    ## cardinality = 0..1
    direction = in_system
    ## cardinality = 0..1
    direction = out_system
}

# variables

### Sets or creates an arbitrarily-named variable with a specific value in the current scope
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:set_variable] = {
    which = value_set[variable]
    value = value_field
}

### Sets a variable to a random value within the specified bounds
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:set_variable_to_random_value] = {
    which = value_set[variable]
    min = value_field
    max = value_field
    ## cardinality = 0..1
    rounded = bool
}

#presumably need to check the variable exists first for these, somehow
### Increments a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:change_variable] = {
    which = value_set[variable]
    value = value_field
}

# since: stellaris v4.0.15 (so how is it different from change_variable?)
### Increments a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:add_variable] = {
    which = value_set[variable]
    value = value_field
}

### Decrements a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:subtract_variable] = {
    which = value[variable]
    value = value_field
}

### Multiplies a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:multiply_variable] = {
    which = value[variable]
    value = value_field
}

### Divides a previously-set variable by a specific amount
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:divide_variable] = {
    which = value[variable]
    value = value_field
}

### Modulos a previously-set variable by a specific amount i.e. X % Y
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:modulo_variable] = {
    which = value[variable]
    value = value_field
}

### Rounds a previously-set variable to the closest X
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:round_variable_to_closest] = {
    which = value[variable]
    value = value_field
}

### Clears a previously-set variable from the game.
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:clear_variable] = value[variable]


#max should not be less than min...
### Adds a lump sum of a resource to the scoped country, defined as a multiple of the country's monthly income of that resource (clamped to max and min allowed values)
## scopes = { country }
alias[effect:add_monthly_resource_mult] = {
    resource = <resource>
    value = value_field
    ## cardinality = 0..1
    min = int
    ## cardinality = 0..1
    max = int
    ## cardinality = 0..1
    mult = value_field
}

### Adds a specific trait to the scoped leader
## scopes = { leader }
alias[effect:add_trait] = {
    ## cardinality = 1..1
    trait = <trait.leader_trait>
    ## cardinality = 1..1
    trait = random_common
    ## cardinality = 1..1
    trait = random_negative
    ## cardinality = 0..1
    consume_selection = bool
    ## cardinality = 0..1
    show_message = bool
}
### Removes a specific trait from the scoped leader
## scopes = { leader }
alias[effect:remove_trait] = <trait.leader_trait>
### Removes a specific trait from the scoped leader
## scopes = { leader }
alias[effect:remove_trait] = all_negative
#also, at least one of while and limit should be there
### Repeats enclosed effects while limit criteria are met or until set iteration count is reached
## scopes = any
alias[effect:while] = {
    ## cardinality = 0..1
    count = int_value_field
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Instantly resettles pop_group
## scopes = any
alias[effect:resettle_pop] = {
    pop = scope[pop_group]
    ## cardinality = 0..1
    planet = scope_group[target_planet]
}

#also, most of these are not used in Vanilla (the first is, I did the cardinality based on it)
### Set citizenship type for scoped species/pop_group/leader
## scopes = { pop_group leader species }
alias[effect:set_citizenship_type] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <citizenship_type>
    ## cardinality = 0..1
    cooldown = bool
}

### Set military service type for scoped species/pop_group/leader
## scopes = { pop_group leader species }
alias[effect:set_military_service_type] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <military_service_type>
    ## cardinality = 0..1
    cooldown = bool
}

### Set purge type for scoped species/pop_group/leader
## scopes = { pop_group leader species }
alias[effect:set_purge_type] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <purge_type>
    ## cardinality = 0..1
    cooldown = bool
}

### Set slavery type for scoped species/pop_group/leader
## scopes = { pop_group leader species }
alias[effect:set_slavery_type] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <slavery_type>
    ## cardinality = 0..1
    cooldown = bool
}

### Set population control for scoped species/pop_group/leader
## scopes = { pop_group leader species }
alias[effect:set_population_controls] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = bool
    type = <population_control>
    ## cardinality = 0..1
    cooldown = bool
}

### Set colonization control for scoped species/pop_group/leader
## scopes = { pop_group leader species }
alias[effect:set_colonization_controls] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = bool
    type = <colonization_control>
    ## cardinality = 0..1
    cooldown = bool
}

### Set migration control for scoped species/pop_group/leader
## scopes = { pop_group leader species }
alias[effect:set_migration_controls] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = bool
    type = <migration_control>
    ## cardinality = 0..1
    cooldown = bool
}

### Set living standard for scoped species/pop_group/leader
## scopes = { pop_group leader species }
alias[effect:set_living_standard] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <living_standard>
    ## cardinality = 0..1
    cooldown = bool
}

### Joins wars on the side of target country
## scopes = { country }
alias[effect:join_war] = scope_group[target_country]
### Changes closed borders status between two countries
## scopes = { country }
alias[effect:set_closed_borders] = {
    who = scope_group[target_country]
    status = bool
    ## cardinality = 0..1
    forced = int_value_field
}

### Declares war between the scoped country and target country
## scopes = { country }
alias[effect:declare_war] = {
    target = scope_group[target_country]
    attacker_war_goal = <war_goal>
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    ## push_scope = war
    effect = single_alias_right[effect_clause]
}

### Adds static war exhaustion, scaled with value_for_planet_destruction, to owner of the battle location
## scopes = { country }
alias[effect:add_static_war_exhaustion] = {
    attacker = scope_group[target_country]
    location = scope[planet] #target planet was omitted here
    value_for_planet_destruction = value_field[0.0..1.0]
}

### Adds diplomatic threat from target country
## scopes = { planet country galactic_object }
alias[effect:add_threat] = {
    who = scope_group[target_country]
    amount = value_field
}

### Adds a Casus Belli to the scoped country against the target country.
## scopes = { country }
alias[effect:add_casus_belli] = {
    type = <casus_belli>
    who = scope_group[target_country]
    days = int_value_field
}

### Sets a war goal to the scoped rebel country/war
## scopes = { country war }
alias[effect:set_war_goal] = {
    type = <war_goal>
    target = scope_group[target_country]
    enemy = scope_group[target_country]
}

### Sets the planet or system as un/surveyed by target country
## scopes = { planet galactic_object astral_rift }
alias[effect:set_surveyed] = {
    surveyed = bool
    ## cardinality = 0..1
    surveyor = scope_group[target_country]
}

### Destroys the target fleet (with death graphics)
## scopes = any
alias[effect:destroy_fleet] = scope[fleet]
### Destroys the target fleet (with death graphics)
## scopes = any
alias[effect:destroy_fleet] = {
    target = scope[fleet]
    ## cardinality = 0..1
    kill_leader = bool
    ## cardinality = 0..1
    destroy_template = bool
}

### Deletes the target fleet (no death graphics)
## scopes = any
alias[effect:delete_fleet] = scope[fleet]
### Deletes the target fleet (no death graphics)
## scopes = any
alias[effect:delete_fleet] = {
    target = scope[fleet]
    ## cardinality = 0..1
    kill_leader = bool
    ## cardinality = 0..1
    destroy_template = bool
}

### Deletes the target ship (no death graphics)
## scopes = any
alias[effect:delete_ship] = scope[ship]
### Destroys the target ship (with death graphics)
## scopes = any
alias[effect:destroy_ship] = scope[ship]
### Increases or reduces the size of the scoped planet by a specified amount
## scopes = { planet }
alias[effect:change_planet_size] = int_value_field
#see comment for what should actually be written here
### Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop_group faction
## scopes = { megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact }
alias[effect:set_name] = random
### Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop_group faction
## scopes = { megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact }
alias[effect:set_name] = scope[any]
### Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop_group faction
## scopes = { megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact }
alias[effect:set_name] = localisation
### Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop_group faction
## scopes = { megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact }
alias[effect:set_name] = {
    ## required
    ## cardinality = 1..1
    ### string in localisation (which contains one or more bracket commands)
    key = localisation
    ## required
    ## cardinality = 0..inf
    ### one of the bracket commands contained in the localisation referenced above, brackets optional (there should be 1 variable_string per unique bracket command)
    variable_string = scalar
}
### Reinstates a previously-exiled leader to the scoped country/fleet/army/pop_group faction
## scopes = { country fleet army }
alias[effect:set_leader] = value[exiled_leader]
### Reinstates a previously-exiled leader to the scoped country/fleet/army/pop_group faction
## scopes = { country fleet army }
alias[effect:set_leader] = last_created_leader
### Reinstates a previously-exiled leader to the scoped country/fleet/army/pop_group faction
## scopes = { country fleet army }
alias[effect:set_leader] = scope_group[target_leader]
### Forces scoped country to evaluate whether to create a specific faction type immediately, rather than monthly
## scopes = { country }
alias[effect:enable_faction_of_type] = <pop_faction>
### Sets the scoped country to be a subject of target country. If use_demanded_terms is set to yes, then the subject agreement will use terms that have previously been demanded in a diplomatic action. If allow_instant_negotiation is set to yes, then the subject and overlord can re-negotiate their agreement right away without having to way for the cooldown. If preset is specified, then the agreement will start as that preset
## scopes = { country }
alias[effect:set_subject_of] = {
    ## cardinality = 0..1
    who = scope_group[target_country]
    ## cardinality = 0..1
    who = none
    ## cardinality = 0..1
    use_demanded_terms = bool
    ## cardinality = 0..1
    allow_instant_negotiation = bool
    ## cardinality = 0..1
    preset = <agreement_preset>
}

### Removes claims on target system
## scopes = { galactic_object }
alias[effect:remove_claims] = {
    who = scope_group[target_country]
    ## cardinality = 0..1
    num_of_claims = int_value_field
}

### Prevents execution of subsequent effects in the same effect block, used with if-statements
## scopes = any
alias[effect:break] = yes
### Destroys the scoped country
## scopes = { country }
alias[effect:destroy_country] = yes
### Destroys the colony on the scoped planet
## scopes = { planet }
alias[effect:destroy_colony] = yes
### Destroys target ambient object
## scopes = any
alias[effect:destroy_ambient_object] = scope[ambient_object]
### Removes the planet from the scope
## scopes = { planet }
alias[effect:remove_planet] = yes
### Removes a single instance of a specific building from the scoped planet
## scopes = { planet }
alias[effect:remove_building] = <building>
### Adds zone to the district of the planet
## scopes = { planet }
alias[effect:add_zone] = {
    district = <district>
    zone = <zone>
    ## cardinality = 0..1
    zone_slot = <zone_slots>
    ## cardinality = 0..1
    zone_slot = int
    ## cardinality = 0..1
    replace = bool
}
### Begins construction of a specific building on the scoped planet
## scopes = { planet }
alias[effect:add_building] = <building>
### Begins construction of a specific building on the scoped planet
## scopes = { planet }
alias[effect:add_building] = {
    ## cardinality = 0..1
    district = <district>
    ## cardinality = 0..1
    zone = <zone>
    building = <building>
}
### Instantly gives a specific tech to the scoped country
## scopes = { country }
alias[effect:give_technology] = {
    tech = <technology>
    ## cardinality = 0..1
    message = bool
}

### Copies all techs from the target country to the scoped country, except for some exceptions listed. Tech weights (and weight modifiers) are honoured, meaning that techs a country should not have will not be copied.
## scopes = { country }
alias[effect:copy_techs_from] = {
    target = scope_group[target_country]
    ## cardinality = 0..1
    except = {
        ## cardinality = 0..inf
        <technology>
    }
}

### Sets the scoped object's graphical culture
## scopes = { megastructure country starbase }
alias[effect:set_graphical_culture] = <graphical_culture>
### Sets the scoped object's graphical culture
## scopes = { megastructure country }
alias[effect:set_graphical_culture] = scope_group[target_graphical_culture]
### Creates a new species. The habitability trait is determined by homeworld, traits = random, traits = { ideal_planet_class = <pc_XYZ> }, traits = <trait_pc_XYZ_preference>, or else is assigned randomly.
## scopes = any
alias[effect:create_species] = {
    ## cardinality = 0..1
    name = scope[any]
    ## cardinality = 0..1
    name = random
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    namelist = <name_list>
    ## cardinality = 0..1
    namelist = scope_group[target_country]
    ## cardinality = 0..1
    namelist = scope[species]
    ## cardinality = 0..1
    namelist = random
    ## cardinality = 0..1
    namelist = random_class
    ## cardinality = 0..1
    plural = scope[any]
    ## cardinality = 0..1
    plural = random
    ## cardinality = 0..1
    plural = scalar
    ## cardinality = 0..1
    species_bio = scalar
    ## cardinality = 0..1
    adjective = scalar
    class = <species_class>
    class = scope_group[target_species]
    class = random
    class = random_non_machine
    class = random_pre_ftl
    ## cardinality = 0..1
    portrait = scope_group[target_species]
    ## cardinality = 0..1
    portrait = <portrait>
    ## cardinality = 0..1
    portrait = <portrait_group>
    ## cardinality = 0..1
    portrait = random
    ## cardinality = 0..1
    portrait = this
    ## cardinality = 0..1
    ### Limits species to this gender
    gender = enum[genders_not_set]
    ## cardinality = 0..1
    ### Limits species to this gender
    gender = scope_group[target_leader]
    ## cardinality = 0..1
    ### Limits species to this gender
    gender = scope_group[target_species]
    ## cardinality = 0..1
    homeworld = scope_group[target_planet]
    ## cardinality = 0..1
    homeworld = scope_group[target_species]
    # -> traits can be multiple. You can have traits = this, traits = { trait = xyz } at the same time
    ## cardinality = 0..2
    traits = scope_group[target_species]
    ## cardinality = 0..2
    traits = random
    ## cardinality = 0..2
    traits = this
    ## cardinality = 0..2
    traits = {
        ## cardinality = 0..1
        ideal_planet_class = scope[planet]
        ## cardinality = 0..1
        ideal_planet_class = scope_group[target_species]
        ## cardinality = 0..1
        ideal_planet_class = <planet_class.habitable_planet>
        ## cardinality = 0..10
        trait = <trait.species_trait>
        ## cardinality = 0..10
        trait = random_traits
        ## cardinality = 0..10
        trait = random_presapient_trait
        ## cardinality = 0..10
        add_trait = <trait.species_trait>
    }
    ### determines if species is sapient (default: yes)
    ## cardinality = 0..1
    sapient = bool
    ### determines if species is a modification of another (default: no)
    ## cardinality = 0..1
    is_mod = bool
    ## cardinality = 0..1
    mod_name_affix = localisation
    ### determines if species leaders are immortal (default: no)
    ## cardinality = 0..1
    immortal = bool
    ### determines if pops of that species can colonize
    ## cardinality = 0..1
    pops_can_be_colonizers = bool
    ### determines if pops of that species can migrate
    ## cardinality = 0..1
    pops_can_migrate = bool
    ### determines if pops of that species can reproduce
    ## cardinality = 0..1
    pops_can_reproduce = bool
    ### determines if pops of that species can join factions
    ## cardinality = 0..1
    pops_can_join_factions = bool
    ### determines if that species can generate leaders
    ## cardinality = 0..1
    can_generate_leaders = bool
    ### determines if pops from that species can become slaves
    ## cardinality = 0..1
    pops_can_be_slaves = bool
    ### determines if pops from that species have happiness
    ## cardinality = 0..1
    pops_have_happiness = bool
    ### determines if pops from need consumer goods
    ## cardinality = 0..1
    consumer_goods = bool
    ### determines if the species can be modified (default: yes)
    ## cardinality = 0..1
    can_be_modified = bool
    ### determines if the species can be modified (default: yes)
    ## cardinality = 0..1
    can_be_modified = scope[any]
    ### speed at which the pops from that species grow automatically
    ## cardinality = 0..1
    pops_auto_growth = float[0.0..1.0]
    ### amount of energy each pop_group of that species consume monthly
    ## cardinality = 0..1
    pop_maintenance = float[0.0..1.0]
    ## cardinality = 0..1
    new_pop_resource_requirement = {
        type = <resource>
        type = robot_food
        type = scalar
        value = float
    }
    ### Limits species to this gender
    ## cardinality = 0..1
    gender = enum[genders_not_set]
    ### Limits species to this gender
    ## cardinality = 0..1
    gender = scope[species]
    ### Limits leader to this gender
    ## cardinality = 0..1
    gender = scope[leader]
    ### (default: no)
    ## cardinality = 0..1
    clear_parent_species_link = bool
    ### (default: yes)
    ## cardinality = 0..1
    allow_negative_traits = bool
    ## cardinality = 0..1
    extra_trait_points = int
    ## cardinality = 0..1
    name_list = <name_list>
    ## cardinality = 0..1
    name_list = random
    ## cardinality = 0..1
    name_list = scope_group[target_country]
    ## cardinality = 0..1
    name_list = scope[species]
    ## cardinality = 0..1
    pop_ethics = no
    ## cardinality = 0..1
    pop_ethics = random
    ## cardinality = 0..1
    pop_ethics = <ethic>
    ## cardinality = 0..1
    pop_ethics = {
        ## cardinality = 1..3
        <ethic>
        ## cardinality = 0..1
        random
    }
    ## cardinality = 0..1
    ## push_scope = species
    effect = single_alias_right[effect_clause]
    ## cardinality = 0..1
    blocked_archetypes = {
        ## cardinality = 1..inf
        <species_archetype>
    }
}

#if the country is default or anything else that uses them, it really should specify all the details of government, species, etc
### Creates a new country
## scopes = any
alias[effect:create_country] = {
    ## cardinality = 0..1
    name = scope[any]
    ## cardinality = 0..1
    name = random
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    adjective = scope[any]
    ## cardinality = 0..1
    adjective = random
    ## cardinality = 0..1
    adjective = localisation
    ## cardinality = 0..1
    type = <country_type>
    ## cardinality = 0..1
    contact_rule = enum[contact_rule]
    ## cardinality = 0..1
    auto_delete = bool
    ## cardinality = 0..1
    name_list = <name_list>
    ## cardinality = 0..1
    name_list = random
    ## cardinality = 0..1
    name_list = scope_group[target_country]
    ## cardinality = 0..1
    ship_prefix = scalar	#should be string or a scope
    ## cardinality = 0..1
    ### Sets country adjective. Allowed values are <string in localisation>/<string written in quotes e.g. "Korean">
    adjective = localisation
    ## cardinality = 0..1
    authority = random
    ## cardinality = 0..1
    authority = <authority>
    ## cardinality = 0..1
    authority = scope_group[target_country]
    ## cardinality = 0..1
    civics = scope_group[target_country]
    ## cardinality = 0..1
    origin = <civic_or_origin.origin>
    ## cardinality = 0..1
    origin = scope_group[target_country]
    ## cardinality = 0..1
    ### random includes starting civics
    civics = random
    ## cardinality = 0..1
    civics = {
        ## cardinality = 0..inf
        civic = <civic_or_origin.civic>
        ## cardinality = 0..inf
        civic = random
    }
    ## cardinality = 0..1
    species = random
    ## cardinality = 0..1
    species = scope_group[target_species]
    ### default: no
    ## cardinality = 0..1
    set_capital_from_species = bool
    ## cardinality = 0..1
    randomize_ethos = yes
    ## cardinality = 0..1
    ### Copies friendliness and hostility data from specified country.
    use_hostilities_from = scope_group[target_country]
    ## cardinality = 0..1
    ethos = random
    ## cardinality = 0..1
    ethos = scope_group[target_country]
    ## cardinality = 0..1
    ethos = {
        ## cardinality = 1..3
        ## cardinality_max_define = "NGameplay/ETHOS_MAX_POINTS"
        ethic = <ethic>
        ## cardinality = 1..3
        ## cardinality_max_define = "NGameplay/ETHOS_MAX_POINTS"
        ethic = random
    }
    ## cardinality = 0..1
    ## push_scope = country
    effect = single_alias_right[effect_clause]
    ## cardinality = 0..1
    graphical_culture = <graphical_culture>
    ## cardinality = 0..1
    city_graphical_culture = <graphical_culture>
    ## cardinality = 0..1
    ship_kinds = {
        ## cardinality = 0..inf
        <ship_categories>
    }
    ## cardinality = 0..1
    room = icon[gfx/portraits/city_sets]
    ## cardinality = 0..1
    flag = scope_group[target_country]
    ## cardinality = 0..1
    flag = random
    ## cardinality = 0..1
    flag = {
        #TODO - this is connected to game/flags.
        #I already created an entry for flag colors etc, you should work on connecting these.
        ## cardinality = 0..1
        icon = {
            category = scalar			#should be some sort of key
            file = scalar			#should be "filename.dds" in the correct folder
        }
        background = {
            category = scalar			#should be some sort of key
            file = scalar			#should be "filename.dds" in the correct folder
        }
        colors = {
            ## cardinality = 0..4
            <color_define>
            ## cardinality = 0..4
            "null"
        }
    }
    ## cardinality = 0..1
    ### Establishing contact on_action (on_first_contact) will not fire for any countries (ever) if this is set to no
    day_zero_contact = bool
    ## cardinality = 0..1
    ### Establishing contact on_action (on_first_contact) will not fire for this country or its federation allies
    exclude_day_zero_contact = scope_group[target_country]
    ## cardinality = 0..1
    released_by_country = scope_group[target_country]	#scope
    ## cardinality = 0..1
    released_from_country = scope_group[target_country]	#scope
    ## cardinality = 0..1
    ignore_initial_colony_error = bool
    ## cardinality = 0..1
    government_restrictions = {
        alias_name[government_trigger] = alias_match_left[government_trigger]
    }
}

### Creates a rebellion
## scopes = { planet }
alias[effect:create_rebels] = {
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    name = scope[any]
    ## cardinality = 0..1
    name = random
    authority = random
    authority = <authority>
    authority = scope_group[target_country]
    ## cardinality = 0..1
    origin = <civic_or_origin.origin>
    ## cardinality = 0..1
    civics = scope_group[target_country]
    ### random includes starting civics
    ## cardinality = 0..1
    civics = random
    ## cardinality = 0..1
    civics = {
        ## cardinality = 0..inf
        civic = <civic_or_origin.civic>
        ## cardinality = 0..inf
        civic = random
    }
    species = scope_group[target_species]
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    ethos = random
    ## cardinality = 0..1
    ethos = scope_group[target_country]
    ## cardinality = 0..1
    ethos = {
        ## cardinality = 1..3
        ## cardinality_max_define = "NGameplay/ETHOS_MAX_POINTS"
        ethic = <ethic>
    }
    ## cardinality = 0..1
    flag = scope_group[target_country]
    ## cardinality = 0..1
    flag = random
    ## cardinality = 0..1
    flag = {
        #TODO - this is connected to game/flags.
        #I already created an entry for flag colors etc, you should work on connecting these.
        ## cardinality = 0..1
        icon = {
            category = scalar			#should be some sort of key
            file = scalar			#should be "filename.dds" in the correct folder
        }
        background = {
            category = scalar			#should be some sort of key
            file = scalar			#should be "filename.dds" in the correct folder
        }
        colors = {
            ## cardinality = 0..4
            <color_define>
            ## cardinality = 0..4
            "null"
        }
    }
    ## cardinality = 0..1
    name_list = <name_list>
    ## cardinality = 0..1
    name_list = random
    ## cardinality = 0..1
    ### This presumably works (report if not)
    ship_prefix = scalar	#should be string or a scope
    ## cardinality = 0..1
    released_from_country = scope_group[target_country]
    ## push_scope = country
    ## severity = warning
    #STNH do some interesting tricks, so I demoted it for their benefit.
    ### this is required to spawn rebels for the rebellion to work in the first place
    effect = single_alias_right[effect_clause]
}

### Creates a new army
## scopes = { planet }
alias[effect:create_army] = {
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    name = random
    owner = scope_group[target_country]
    type = <army>
    ## cardinality = 0..1
    species = scope_group[target_species]
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    leader = scope_group[target_leader]
    ## cardinality = 0..1
    ## push_scope = army
    effect = single_alias_right[effect_clause]
}

### Creates a new leader for the scoped country
## scopes = { country }
alias[effect:create_leader] = {
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    name = random
    ### Other scopes will simply default to this.owner_main_species
    ## cardinality = 0..1
    species = scope_group[target_species]
    ### Other scopes will simply default to this.owner_main_species
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    class = <leader_class>
    class = random
    class = random_ruler
    ### The leader skill level, minimum LEADER_SKILL_MIN and maximum LEADER_MAX_SKILL_CAP.
    ## cardinality = 0..1
    skill = int[1..20]
    ### The leader skill level, minimum LEADER_SKILL_MIN and maximum LEADER_MAX_SKILL_CAP.
    ## cardinality = 0..1
    skill = random
    ## cardinality = 0..1
    set_age = value_field
    ### The traits of the leader, e.g. "1 = leader_trait_bureaucrat". If <level> is a positive int and randomize_traits = yes, the trait is added if the leader's level is at least <level>.
    ## cardinality = 0..1
    traits = {
        ## cardinality = 0..inf
        int = <trait.leader_trait>
        ## cardinality = 0..inf
        trait = <trait.leader_trait>
        ## cardinality = 0..inf
        trait = random_trait
    }

    ### Optional, default = random.
    ## cardinality = 0..1
    gender = enum[gender]
    ### Optional, default = no. Sets if this is a event leader or not. Is checked through is_event_leader.
    ### default: no
    ## cardinality = 0..1
    event_leader = bool
    ### Optional, default = no.
    ## cardinality = 0..1
    immortal = bool
    ### Optional, default = no.
    ## cardinality = 0..1
    hide_age = bool
    ### Optional. Used for scientist subtypes.
    ## cardinality = 0..1
    sub_type = survey
    ### Optional, default = yes.
    ## cardinality = 0..1
    can_manually_change_location = bool
    ### Optional, default = yes.
    ## cardinality = 0..1
    can_assign_to_council = bool
    ### Optional, default = no. Hides the leader from the player's list of leaders, and doesn't count them towards the leader cap.
    ## cardinality = 0..1
    hide_leader = bool
    ### Optional, default = yes. Does not randomize for levels that are specified in traits.
    ## cardinality = 0..1
    randomize_traits = bool
    ### Optional, but requires leader_age_max if used. Used to randomize leader age within the age span between this and leader_age_max.
    ## cardinality = 0..1
    leader_age_min = int
    ### Optional, but requires leader_age_min if used. Used to randomize leader age within the age span between this and leader_age_min.
    ## cardinality = 0..1
    leader_age_max = int
    ### Optional, default = no. If generating a random name, use regnal names if the name list has them.
    ## cardinality = 0..1
    use_regnal_name = bool
    ### Optional. Scripted effect(s) that are run on the leader after it has been created.
    ## cardinality = 0..1
    ## push_scope = leader
    effect = single_alias_right[effect_clause]

    ### Optional.
    ## cardinality = 0..1
    custom_description = localisation
    ### Optional.
    ## cardinality = 0..1
    custom_catch_phrase = localisation
    ### Optional, default = no. Disables random generation of a background.
    ## cardinality = 0..1
    skip_background_generation = bool
    ### Optional. Used as the home planet of the leader.
    ## cardinality = 0..1
    background_planet = scope[planet]
    ### Optional.
    ## cardinality = 0..1
    background_job = <job>
    ### Optional.
    ## cardinality = 0..1
    background_ethic = <ethic>
}

#Same as create, but all optional except target
### Clones the last created leader for the scoped country
## scopes = { country }
alias[effect:clone_leader] = {
    target = scope_group[target_leader]

    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    name = random
    ### Other scopes will simply default to this.owner_main_species
    ## cardinality = 0..1
    species = scope_group[target_species]
    ### Other scopes will simply default to this.owner_main_species
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    class = <leader_class>
    ## cardinality = 0..1
    class = random
    ## cardinality = 0..1
    class = random_ruler
    ### The leader skill level, minimum LEADER_SKILL_MIN and maximum LEADER_MAX_SKILL_CAP.
    ## cardinality = 0..1
    skill = int[1..20]
    ### The leader skill level, minimum LEADER_SKILL_MIN and maximum LEADER_MAX_SKILL_CAP.
    ## cardinality = 0..1
    skill = random
    ## cardinality = 0..1
    set_age = value_field
    ### The traits of the leader, e.g. "1 = leader_trait_bureaucrat". If <level> is a positive int and randomize_traits = yes, the trait is added if the leader's level is at least <level>.
    ## cardinality = 0..1
    traits = {
        ## cardinality = 0..inf
        int = <trait.leader_trait>
        ## cardinality = 0..inf
        trait = <trait.leader_trait>
        ## cardinality = 0..inf
        trait = random_trait
    }

    ### Optional, default = random.
    ## cardinality = 0..1
    gender = enum[gender]
    ### Optional, default = no. Sets if this is a event leader or not. Is checked through is_event_leader.
    ### default: no
    ## cardinality = 0..1
    event_leader = bool
    ### Optional, default = no.
    ## cardinality = 0..1
    immortal = bool
    ### Optional, default = no.
    ## cardinality = 0..1
    hide_age = bool
    ### Optional. Used for scientist subtypes.
    ## cardinality = 0..1
    sub_type = survey
    ### Optional, default = yes.
    ## cardinality = 0..1
    can_manually_change_location = bool
    ### Optional, default = yes.
    ## cardinality = 0..1
    can_assign_to_council = bool
    ### Optional, default = no. Hides the leader from the player's list of leaders, and doesn't count them towards the leader cap.
    ## cardinality = 0..1
    hide_leader = bool
    ### Optional, default = yes. Does not randomize for levels that are specified in traits.
    ## cardinality = 0..1
    randomize_traits = bool
    ### Optional, but requires leader_age_max if used. Used to randomize leader age within the age span between this and leader_age_max.
    ## cardinality = 0..1
    leader_age_min = int
    ### Optional, but requires leader_age_min if used. Used to randomize leader age within the age span between this and leader_age_min.
    ## cardinality = 0..1
    leader_age_max = int
    ### Optional. Scripted effect(s) that are run on the leader after it has been created.
    ## cardinality = 0..1
    ## push_scope = leader
    effect = single_alias_right[effect_clause]

    ### Optional.
    ## cardinality = 0..1
    custom_description = localisation
    ### Optional.
    ## cardinality = 0..1
    custom_catch_phrase = localisation
    ### Optional, default = no. Disables random generation of a background.
    ## cardinality = 0..1
    skip_background_generation = bool
    ### Optional. Used as the home planet of the leader.
    ## cardinality = 0..1
    background_planet = scope[planet]
    ### Optional.
    ## cardinality = 0..1
    background_job = <job>
    ### Optional.
    ## cardinality = 0..1
    background_ethic = <ethic>
}

### Sets the age of the scoped leader
## scopes = { leader }
alias[effect:set_age] = int_value_field
### Creates a new, modified species based on an already-extant species
## scopes = { planet country pop_group leader species }
alias[effect:modify_species] = {
    ## cardinality = 0..1
    species = scope_group[target_species]
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    ### new base species; default: auto (uses species)
    base = scope_group[target_species]
    ## cardinality = 0..1
    base = auto
    ## cardinality = 0..1
    base = none
    ## cardinality = 0..inf
    add_trait = <trait>
    ### optional, pushes out other traits if needed
    ## cardinality = 0..1
    add_traits_at_start_of_list = bool
    ## cardinality = 0..inf
    remove_trait = <trait>
    ## cardinality = 0..1
    ideal_planet_class = scope[planet]
    ## cardinality = 0..1
    ideal_planet_class = scope_group[target_species]
    ## cardinality = 0..1
    ideal_planet_class = <planet_class.habitable_planet>
    ## cardinality = 0..1
    ### modify scoped pop_group/planet/leader/country; default: yes
    change_scoped_species = bool
    ## cardinality = 0..1
    portrait = scope_group[target_species]
    ## cardinality = 0..1
    portrait = <portrait>
    ## cardinality = 0..1
    portrait = <portrait_group>
    ## cardinality = 0..1
    portrait = random
    ### adds a random trait filtered by the given trigger, the Scope is the trait token, and the original scope is in Prev
    ## cardinality = 0..1
    add_random_species_trait = single_alias_right[trigger_clause]
    ### effect is fired for randomly selected trait, the Scope is the trait, the original scope is in Prev, and From contains Species
    ## cardinality = 0..1
    on_random_trait_added = single_alias_right[effect_clause]
    ### <Y/N, determines if species is pre-sapient>
    ## cardinality = 0..1
    sapient = bool
    ## cardinality = 0..1
    ## push_scope = species
    effect = single_alias_right[effect_clause]
}

### Changes the species of the scoped object
## scopes = { country ship pop_group leader army }
alias[effect:change_species] = scope_group[target_species]
### Changes the dominant species of the current Country, change_all also changes all usage of that species (Pops etc) in the empire
## scopes = { country }
alias[effect:change_dominant_species] = {
    species = scope_group[target_species]
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    change_all = yes
}

### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = <planet_class>
### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = <planet_class_random_list>
### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = scope_group[target_species]
### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = scope[species]
### Changes the class of the scoped planet
## scopes = { planet }
alias[effect:change_pc] = {
    class = <planet_class>
    class = <planet_class_random_list>
    class = scope_group[target_species]
    class = scope[species]
    inherit_entity = bool
}

### Sets the planet size to a specified number
## scopes = { planet }
alias[effect:set_planet_size] = int_value_field

### Adds resource deposit to the scoped planet (note: if you add a blocker, it will add a random deposit that can be blocked by that deposit)
## scopes = { planet astral_rift }
alias[effect:add_deposit] = <deposit>
### Adds resource deposit to the scoped planet (note: if you add a blocker, it will add a random deposit that can be blocked by that deposit)
## scopes = { planet astral_rift }
alias[effect:add_deposit] = enum[add_deposit_type]
### Replaces resource deposit on the scoped planet
## scopes = { planet }
alias[effect:set_deposit] = <deposit>
### Removes all deposits from the scoped planet
## scopes = { planet }
alias[effect:clear_deposits] = yes

enums = {
    enum[add_deposit_type] = {
        random
        random_blocker
        random_nonblocker
    }
}

### Clear modifiers on target planet
## scopes = { planet }
alias[effect:clear_planet_modifiers] = yes
### Clears resources of a country
## scopes = { country }
alias[effect:clear_resources] = yes
### Rebuild modifiers on target planet
## scopes = { planet }
alias[effect:reroll_planet_modifiers] = yes
### Silently establish communications between scoped country and target country
## scopes = { country }
alias[effect:establish_communications_no_message] = scope_group[target_country]
### Establishes first contact between the scoped country and target country at the set location
## scopes = { country }
alias[effect:establish_contact] = {
    who = scope_group[target_country]
    ## cardinality = 0..1
    location = scope_group[celestial_coordinate]
}

### Changes scoped pop_group to chosen ethic
## scopes = { pop_group }
alias[effect:pop_change_ethic] = {
    ethic = <ethic>
    ## cardinality = 0..1
    amount = int_value_field
    ## cardinality = 0..1
    percentage = float[0.0..1.0]
    ## cardinality = 0..1
    random = int_value_field
}
### Starts a situation log event chain for target country
## scopes = any
alias[effect:begin_event_chain] = {
    event_chain = <event_chain>
    ## cardinality = 0..1
    target = scope_group[target_country]
}

### Ends a specific situation log event chain for the scoped country
## scopes = { country }
alias[effect:end_event_chain] = <event_chain>
### Increments (or decrements with negative values) an event chain counter for the scoped country by a specific amount
## scopes = { country }
alias[effect:add_event_chain_counter] = {
    event_chain = <event_chain>
    counter = enum[event_chain_counter]
    amount = int_value_field
}

### Enables a specific special research project for target country at a specific location (should be same as the current scope where possible)
## scopes = any
alias[effect:enable_special_project] = {
    name = <special_project>
    ## cardinality = 0..1
    owner = scope_group[target_country]
    ## cardinality = 0..1
    location = scope_group[spatial_object]
}

### Aborts a specific special project for the country, removing it from the situation log
## scopes = { country }
alias[effect:abort_special_project] = {
    type = <special_project>
    ## cardinality = 0..1
    location = scope_group[spatial_object]
}

### Makes the scoped country remember that it has encountered the bypass type
## scopes = { country }
alias[effect:add_seen_bypass_type] = <bypass>
### Spawns a new natural wormhole in the scoped system.
## scopes = { galactic_object }
alias[effect:spawn_natural_wormhole] = {
    ## cardinality = 0..1
    in_place_of = scope_group[spatial_object]
    bypass_type = <bypass>
    ## cardinality = 0..1
    orbit_distance = float #no variables here atm
    ## cardinality = 0..1
    orbit_distance = { min = float max = float }
    ## cardinality = 0..1
    orbit_angle = random
    ## cardinality = 0..1
    orbit_angle = int[-360..360]
    ## cardinality = 0..1
    orbit_angle = { min = int[-360..360] max = int[-360..360] }
    ## cardinality = 0..1
    random_pos = bool
    ## cardinality = 0..1
    graphics_entity_name = <model_entity>
    ## cardinality = 0..1
    ## push_scope = bypass
    init_effect = single_alias_right[effect_clause]
}

### Link the wormhole from the scoped system to the wormhole in the target system, or from the scope wormhole to the target wormhole.
## scopes = { galactic_object bypass }
alias[effect:link_wormholes] = scope[galactic_object]
### Executes an effect on systems with planets owned by the scoped country, starting at an origin, and until a certain percentage of owned planets matching the planet_limit has been covered.
## scopes = { country }
alias[effect:effect_on_blob] = {
    center = scope[galactic_object]
    owned_planets_percentage = value_field[0.0..1.0]
    ## push_scope = planet
    planet_limit = single_alias_right[trigger_clause]
    ## push_scope = system
    effect = single_alias_right[effect_clause]
}

### Assign the player of the target country to play the scoped country instead
## scopes = { country }
alias[effect:set_player] = scope_group[target_country]

### Activates the gateway associated with a megastructure.
## scopes = any
alias[effect:activate_gateway] = scope[megastructure]
### Moves a saved leader to the active for the scoped country with a lookup key
## scopes = { country }
alias[effect:activate_saved_leader] = {
    key = value[saved_leader]
    ## cardinality = 0..1
    add_to_owned = bool
    ## cardinality = 0..1
    ## push_scope = leader
    effect = single_alias_right[effect_clause]
}

### Adds a specific anomaly category to the scoped planet
## scopes = any
alias[effect:add_anomaly] = {
    category = <anomaly_category>
    ## cardinality = 0..1
    target = scope_group[target_country]
}

### Adds an asteroid belt at the distance in the scope.
### Example:
## scopes = { galactic_object }
alias[effect:add_asteroid_belt] = {
    radius = int #no variables here atm
    type = <asteroid_belt_type>
}

### Adds to ongoing colonization progress on the scoped planet
## scopes = { planet }
alias[effect:add_colony_progress] = value_field[0.0..1.0]
### Adds a specific global design to the game
## scopes = any
alias[effect:add_global_ship_design] = <global_ship_design>
### Adds a hyperlane between two systems
## scopes = any
alias[effect:add_hyperlane] = {
    from = scope[galactic_object]
    to = scope[galactic_object]
}

### Adds or subtracts progress to/from the scoped observation post's current mission
## scopes = { fleet }
alias[effect:add_mission_progress] = value_field[-1.0..1.0]
### Add a notification modifier to the country
## scopes = { country }
alias[effect:add_notification_modifier] = <notification_modifier>
### Adds s random tech research option to the scoped country's tech view list, permanent until researched. if none applicable it runs fail_effects
## scopes = { country }
alias[effect:add_random_research_option] = {
    ## cardinality = 0..1
    category = <technology_category>
    ## cardinality = 0..1
    area = enum[technology_area]
    ## cardinality = 0..1
    tier = <technology_tier>
    ## cardinality = 0..1
    add_progress = value_field[0.1..1.0]
    ## cardinality = 0..1
    fail_effects = single_alias_right[effect_clause]
    ### default no
    ## cardinality = 0..1
    ignore_prereqs = bool
    ### default no
    ## cardinality = 0..1
    only_rare = bool
    ### default yes
    ## cardinality = 0..1
    ignore_insight = bool
    ### default yes
    ## cardinality = 0..1
    ignore_rare = bool
}

### Adds a tech research option to the scoped country's tech view list, permanent until researched
## scopes = { country }
alias[effect:add_research_option] = <technology>
### Makes the scoped country remember that it has encountered the bypass
## scopes = { country }
alias[effect:add_seen_bypass] = scope_group[spatial_object] #megastructure or wormhole
### Adds a specific ship design to the scoped country
## scopes = { country }
alias[effect:add_ship_design] = <global_ship_design>
### Adds a specific ship design to the scoped country
## scopes = { country }
alias[effect:add_ship_design] = scope[design]
### Adds a specific ship design to the scoped country
## scopes = { country }
alias[effect:add_ship_design] = last_created_design
### Adds to the scoped leader's skill level
## scopes = { leader }
alias[effect:add_skill] = int_value_field[-10..20] #check the interval
### Gives percentage progress (0.0-1.0) in a specific tech to the scoped country
## scopes = { country }
alias[effect:add_tech_progress] = {
    tech = <technology>
    progress = value_field[0.1..1.0]
}

### Create and sends an telemetry event keeping track of the tutorial steps for the current game
## scopes = any
alias[effect:complete_tutorial_step] = scalar

### Adds the specified tradition to the scoped country. add_tradition = <tradition_key>
## scopes = { country }
alias[effect:add_tradition] = <tradition>
### Adds trust on scope country towards target country
## scopes = { country }
alias[effect:add_trust] = {
    amount = value_field
    who = scope_group[target_country]
}

### Makes a fleet or ship auto-move to target fleet and potentially attack it
## scopes = { ship fleet }
alias[effect:auto_follow_fleet] = scope[fleet]

### Makes a fleet or ship auto-move to target fleet and potentially attack it
## scopes = { ship fleet }
alias[effect:auto_follow_fleet] = {
    target = scope[fleet]
    ## cardinality = 0..1
    attack_fleet = bool
}

### Makes a fleet or ship auto-move to target planet
## scopes = { ship fleet }
alias[effect:auto_move_to_planet] = {
    target = scope[planet]
    target = scope[galactic_object]
    clear_auto_move_on_arrival = bool
    ## cardinality = 0..1
    destroy_on_arrival = bool
    ## cardinality = 0..1
    arrival_effect = <scripted_effect>
}

### Cancels terraformation of the scoped planet
## scopes = { planet }
alias[effect:cancel_terraformation] = bool
### Changes the scoped country's flag
## scopes = { country }
alias[effect:change_country_flag] = random
### Changes the scoped country's flag
## scopes = { country }
alias[effect:change_country_flag] = {
    icon = {
        category = scalar		#TODO should be a folder name. This needs to be corrected for create_country, create_rebels and prescripted_countries too (possibly more)
        file = scalar		#TODO should be "filename.dds" in the named folder
    }
    background = {
        category = scalar		#TODO should be a folder name
        file = scalar		#TODO should be "filename.dds" in the named folder
    }
    colors = {
        ## cardinality = 0..4
        <color_define>
        ## cardinality = 0..4
        "null"
    }
}

### Changes the portrait of the leader in scope.
## scopes = { leader }
alias[effect:change_leader_portrait] = scope_group[target_species]
### Changes the portrait of the leader in scope.
## scopes = { leader }
alias[effect:change_leader_portrait] = <portrait>
### Changes the portrait of the leader in scope.
## scopes = { leader }
alias[effect:change_leader_portrait] = <portrait_group>
### Changes the characteristics of a species
## scopes = { species }
alias[effect:change_species_characteristics] = {
    ## cardinality = 0..1
    ### determines if species is pre-sapient
    sapient = bool
    ## cardinality = 0..1
    ### determines if species leaders are immortal
    immortal = bool
    ## cardinality = 0..1
    ### determines if the species can be modified
    can_be_modified = bool
    ## cardinality = 0..1
    ### determines if the species can be modified
    can_be_modified = scope_field
    ## cardinality = 0..1
    portrait = scope_group[target_species]
    ## cardinality = 0..1
    portrait = <portrait>
    ## cardinality = 0..1
    portrait = <portrait_group>
    ## cardinality = 0..1
    portrait = random
    ## cardinality = 0..inf
    add_trait = <trait.species_trait>
    ## cardinality = 0..inf
    remove_trait = <trait.species_trait>
    ## cardinality = 0..1
    ### Limits species to this gender
    gender = enum[genders_not_set]
    ## cardinality = 0..1
    ### Removes species gender restrictions
    gender = any
    ## cardinality = 0..1
    ### Limits species to this gender
    gender = scope_group[target_leader]
    ## cardinality = 0..1
    ### Limits species to this gender
    gender = scope_group[target_species]
    ## cardinality = 0..1
    ### Apply portrait and gender (randomizes new name) changes to existing leaders
    can_change_leader = bool
}

### Re-evaluate the specified casus belli type with given target country
## scopes = { country }
alias[effect:check_casus_belli_valid] = {
    ## cardinality = 0..1
    target = scope_group[target_country]
    ## cardinality = 0..1
    type = <casus_belli>
}

### Clears all ethics of specified pop_group or country
## scopes = { country pop_group }
alias[effect:clear_ethos] = yes
### Clears all queued fleet actions for target fleet
## scopes = { fleet }
alias[effect:clear_fleet_actions] = scope[fleet]
### Deletes the specified saved global target reference
## scopes = any
alias[effect:clear_global_event_target] = value[global_event_target]
### Deletes all saved global target references
## scopes = any
alias[effect:clear_global_event_targets] = yes
### Clears all fleet orders from the scoped fleet
## scopes = { fleet }
alias[effect:clear_orders] = yes
### Clears uncharted space from the galaxy map for the scoped country, in a radius around target system
## scopes = { country }
alias[effect:clear_uncharted_space] = scope[country]
### Clears uncharted space from the galaxy map for the scoped country, in a radius around target system
## scopes = { country }
alias[effect:clear_uncharted_space] = scope[system]

### Conquers the planet by setting its owner to target country and adding an unhappiness modifier
## scopes = { planet }
alias[effect:conquer] = scope_group[target_country]
### Makes the scoped country copy the ethos and government authority of the target country.
## scopes = { country }
alias[effect:copy_ethos_and_authority] = scope_group[target_country]
### Creates a new ambient object
## scopes = any
alias[effect:create_ambient_object] = {
    type = <ambient_object>
    ## cardinality = 0..1
    location = scope_group[spatial_object]
    ## cardinality = 0..1
    scale = float
    ## cardinality = 0..1
    use_3d_location = bool
    ## cardinality = 0..1
    entity_offset = float
    ## cardinality = 0..1
    entity_offset = { min = float max = float }
    ## cardinality = 0..1
    entity_offset_angle = int
    ## cardinality = 0..1
    entity_offset_angle = { min = int max = int }
    ## cardinality = 0..1
    entity_offset_height = float
    ## cardinality = 0..1
    entity_offset_height = { min = float max = float }
    ## cardinality = 0..1
    base_angle_towards = scope[country]
    ## cardinality = 0..1
    base_angle_towards = scope_group[spatial_object]
    ## cardinality = 0..1
    entity_face_object = scope_group[spatial_object]
    ## cardinality = 0..1
    entity_scale_to_size = bool
    ## cardinality = 0..1
    scripted_scale = value[variable]
    ## cardinality = 0..1
    play_animation_once = bool
    ## cardinality = 0..1
    duration = int
    ## cardinality = 0..1
    ## push_scope = ambient_object
    effect = single_alias_right[effect_clause]
}

### Creates a new army in a new transport ship
## scopes = { fleet }
alias[effect:create_army_transport] = {
    ## cardinality = 0..1
    graphical_culture = <graphical_culture>
    army_type = <army>
    ## cardinality = 0..1
    ship_name = localisation
    ## cardinality = 0..1
    army_name = localisation
    ## cardinality = 0..1
    species = scope_group[target_species]
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    ## push_scope = ship
    effect = single_alias_right[effect_clause]
}

### Creates a bypass in the parent SpatialObject (stored in FromFrom), of the type passed in "type".
## scopes = { megastructure }
alias[effect:create_bypass] = {
    owner = scope_group[target_country]
    type = <bypass>

    ## cardinality = 0..1
    ## replace_scopes = { this = bypass fromfrom = megastructure }
    effect = single_alias_right[effect_clause]
}
### Creates a cluster centered around the specified spatial object
## scopes = any
alias[effect:create_cluster] = {
    id = value_set[cluster_id]
    radius = float #no variables here atm
    center = scope[system]
}

### Creates a colony on the scoped planet
## scopes = { planet }
alias[effect:create_colony] = {
    owner = scope_group[target_country]
    ## cardinality = 0..1
    species = scope_group[target_species]
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    species = scalar	#key
    ## cardinality = 0..1
    ethos = random
    ## cardinality = 0..1
    # Specifically this keyword, not all scopes
    ethos = owner
    ## cardinality = 0..1
    ethos = {
        ## cardinality = 1..3
        ## cardinality_max_define = "NGameplay/ETHOS_MAX_POINTS"
        ethic = <ethic>
    }
}

# create_fleet = { name = <string> effect = { <create_ship, set_owner, set_location etc effects go here> } }
### Creates a new fleet
## scopes = any
alias[effect:create_fleet] = {
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    name = scope[fleet]
    ## cardinality = 0..1
    parent = sceop[fleet]
    ## cardinality = 0..1
    parent = none
    ## cardinality = 0..1
    set_take_point = bool
    ## cardinality = 0..inf
    settings = single_alias_right[fleet_settings]
    ### Must include set_owner, set_location and create_ship (here or in last_created_country). Todo: Check this somehow
    ## cardinality = 0..1
    ## push_scope = fleet
    effect = single_alias_right[effect_clause]
    ### <integer value between 1 and the amount of growth stages in the design> (optional, use the first growth stage by default)
    ## cardinality = 0..1
    growth_stage = int
}

### Set fleet's settings, any unspecified setting will set to default value.
## scopes = { fleet }
alias[effect:set_fleet_settings] = single_alias_right[fleet_settings]

single_alias[fleet_settings] = {
    ## cardinality = 0..1
    spawn_debris = bool
    ## cardinality = 0..1
    garrison = bool
    ## cardinality = 0..1
    can_upgrade = bool
    ## cardinality = 0..1
    can_disband = bool
    ## cardinality = 0..1
    can_change_composition = bool
    ## cardinality = 0..1
    can_change_leader = bool
    ## cardinality = 0..1
    uses_naval_capacity = bool
    ## cardinality = 0..1
    is_boss = bool
    ## cardinality = 0..1
    ai_ignore_strength = bool
    ## cardinality = 0..1
    is_ultra_boss = bool
}

### Creates a message, can take multiple variables
## scopes = any
alias[effect:create_message] = {
    type = <message_type>
    ## cardinality = 0..1
    localization = localisation
    days = int #no variables here atm
    ## cardinality = 0..1
    custom_toast_content_text = localisation
    ## cardinality = 0..1
    custom_toast_content_icon = <sprite>
    ## cardinality = 0..1
    target = scope[any]
    ## cardinality = 0..1
    recipient = scope[any]
    ## cardinality = 0..100
    variable = {
        ## cardinality = 0..1
        varname = value[variable]
        ## cardinality = 0..1
        type = enum[mesage_variable_type]
        ## cardinality = 0..1
        key = scalar
        ## cardinality = 0..1
        value = scalar
        ## cardinality = 0..1
        localization = scalar		#not localisation, but rather something that can be used in localisation
        ## cardinality = 0..1
        scope = scope[any]
        ## cardinality = 0..1
        trigger = single_alias_right[trigger_clause]
    }
}

enums = {
    enum[mesage_variable_type] = {
        key
        name
        variable
    }
}

### Creates a military fleet with the designs of a specified country.
## scopes = any
alias[effect:create_military_fleet] = {
    owner = scope_group[target_country]
    scaled_size = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }
    effect = single_alias_right[effect_clause]
}

### Creates a mining station in orbit of the scoped planet
## scopes = { planet astral_rift }
alias[effect:create_mining_station] = {
    owner = scope_group[target_country]
    ## cardinality = 0..1
    ## push_scope = ship
    effect = single_alias_right[effect_clause]
}

### Creates a point of interest for the scoped country at a specific location, associated with an event chain
## scopes = { planet country ship pop_group }
alias[effect:create_point_of_interest] = {
    id = value_set[point_of_interest]
    ### Leaving out "name" gives a blank button that looks really terrible and unprofessional. Don't do it :P
    ## severity = info
    ## cardinality = ~1..1
    name = localisation
    #The last comment does not apply here.
    ## cardinality = 0..1
    desc = localisation
    event_chain = <event_chain>
    ## severity = warning
    ## cardinality = 0..1
    location = scope_group[spatial_object]
    ## cardinality = 0..1
    location = scope[country]
    ## cardinality = 0..1
    location = scope[pop_group]
    ## cardinality = 0..1
    location = scope[leader]
    ## cardinality = 0..1
    location = scope[deposit]
    ## cardinality = 0..1
    location = scope[army]
    ## cardinality = 0..1
    category = scalar
    ## cardinality = 0..1
    picture = <sprite>
}

### Adds pop size on the scoped planet
## scopes = { planet }
alias[effect:create_pop] = {
    ## cardinality = 0..1
    species = scope_group[target_species]
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    species = scalar	#key
    ## cardinality = 0..1
    pop_group = scope[pop_group]
    ## cardinality = 0..1
    ethos = random
    ## cardinality = 0..1
    ethos = scope[pop_group]
    ## cardinality = 0..1
    ethos = scope_group[target_country]
    ## cardinality = 0..1
    ethos = {
        ## cardinality = 1..1
        ethic = <ethic>
    }
    ### (optional, default: POP_BULK_UNIT_SIZE)
    ## cardinality = 0..1
    size = int
    ## cardinality = 0..1
    ## push_scope = pop_group
    effect = single_alias_right[effect_clause]
}


### Creates a new pop_group on the scoped planet
## scopes = { planet }
alias[effect:create_pop_group] = {
    ## cardinality = 0..1
    species = scope_group[target_species]
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    species = scalar	#key
    ## cardinality = 0..1
    pop_group = scope[pop_group]
    ## cardinality = 0..1
    ethos = random
    ## cardinality = 0..1
    ethos = scope[pop_group]
    ## cardinality = 0..1
    ethos = scope_group[target_country]
    ## cardinality = 0..1
    ethos = {
        ## cardinality = 1..1
        ethic = <ethic>
    }
    ### (optional; if omitted and no base group is defined, use lowest rank pop category)
    ## cardinality = 0..1
    category = <pop_category>
    ### (optional, default: POP_BULK_UNIT_SIZE)
    ## cardinality = 0..1
    size = int_value_field
    ### If set, the amount will be randomized in [size - random, size + random]. The minimum value is 0 if size is 0, and 1 otherwise.
    ## cardinality = 0..1
    random = int_value_field
    ## cardinality = 0..1
    ## push_scope = pop_group
    effect = single_alias_right[effect_clause]

}

### Creates a research station in orbit of the scoped planet
## scopes = { planet astral_rift }
alias[effect:create_research_station] = {
    owner = scope_group[target_country]
    ## cardinality = 0..1
    ## push_scope = ship
    effect = single_alias_right[effect_clause]
}

### Creates a new saved leader for the scoped country with a lookup key
## scopes = { country }
alias[effect:create_saved_leader] = {
    key = value_set[saved_leader]
    ## cardinality = 0..1
    creator = scope_group[target_country]
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    name = random
    ## cardinality = 0..1
    gender = enum[gender]
    ## cardinality = 0..1
    class = random
    ## cardinality = 0..1
    class = <leader_class>
    species = scope_group[target_species]
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    event_leader = bool
    ## cardinality = 0..1
    set_age = value_field
    ## cardinality = 0..1
    skill = random
    ## cardinality = 0..1
    skill = int[1..20]
    ## cardinality = 0..1
    traits = {
        ## cardinality = 0..inf
        int = <trait.leader_trait>
        ## cardinality = 0..inf
        trait = <trait.leader_trait>
        ## cardinality = 0..inf
        trait = random_trait
    }
    ## push_scope = leader
    ## cardinality = 0..1
    effect = single_alias_right[effect_clause]
}

### Creates a new ship
## scopes = { fleet starbase }
alias[effect:create_ship] = {
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    name = random
    ## cardinality = 0..1
    name = scope[ship]
    ## cardinality = 0..1
    design = <global_ship_design>
    ## cardinality = 0..1
    design = scope[design]
    ## cardinality = 0..1
    design = last_created_design
    ## cardinality = 0..1
    random_existing_design = <ship_size>
    ## cardinality = 0..1
    prefix = bool
    ## cardinality = 0..1
    graphical_culture = <graphical_culture>
    ## cardinality = 0..1
    graphical_culture = scope[species]
    ## cardinality = 0..1
    graphical_culture = scope_group[target_country]
    ## cardinality = 0..1
    graphical_culture_fallback = <graphical_culture>
    ## cardinality = 0..1
    graphical_culture_fallback = scope[species]
    ## cardinality = 0..1
    graphical_culture_fallback = scope_group[target_country]
    ## cardinality = 0..1
    prefix = bool
    ## cardinality = 0..1
    upgradable = bool
    ## cardinality = 0..1
    ### Used if the created ship is a colony ship
    colonizer_species = scope_group[target_species]
    ### (optional)
    ## cardinality = 0..1
    age = int
    ## cardinality = 0..1
    age = min
    ## cardinality = 0..1
    age = random
    ###  <common/rare/epic/exceptional, used only if ship is space fauna> (optional, fallbacks to highest owned genetic material if applicable but not set)
    ## cardinality = 0..1
    rarity = enum[ship_rarity]
    ## cardinality = 0..1
    ## push_scope = ship
    effect = single_alias_right[effect_clause]
}

### Creates a new ship design for use with last_created_design target
## scopes = any
alias[effect:create_ship_design] = {
    design = localisation
}

### Trigger an assertion to stop the debugger when encountering this effect; argument is ignored
## scopes = any
alias[effect:debug_break] = yes
### Deletes the target mega structure (no death graphics)
## scopes = any
alias[effect:delete_megastructure] = scope[megastructure]
### Dismantles the scoped orbital station (fleet)
## scopes = { fleet }
alias[effect:dismantle] = yes
### Force-end rivalry with target country
## scopes = { country }
alias[effect:end_rivalry] = scope_group[target_country]
### Send endgame telemetry event
## scopes = any
alias[effect:endgame_telemetry] = scalar
### Establish communications between scoped country and target country
## scopes = { country }
alias[effect:establish_communications] = scope_group[target_country]
### Finish the current upgrade of a Mega Structure.
## scopes = { megastructure }
alias[effect:finish_upgrade] = yes
### Sends a fleet to research a special project
## scopes = { fleet }
alias[effect:fleet_action_research_special_project] = {
    special_project = <special_project>
    target = scope_group[spatial_object]
}

### Forces target pop group to immediately evaluate their attraction to various pop factions
## scopes = { pop_group }
alias[effect:force_faction_evaluation] = yes
### Copies a value from the galaxy setup into a variable, optionally scaling it by an int value
## scopes = any
alias[effect:get_galaxy_setup_value] = {
    which = value_set[variable]
    setting = enum[galaxy_setup_value]
    ## cardinality = 0..1
    scale_by = float #no variables here atm
}

### Makes a country guarantee another country
## scopes = { country }
alias[effect:guarantee_country] = scope_group[target_country]
### Makes a country guarantee another country
## scopes = { country }
alias[effect:guarantee_country] = {
    ### free_guarantee_days is deprecated, does nothing
    target = scope_group[target_country]
}

### Executes the first appropriate effect set for a specific trigger treated as NOT.
## scopes = any
alias[effect:inverted_switch] = {
    trigger = alias_keys_field[trigger]
    ## cardinality = 0..inf
    scalar = single_alias_right[effect_clause]
    ## cardinality = 0..1
    default = single_alias_right[effect_clause]
}

### Join federation with target
## scopes = { country }
alias[effect:join_alliance] = {
    who = scope_group[target_country]
    override_requirements = bool
    alias_name[name] = alias_match_left[name]
}

### Removes scoped country from any alliances it is in
## scopes = { country }
alias[effect:leave_alliance] = {
    override_requirements = bool
    ## cardinality = 0..1
    apply_opinion_penalty = bool
}

### Prints a message to game.log for debugging purposes.
## scopes = any
alias[effect:log] = single_alias_right[effect_clause]

### Prints a message to game.log for debugging purposes.
## scopes = any
alias[effect:log] = scalar
### Modifies army with parameters:
## scopes = { army }
alias[effect:modify_army] = {
    ## cardinality = 0..1
    name = random
    ## cardinality = 0..1
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    owner = scope_group[target_country]
    ## cardinality = 0..1
    species = scope_group[target_species]
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    type = <army>
}

### Randomly mutate a species.
## scopes = { species }
alias[effect:mutate_species] = yes

### Forces scoped fleet to retreat to friendly territory
## scopes = { fleet }
alias[effect:order_forced_return] = yes
### Play the defined sound effect
## scopes = any
alias[effect:play_sound] = <sound_effect>
### Adds a specific ethic to the scoped pop_group regardless if pop_group-species allows ethic divergence or not.
## scopes = { pop_group }
alias[effect:pop_force_add_ethic] = {
    ethic = <ethic>
    ## cardinality = 0..1
    amount = int_value_field
    ## cardinality = 0..1
    percentage = float[0.0..1.0]
    ## cardinality = 0..1
    random = int_value_field
}
### Removes a specific ethic from the scoped pop_group
## scopes = { pop_group }
alias[effect:pop_remove_ethic] = {
    ethic = <ethic>
    ## cardinality = 0..1
    amount = int_value_field
    ## cardinality = 0..1
    percentage = float[0.0..1.0]
    ## cardinality = 0..1
    random = int_value_field
}
### Disables or enables anomaly generation for the scoped planet
## scopes = { planet }
alias[effect:prevent_anomaly] = bool
#randomize_flag_symbol = pirate
### Randomizes a country's flag symbol within the selected category
## scopes = { country }
alias[effect:randomize_flag_symbol] = scalar #TODO pirate
### Removes all armies on scoped planet
## scopes = { planet }
alias[effect:remove_all_armies] = yes
### Removes the scoped army
## scopes = { army }
alias[effect:remove_army] = yes
### Makes a fleet or ship stop auto-moving
## scopes = { ship fleet }
alias[effect:remove_auto_move_target] = yes
### Removes existing hyperlane between two systems
## scopes = any
alias[effect:remove_hyperlane] = {
    from = scope[galactic_object]
    to = scope[galactic_object]
}

### Remove a notification modifier to the country
## scopes = { country }
alias[effect:remove_notification_modifier] = <notification_modifier>
# ### Removes the orbital deposit slot from the scoped planet
#alias[effect:remove_orbital_deposit] = yes
### Removes a specific point of interest from the scoped country's situation log
## scopes = { country }
alias[effect:remove_point_of_interest] = value[point_of_interest]
### Removes a saved leader for the scoped country with a lookup key
## scopes = { country }
alias[effect:remove_saved_leader] = value[saved_leader]

### Renames the species.
## scopes = { species }
alias[effect:rename_species] = {
    ## cardinality = 0..1
    prompt_country = scope_group[target_country]
    ## cardinality = 0..1
    name = scalar
    ## cardinality = 0..1
    name = random
    ## cardinality = 0..1
    ### Name lists defined in the name_lists folder might not work (where would it get the name from?). Rather, Vanilla uses ones defined in species_names. Let Dayshine and Caligula know if ones in name_lists work. (Same with name_list = random and name_list = country).
    name_list = <species_named_list>
}

### Restores a certain percentage of hull points to the scoped ship
## scopes = { ship fleet }
alias[effect:repair_percentage] = value_field[0.0..1.0]

### Restores a certain percentage of armor points to the scoped ship
## scopes = { ship fleet }
alias[effect:repair_armor_percentage] = value_field[0.0..1.0]

### Restores all hull points to the scoped ship
## scopes = { ship }
alias[effect:repair_ship] = yes
### Resets years of peace for a country.
## scopes = { country }
alias[effect:reset_years_of_peace] = yes
### Runs strategic data for AI
## scopes = { country }
alias[effect:run_ai_strategic_data] = yes
### Enables or disables the VIR window pop_group-in
## scopes = { country }
alias[effect:set_advisor_active] = bool
### Sets the scoped fleet/country's aggro range in intra-system units
## scopes = { country fleet }
alias[effect:set_aggro_range] = int_value_field
### Determines whether the scoped fleet/country's aggro range is measured from the fleet's current position or its spawn location
## scopes = { country fleet }
alias[effect:set_aggro_range_measure_from] = enum[aggro_range_measure_from]

enums = {
    enum[aggro_range_measure_from] = {
        self
        return_point
    }
}

### Sets an asteroid belt at the distance in the scope.
### Example:
## scopes = { galactic_object }
alias[effect:set_asteroid_belt] = {
    ## cardinality = 0..1
    radius = float #no variables here atm
    ## cardinality = 0..1
    type = <asteroid_belt_type>
}

### Sets the scoped planet to be the capital of its owner country
## scopes = { planet }
alias[effect:set_capital] = yes
### Sets the scoped country's city graphical culture
## scopes = { country }
alias[effect:set_city_graphical_culture] = <graphical_culture>
### Changes the country type of the scoped country
## scopes = { country }
alias[effect:set_country_type] = <country_type>
### Sets the crisis ambient loop to the current effect
## scopes = any
alias[effect:set_crisis_sound] = <sound_effect>
### Sets a custom spatial object as custom country capital location.
## scopes = { country }
alias[effect:set_custom_capital_location] = scope_group[spatial_object]
### Sets the scoped ship to become disabled at a certain hull point percentage
## scopes = { ship fleet }
alias[effect:set_disable_at_health] = value_field[0.0..1.0]
### Enables or disables the scoped ship
## scopes = { ship }
alias[effect:set_disabled] = bool
### Sets the flag of the current Empire.
## scopes = { country }
alias[effect:set_empire_flag] = scalar #TODO PLS 1.2.4+
### Sets the name of the current Empire.
## scopes = { country }
alias[effect:set_empire_name] = localisation
### Silently disables the scoped fleet to prevent player action, remember to unlock at the end of the event
## scopes = { fleet }
alias[effect:set_event_locked] = bool
### Sets the aggro state of the scoped faction-type country
## scopes = { country }
alias[effect:set_faction_hostility] = {
    ## cardinality = 0..1
    target = scope_group[target_country]
    ## cardinality = 0..1
    set_hostile = bool
    ## cardinality = 0..1
    set_neutral = bool
    ## cardinality = 0..1
    set_friendly = bool
}

### Sets a country to lead a federation
## scopes = { country federation }
alias[effect:set_federation_leader] = scope[country]
### Sets the bombardment stance of the scoped fleet
## scopes = { fleet }
alias[effect:set_fleet_bombardment_stance] = <bombardment_stance>
### Sets a custom fleet formation on a fleet.
## scopes = { fleet }
alias[effect:set_fleet_formation] = {
    ## cardinality = 0..100
    position = {
        x = float
        y = float
    }
}

### Sets the stance of the scoped fleet
## scopes = { fleet }
alias[effect:set_fleet_stance] = enum[fleet_stance]
### Scales the scoped fleet's formation's ship spacing, above and below 1.0
## scopes = { fleet }
alias[effect:set_formation_scale] = value_field
### Sets the mega structure upgrade to halted status for n days. -1 days = indefinitely
## scopes = { megastructure }
alias[effect:set_halted] = int_value_field
### Sets the target leader to be the scoped country's heir
## scopes = { country }
alias[effect:set_heir] = scope[leader]
### Set the home base of the scoped fleet to the specified starbase
## scopes = { fleet }
alias[effect:set_home_base] = scope[starbase]
### Sets the current mission of an observation station
## scopes = { fleet }
alias[effect:set_mission] = <observation_station_mission>
### Change entity of a planet.
### Example:
## scopes = { planet }
alias[effect:set_planet_entity] = {
    ## cardinality = 0..1
    entity = scalar # TODO entity suffixes
    ## cardinality = 0..1
    entity = <model_entity>
    ## cardinality = 0..1
    graphical_culture = <graphical_culture>
    ## cardinality = 0..1
    graphical_culture = scope[species]
    ## cardinality = 0..1
    graphical_culture = scope_group[target_country]
    ## cardinality = 0..1
    picture = scalar	#filepath #TODO picture
    ## cardinality = 0..1
    atmosphere_color = colour[hsv]
    ## cardinality = 0..1
    atmosphere_intensity = float[0.0..1.0]
    ## cardinality = 0..1
    atmosphere_width = float[0.0..1.0]
}

### Sets the name of the current planet.
## scopes = { planet }
alias[effect:set_planet_name] = scalar
### Sets a policy to a specific option for the scoped country and specifies if policy cooldown should go into effect
## scopes = { country }
alias[effect:set_policy] = {
    policy = <policy>
    option = enum[policy_option]
    ## cardinality = 0..1
    cooldown = bool
}

### Sets the scoped pop_group to belong to a specific pop_group faction
## scopes = { pop_group }
alias[effect:set_pop_faction] = <pop_faction>

### Adds or removes a planetary ring around the scoped planet
## scopes = { planet }
alias[effect:set_ring] = bool
### Sets the scoped leader's level
## scopes = { leader }
alias[effect:set_skill] = int_value_field
### Optimizes the calls for spawn_system effect.
### Spawn system should be located in a block between Begin and End.
### Begin: set_spawn_system_batch = begin
### End: set_spawn_system_batch = end
## scopes = any
alias[effect:set_spawn_system_batch] = enum[optimisation_batch]

### Disables modifier system to do full updates between Begin and End.
## scopes = any
alias[effect:set_update_modifiers_batch] = enum[optimisation_batch]

enums = {
    enum[optimisation_batch] = {
        begin
        end
    }
}

### Defines a homeworld for the current species.
## scopes = { species }
alias[effect:set_species_homeworld] = scope_group[target_planet]
### Sets the current species scopes identity to match the target scopes making them evaluate as the same species in is_same_species trigger.
## scopes = { species }
alias[effect:set_species_identity] = scope_group[target_species]
### Sets a building in a slot on a starbase
## scopes = { starbase }
alias[effect:set_starbase_building] = {
    slot = int #no variables here atm
    building = <starbase_building>
}

### Sets a module in a slot on a starbase
## scopes = { starbase }
alias[effect:set_starbase_module] = {
    slot = int #no variables here atm
    module = <starbase_module>
}

### Sets the ship size of a starbase
## scopes = { starbase }
alias[effect:set_starbase_size] = <ship_size.starbase>
### Changes the scoped country's tutorial level (0 none, 1 limited, 2 full)
## scopes = { country }
alias[effect:set_tutorial_level] = enum[tutorial_level]
### Spawns a mega structure in a system.
## scopes = { galactic_object }
alias[effect:spawn_megastructure] = {
    type = <megastructure>
    ## cardinality = 0..1
    planet = scope_group[target_planet]
    ## cardinality = 0..1
    coords_from = scope_group[spatial_object]
    alias_name[name] = alias_match_left[name]
    ## cardinality = 0..1
    orbit_angle = random
    ## cardinality = 0..1
    orbit_angle = int[-360..360]
    ## cardinality = 0..1
    orbit_angle = { min = int[-360..360] max = int[-360..360] }
    ## cardinality = 0..1
    orbit_distance = float
    ## cardinality = 0..1
    orbit_distance = { min = float max = float }
    ## cardinality = 0..1
    owner = scope_group[target_country]
    ## cardinality = 0..1
    graphical_culture = <graphical_culture>
    ## cardinality = 0..1
    graphical_culture = scope[country]
    ## cardinality = 0..1
    graphical_culture = scope[megastructure]
    ## cardinality = 0..1
    graphical_culture = scope[ship]
    ## cardinality = 0..1
    random_pos = bool
    ## cardinality = 0..1
    ## push_scope = megastructure
    init_effect = single_alias_right[effect_clause]
}

### Spawns a planet in a system.
## scopes = { galactic_object }
alias[effect:spawn_planet] = {
    class = <planet_class>
    class = <planet_class_random_list>
    class = random
    class = random_colonizable
    ## cardinality = 0..1
    generate_random_name = bool
    ## cardinality = 0..1
    name = localisation
    ## cardinality = 0..1
    location = scope_group[celestial_coordinate]
    ## cardinality = 0..1
    orbit_location = bool
    ## cardinality = 0..1
    orbit_distance = float
    ## cardinality = 0..1
    orbit_distance = { min = float max = float }
    ## cardinality = 0..1
    orbit_distance_offset = value_field
    ## cardinality = 0..1
    plane_offset = float
    ## cardinality = 0..1
    deposit_blockers = none
    ## cardinality = 0..1
    modifiers = none
    ## cardinality = 0..inf
    modifier = <planet_modifier>
    ## cardinality = 0..1
    flags = {
        ## cardinality = 0..inf
        value_set[planet_flag]
    }
    ## cardinality = 0..1
    size = int
    ## cardinality = 0..1
    size = random
    ## cardinality = 0..1
    has_ring = bool
    ### default: no
    ## cardinality = 0..1
    spawn_beyond_gravity_well = bool
    ## cardinality = 0..1
    orbit_angle = random
    ## cardinality = 0..1
    orbit_angle = int[-360..360]
    ## cardinality = 0..1
    orbit_angle = { min = int[-360..360] max = int[-360..360] }
    ## cardinality = 0..1
    orbit_angle_offset = float
    ## cardinality = 0..1
    ## push_scope = planet
    init_effect = single_alias_right[effect_clause]
}

### Spawns a new system at a position relative to the scoped system/planet/ship.
## scopes = { megastructure planet ship fleet galactic_object starbase no_scope }
## push_scope = galactic_object
alias[effect:spawn_system] = {
    ## cardinality = 0..1
    min_distance = float
    ## cardinality = 0..1
    max_distance = float
    ## cardinality = 0..1
    min_jumps = int[0..1000]
    ## cardinality = 0..1
    max_jumps = int[0..1000]
    initializer = <solar_system_initializer>
    initializer = random
    ## cardinality = 0..1
    hyperlane = bool
    ## cardinality = 0..1
    is_discovered = bool
    ## cardinality = 0..1
    min_orientation_angle = float
    ## cardinality = 0..1
    max_orientation_angle = float
    ## cardinality = 0..1
    direction = corewards
    ## cardinality = 0..1
    direction = rimwards
    ## cardinality = 0..1
    effect = single_alias_right[effect_clause]

    ## cardinality = 0..1
    authorize_spawn_on_galactic_core = bool
}

### Starts colonization of the scoped planet
## scopes = { planet }
alias[effect:start_colony] = {
    owner = scope_group[target_country]
    ## cardinality = 0..1
    species = scope_group[target_species]
    ## cardinality = 0..1
    species = enum[buildable_pop_species]
    ## cardinality = 0..1
    species = scalar	#key
    ## cardinality = 0..1
    ethos = owner
    ## cardinality = 0..1
    ethos = {
        ## cardinality = 1..10
        ethic = <ethic>
    }
    ## cardinality = 0..1
    ethos = random
}

### Stops the crisis ambient loop
## scopes = any
alias[effect:stop_crisis_sound] = yes

### Executes the first appropriate effect set for a specific trigger
## scopes = any
alias[effect:switch] = {
    trigger = alias_keys_field[trigger]
    ## cardinality = 0..inf
    scalar = single_alias_right[effect_clause]
    ## cardinality = 0..1
    default = single_alias_right[effect_clause]
}

### Just a tooltip (shows the effect but does not run it)
## scopes = any
alias[effect:tooltip] = single_alias_right[effect_clause]

### if a planet has trigger_megastructure_icon = yes then the map icon for the star will show a megastructure icon
## scopes = { planet }
alias[effect:trigger_megastructure_icon] = yes
### Starts an upgrade process on a mega structure.
## scopes = { megastructure }
alias[effect:upgrade_megastructure_to] = <megastructure>

# 2.2

### Adds specific resource to the stockpile for the country scope:
## scopes = { country }
alias[effect:add_resource] = {
    ## cardinality = 1..inf
    <resource> = float
    ## cardinality = 0..1
    mult = value_field
    ## cardinality = 0..1
    multiplier = value_field
}

### Adds a new timeline event for the scope country.
## scopes = { country }
alias[effect:add_timeline_event] = {
    type = <timeline_events>
    ### 2300.1.1 (optional - if not present, current date is used)
    ## cardinality = 0..1
    date = scalar
    ## cardinality = 0..1
    ###(There is also overrides that can be used to override settings on the database entries. The Id is required, and the others are optional)
    override_id = value_set[timeline_event_id]
    ## cardinality = 0..1
    ### override_tooltip
    override_tooltip = localisation
    ## cardinality = 0..1
    override_types = {
        ## cardinality = 0..inf
        enum[scope_type_token]
    }
    ## cardinality = 0..1
    override_text = {
        ## cardinality = 0..inf
        value[gui_element_name]:localisation
    }
    ## cardinality = 0..1
    override_texture = {
        ## cardinality = 0..inf
        value[gui_element_name]:<sprite>
    }
    ## cardinality = 0..1
    ### (optional - array of event targets. This depends on localization and what event targets the type requires)
    targets = {
        ## cardinality = 0..inf
        scope[any]
    }
    ## cardinality = 0..1
    ### loc_delayed_tooltip
    override_tooltip_delayed  = localisation

}

### Proposes the resolution of the given type
## scopes = { country }
alias[effect:propose_resolution] = {
    resolution = <resolution>
    target = scope_group[target_country]
}

### Weighted random on owned popgroups based on the popgroup size. Supports the same scopes as the owned_pop_group script list
## scopes = { planet country pop_faction sector }
## push_scope = pop_group
alias[effect:weighted_random_owned_pop_group] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Sets the trade conversions for the scoped Country. If they do not add up to 1.0 any remaining trade the country keeps as income
## scopes = { country }
alias[effect:set_trade_conversions] = {
    ## cardinality = 0..inf
    <resource> = value_field
}

### Sets the specific resource to the stockpile for the country scope:
## scopes = { country }
alias[effect:set_resource] = {
    ## cardinality = 1..1
    resource = <resource>
    ## cardinality = 1..1
    value = value_field
}

### Remove resource deposit on the scoped planet or deposit, does not fire on_cleared if used on a blocker
## scopes = { planet deposit astral_rift }
alias[effect:remove_deposit] = yes
### Remove resource deposit on the scoped planet or deposit, does not fire on_cleared if used on a blocker
## scopes = { planet deposit astral_rift }
alias[effect:remove_deposit] = <deposit>

### Fires scoped pop_group from its job
## scopes = { pop }
alias[effect:unemploy_pop] = yes

### Immediately runs a job evaluation on the planet, firing and employing pops as needed
## scopes = { planet }
alias[effect:check_planet_employment] = yes

### Adds random non-blocker resource deposit to the scoped planet
## scopes = { planet }
alias[effect:add_random_non_blocker_deposit] = yes
### Removes last built building from the scoped planet
## scopes = { planet }
alias[effect:remove_random_building] = yes
### Removes all buildings from the scoped planet
## scopes = { planet }
alias[effect:remove_all_buildings] = yes
### Repairs all ruined buildings on the scoped planet
## scopes = { planet }
alias[effect:repair_all_buildings] = yes
### Downgrades all non-capital buildings on the scoped planet/country. Leaves tier 1 buildings untouched.
## scopes = { planet country }
alias[effect:downgrade_all_buildings] = yes
### Downgrades all buildings of a specified type on the planet/country.
## scopes = { planet country }
alias[effect:downgrade_buildings_of_type] = <building>
### Instantly adds devastation to scoped planet
## scopes = { planet }
alias[effect:add_planet_devastation] = value_field[-100..100]

### Forces target planet or country to calculate its internal modifier
## scopes = { planet country }
alias[effect:calculate_modifier] = yes
### Establish branch office on scoped planet for target country
## scopes = { planet }
alias[effect:establish_branch_office] = scope_group[target_country]
### Close branch office on scoped planet
## scopes = { planet }
alias[effect:close_branch_office] = yes
### Removes all blockers from the scoped planet
## scopes = { planet }
alias[effect:clear_blockers] = yes
### Changes the built species of the scoped object
## scopes = { country }
alias[effect:set_built_species] = scope_group[target_species]
### Removes a random district from the scoped planet. Bigger district is more likely to be removed.
## scopes = { planet }
alias[effect:remove_random_district] = yes
### Removes all districts from the scoped planet
## scopes = { planet }
alias[effect:remove_all_districts] = yes
### Removes a specific district from the scoped planet
## scopes = { planet }
alias[effect:remove_district] = <district>
### Begins construction of a specific district on the scoped planet
## scopes = { planet }
alias[effect:add_district] = <district>
### Begins construction of a specific district on the scoped planet
## scopes = { planet }
alias[effect:add_district] = {
    district_type = <district>
    ## cardinality = 0..1
    ignore_cap = yes
    ## cardinality = 0..1
    type_conversion = yes
}

### Enables a resource on the Galactic Market
## scopes = any
alias[effect:enable_on_market] = <resource>
### Enables the galactic market. enable_galactic_market = <yes/no>
## scopes = { country }
alias[effect:enable_galactic_market] = bool
### Checks whether the planets and districts on the planet are valid (their potential triggers are fulfilled), removes or replaces them if not.
## scopes = { planet }
alias[effect:validate_planet_buildings_and_districts] = yes
### Clears scoped deposit blocker and fires its on_cleared effect
## scopes = { deposit }
alias[effect:clear_blocker] = yes
### Changes the portrait of the species in scope.
## scopes = { species }
alias[effect:change_species_portrait] = scope_group[target_species]
### Changes the portrait of the species in scope.
## scopes = { species }
alias[effect:change_species_portrait] = <portrait>
### Changes the portrait of the species in scope.
## scopes = { species }
alias[effect:change_species_portrait] = <portrait_group>
### Changes the portrait of the species in scope.
## scopes = { species }
alias[effect:change_species_portrait] = random
### Rebuild resource deposits on target planet
## scopes = { planet }
alias[effect:reroll_deposits] = yes

# 2.3

### Creates a archaeological site associated with the scope object
## scopes = { megastructure planet ship fleet galactic_object ambient_object starbase debris astral_rift }
alias[effect:create_archaeological_site] = <archaeological_site_type>
### Creates a archaeological site associated with the scope object
## scopes = { megastructure planet ship fleet galactic_object ambient_object starbase debris astral_rift }
alias[effect:create_archaeological_site] = random
### Destroys a archaeological site in right hand site event target
## scopes = any
alias[effect:destroy_archaeological_site] = scope[archaeological_site]
### Adds clues to the current stage of an archaeological or first contact site
## scopes = { archaeological_site first_contact astral_rift }
alias[effect:add_stage_clues] = int_value_field
### Adds clues to the current stage of an archaeological or first contact site
## scopes = { archaeological_site first_contact astral_rift }
alias[effect:add_stage_clues] = lower_insight_reward
### Adds clues to the current stage of an archaeological or first contact site
## scopes = { archaeological_site first_contact astral_rift }
alias[effect:add_stage_clues] = higher_insight_reward
### Adds a specific expedition log entry to an archaeological site chapter
## scopes = { archaeological_site }
alias[effect:add_expedition_log_entry] = who_knows_tell_us_please
### Resets the current stage
## scopes = { archaeological_site }
alias[effect:reset_current_stage] = yes
### Sets the current stage for this arc site (first chapter is index 0).
## scopes = { archaeological_site }
alias[effect:set_current_stage] = int[0..inf]
### Finish the current stage
## scopes = { archaeological_site }
alias[effect:finish_current_stage] = yes
### Finish the current stage. yes = trigger stage completed for each stage and current excavator. no = do not trigger any stage completed. country = use this country instead of excavator, no stage complete will be triggered.
## scopes = { archaeological_site }
alias[effect:finish_site] = bool
### Finish the current stage. yes = trigger stage completed for each stage and current excavator. no = do not trigger any stage completed. country = use this country instead of excavator, no stage complete will be triggered.
## scopes = { archaeological_site }
alias[effect:finish_site] = country
### Locks or unlocks the progress of a site
## scopes = { archaeological_site first_contact }
alias[effect:set_site_progress_locked] = bool
### Displays a specific localization string with parameters in tooltip
## scopes = any
alias[effect:custom_tooltip_with_params] = {
    description = localisation
    ## cardinality = 0..1
    description_parameters = {
        ### Any value can go here to be used in localisation
        ## cardinality = 0..inf
        $localisation_parameter = scalar
    }
}

### Adds the specified relic to the scoped country. add_relic = <relic_key>
## scopes = { country }
alias[effect:add_relic] = <relic>
### Adds the specified relic to the scoped country. add_relic = <relic_key>
## scopes = { country }
alias[effect:add_relic] = {

    key = <relic>
    ## cardinality = 0..1
    full_description = bool
}
### Removes the specified relic from the scoped country. remove_relic = <relic_key>
## scopes = { country }
alias[effect:remove_relic] = <relic>
### Manually flags an archaeological event as expired
## scopes = { archaeological_site }
alias[effect:expire_site_event] = <event.fleet>

# 2.5.1 (or missing from earlier)

### Adds a specific trait to the scoped leader for a specific duration
## scopes = { leader }
alias[effect:add_timed_trait] = {
    trait = <trait>
    enum[days_months_year] = int_value_field
}

### Recomputes strategic war ( attack / defense ) data for AI = yes
## scopes = { country }
alias[effect:run_ai_strategic_war_data] = yes
### Set scoped country as the current Galactic Market leader. set_market_leader = <yes/no>
## scopes = { country }
alias[effect:set_market_leader] = bool
### Steal all/a random/a specific relic from a target country
## scopes = { country }
alias[effect:steal_relic] = {
    target = scope_group[target_country]
    relic = <relic>
    relic = all
    relic = random
}

# 2.6

### Add <value> favors for scoped country to use on target country.
## scopes = { country }
alias[effect:add_favors] = {
    target = scope_group[target_country]
    value = int_value_field
}

### Remove <value/all> favors that scoped country have on target country:
## scopes = { country }
alias[effect:remove_favors] = {
    target = scope_group[target_country]
    value = int_value_field
    value = all
}

### Sets an arbitrarily-named flag on the scoped federation
## scopes = { federation }
alias[effect:set_federation_flag] = value_set[federation_flag]

### Sets an arbitrarily-named flag on the scoped federation for a set duration
## scopes = { federation }
alias[effect:set_timed_federation_flag] = {
    flag = value_set[federation_flag]
    enum[days_months_year] = int_value_field
}
### Removes a flag from the scoped federation
## scopes = { federation }
## severity = warning
alias[effect:remove_federation_flag] = value[federation_flag]

### Sets the given law for the scoped federation
## scopes = { federation }
alias[effect:set_federation_law] = <federation_law>

### Tries to add the scoped country to the Galactic Community
## scopes = { country }
alias[effect:add_to_galactic_community] = yes

### Tries to add the scoped country to the Galactic Community without producing member joining notifications.
## scopes = { country }
alias[effect:add_to_galactic_community_no_message] = yes

### Tries to remove the scoped country from the Galactic Community
## scopes = { country }
alias[effect:remove_from_galactic_community] = yes

### Tries to add the scoped country to the Galactic Council
## scopes = { country }
alias[effect:add_to_galactic_council] = yes

### Tries to remove the scoped country from the Galactic Council
## scopes = { country }
alias[effect:remove_from_galactic_council] = yes

### Adds experience to the scoped federation
## scopes = { federation }
alias[effect:add_federation_experience] = value_field

### Sets federation type to the scoped federation
## scopes = { federation }
alias[effect:set_federation_type] = <federation_type>

### Sets scoped federation's succession type to the specified value.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_federation_succession_type] = enum[federation_succession_type]

### Sets scoped federation's succession term to the specified value.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_federation_succession_term] = enum[federation_succession_term]

### Sets exclusive right to build fleets by federation leader.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_only_leader_builds_fleets] = bool

### Sets right for subjects to join federation.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_allow_subjects_to_join] = bool

### Sets different voting weight.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_equal_voting_power] = bool

### Sets diplomatic action custom setting.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_diplomacy_action_setting] = {
    action = <diplomatic_action>
    settings = {
        ## cardinality = 0..1
        vote_type = enum[vote_type] #unanimous_vote majority_vote leader
        ## cardinality = 0..1
        acceptance_type = enum[acceptance_type] #leader default
    }
}

### Sets unified migration flag for federation.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_free_migration] = bool

### Sets diplomatic action custom setting.
### Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
## scopes = { federation }
alias[effect:set_federation_settings] = {
    enum[federation_setting] = bool
}

### Add cohesion to the federation
## scopes = { federation }
alias[effect:add_cohesion] = value_field

### Sets the number of seats on the Galactic Council
## scopes = any
alias[effect:set_council_size] = int_value_field

### Increases the number of seats on the Galactic Council by 1
## scopes = any
alias[effect:increase_council_size] = yes

### Decreases the number of seats on the Galactic Council by 1
## scopes = any
alias[effect:decrease_council_size] = yes

### Sets whether council members can veto resolutions or not
## scopes = any
alias[effect:set_council_veto] = bool

### Sets whether council members can propose emergency measures or not
## scopes = any
alias[effect:set_council_emergency_measures] = bool

### Gives provided country a permanent position on the Galactic Council
## scopes = { country }
alias[effect:add_permanent_councillor] = yes

### Remove the provided country from their permanent council position
## scopes = { country }
alias[effect:remove_permanent_councillor] = yes

### Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type.
## scopes = { country }
alias[effect:pass_resolution] = <resolution>

### Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type. Skips the cooldown on the relevant category.
## scopes = { country }
alias[effect:pass_resolution_no_cooldown] = <resolution>

### Removes a specified country from the war
## scopes = { war }
alias[effect:remove_war_participant] = scope_group[target_country]

### Ends all treaties with the target
## scopes = { country }
alias[effect:end_all_treaties_with] = scope_group[target_country]

# 2.7

### Prints a list of the countries that match the limit triggers in a tooltip, each separated by a line break.
## scopes = any
alias[effect:country_list_tooltip] = {
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
}

### Prints a list of the country's planets that match the limit triggers in a tooltip, each separated by a line break.
## scopes = { country }
alias[effect:owned_planet_list_tooltip] = {
    ## push_scope = planet
    limit = single_alias_right[trigger_clause]
}

### Prints a list of the country's pop_group factions that match the limit triggers in a tooltip, each separated by a line break.
## scopes = { country }
alias[effect:owned_pop_faction_list_tooltip] = {
    ## push_scope = pop_faction
    limit = single_alias_right[trigger_clause]
}

### Prints a list of the country's leaders that match the limit triggers in a tooltip, each separated by a line break.
## scopes = { country }
alias[effect:owned_leader_list_tooltip] = {
    ## push_scope = leader
    limit = single_alias_right[trigger_clause]
}

### Prints a list of the country's fleets that match the limit triggers in a tooltip, each separated by a line break.
## scopes = { country }
alias[effect:owned_fleet_list_tooltip] = {
    ## push_scope = fleet
    limit = single_alias_right[trigger_clause]
}

### Locks the leader in its current role for the next X days.
## scopes = { leader }
alias[effect:set_cooldown] = int_value_field

### Sets the scoped planet to be the capital of the sector it is part of. If used in the capital sector, it will shift the empire capital. Warning: Experimental, may have unintended consequences.
## scopes = { planet }
alias[effect:set_sector_capital] = yes

### Sets the colony's designation type
## scopes = { planet }
alias[effect:set_colony_type] = <colony_type>

### Adds civic to a government without checking the restrictions
## scopes = { country }
alias[effect:force_add_civic] = <civic_or_origin.civic>

### Removes civic from a government without checking the restrictions
## scopes = { country }
alias[effect:force_remove_civic] = int[0..inf]
### Removes civic from a government without checking the restrictions
## scopes = { country }
alias[effect:force_remove_civic] = <civic_or_origin.civic>

### Completes a specific special project for the country, firing the on complete effects
## scopes = { country }
alias[effect:complete_special_project] = {
    type = <special_project>
    ## cardinality = 0..1
    location = scope_group[spatial_object]
}

### Force a truce with target country of a specified type, or a war
## scopes = { country }
alias[effect:set_truce] = {
    target = scope_group[target_country]
    type = enum[truce_type]
}

### Force-end truce with target country
## scopes = { country }
alias[effect:end_truce] = scope_group[target_country]


# 2.8

### Removes a module from a certain slot or all slots on a starbase
## scopes = { starbase }
alias[effect:remove_starbase_module] = {
    ## cardinality = 0..1
    ### Optional, default = all
    slot = int #no variables here atm
    ## cardinality = 0..1
    module = <starbase_module>
}

### Remove a building from a certain slot or all slots on a starbase
## scopes = { starbase }
alias[effect:remove_starbase_building] = {
    ## cardinality = 0..1
    ### Optional, default = all
    slot = int #no variables here atm
    ## cardinality = 0..1
    slot = all
    ## cardinality = 0..1
    building = <starbase_building>
}

### Changes the colony foundation date (affecting on_colony_X_years pulses) by a specific number of days. Use with care, you can probably break things with this!
## scopes = { planet }
alias[effect:change_colony_foundation_date] = int_value_field

### Sets the adjective of the scoped country
## scopes = { country }
alias[effect:set_adjective] = localisation
### Sets the adjective of the scoped country
## scopes = { country }
alias[effect:set_adjective] = scope_group[target_country]

### Sets the ship prefix of the scoped country
## scopes = { country }
alias[effect:set_ship_prefix] = localisation
### Sets the ship prefix of the scoped country
## scopes = { country }
alias[effect:set_ship_prefix] = scope_group[target_country]

### Locks the country's government for a given period of days, the default cooldown, or unlocks it.
## scopes = { country }
alias[effect:set_government_cooldown] = int_value_field
### Locks the country's government for a given period of days, the default cooldown, or unlocks it.
## scopes = { country }
alias[effect:set_government_cooldown] = default
### Locks the country's government for a given period of days, the default cooldown, or unlocks it.
## scopes = { country }
alias[effect:set_government_cooldown] = no

### Sets the country's origin to a certain value. Note: This will not run effects executed during galaxy generation.
## scopes = { country }
alias[effect:set_origin] = <civic_or_origin.origin>

# 3.0

### Gives the player the reward for the specified crisis objective
## scopes = { country }
alias[effect:complete_crisis_objective] = <crisis_objective>

### Sets whether the Galactic Emperor can change Imperial Council members or not
## scopes = any
alias[effect:set_emperor_can_change_council_members] = bool

### Sets the specified policy group to have a cooldown as if the policy had just been changed.
## scopes = { country }
alias[effect:set_policy_cooldown] = <policy>

### Sets the current ship or fleet to be destroyed and spawn a debris project for the specified country.
## scopes = { ship fleet }
alias[effect:destroy_and_spawn_debris_for] = scope_group[target_country]

### Sets the star's star class, affecting system and galactic map graphics and potentially modifiers. Also changes the planet class of the system's primary star.
## scopes = { galactic_object }
alias[effect:set_star_class] = <star_class>

### Fires a made-up on_action.
## scopes = any
alias[effect:fire_on_action] = {
    on_action = <on_action>
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Sets the current fleet to go missing in action with the MIA type defided by <key>
## scopes = { fleet }
alias[effect:set_mia] = enum[mia_type]

### If the scoped fleet is MIA, sets the return date in a given number of days, starting from current date
## scopes = { fleet }
alias[effect:set_mia_return_delay] = int_value_field

### Sets the given stage for the scoped first contact
## scopes = { first_contact }
alias[effect:set_first_contact_stage] = <first_contact_stage>

### Ends the First Contact
## scopes = { first_contact }
alias[effect:finish_first_contact] = yes

### Sets an arbitrarily-named flag on the scoped first contact site
## scopes = { first_contact }
alias[effect:set_first_contact_flag] = value_set[first_contact_flag]

### Sets an arbitrarily-named flag on the scoped first contact site for a set duration
## scopes = { first_contact }
alias[effect:set_timed_first_contact_flag] = {
    flag = value_set[first_contact_flag]
    enum[days_months_year] = int_value_field
}
### Removes a flag from the scoped first contact site
## scopes = { first_contact }
## severity = warning
alias[effect:remove_first_contact_flag] = value[first_contact_flag]

### Prints a custom error to the error log
## scopes = any
alias[effect:log_error] = scalar

### Adds a random tech from the target country within the given category and tech area constraints. The country must be able to research said tech (weight > 0, fulfils potential trigger)
## scopes = { country }
alias[effect:copy_random_tech_from] = {
    who = scope_group[target_country]
    ## cardinality = 0..1
    category = <technology_category>
    ## cardinality = 0..1
    area = enum[research_area]
    ## cardinality = 0..1
    ### Optional: this makes it grant the tech option rather than the whole tech
    progress = value_field[0.0..1.0]
}

### Adds the defined amount of intel toward the target empire.
## scopes = { country }
alias[effect:add_intel] = {
    who = scope_group[target_country]
    amount = value_field
}

### Creates espionage asset within a given spy network
## scopes = { spy_network }
alias[effect:create_espionage_asset] = {
    type = <espionage_asset>
    ## cardinality = 0..1
    ## push_scope = espionage_asset
    effect = single_alias_right[effect_clause]
}

### Destroys espionage asset within a given spy network/operation
## scopes = { spy_network espionage_operation }
alias[effect:destroy_espionage_asset] = <espionage_asset>

### Locks or unlocks the progress of an espionage operation
## scopes = { espionage_operation }
alias[effect:set_espionage_operation_progress_locked] = bool

### Unassigns espionage asset from the scope operation to owning spy network
## scopes = { espionage_operation }
alias[effect:unassign_espionage_asset] = <espionage_asset>

### Assigns espionage asset to the scope operation from owning spy network
## scopes = { espionage_operation }
alias[effect:assign_espionage_asset] = <espionage_asset>

### Sets an arbitrarily-named flag on the scoped espionage operation
## scopes = { espionage_operation }
alias[effect:set_espionage_operation_flag] = value_set[espionage_operation_flag]

### Removes a flag from the scoped espionage operation
## scopes = { espionage_operation }
alias[effect:remove_espionage_operation_flag] = value[espionage_operation_flag]
### Sets an arbitrarily-named flag on the scoped espionage operation for a set duration
## scopes = { espionage_operation }
## severity = warning
alias[effect:set_timed_espionage_operation_flag] = {
    flag = value_set[espionage_operation_flag]
    enum[days_months_year] = int_value_field
}

### Joins the war on the specified side.
## scopes = { country }
alias[effect:join_war_on_side] = {
    war = scope[war]
    side = enum[war_side]
    side = scope_group[target_country]
}

### Remove a number of random building(s) matching/not matching a type from the starbase
## scopes = { starbase }
alias[effect:remove_random_starbase_building] = {
    ## cardinality = 0..1
    type = <starbase_building>
    ## cardinality = 0..1
    count = int #no variables here atm
}

### Remove a number of random module(s) matching/not matching a type from the starbase
## scopes = { starbase }
alias[effect:remove_random_starbase_module] = {
    ## cardinality = 0..1
    type = <starbase_module>
    ## cardinality = 0..1
    count = int #no variables here atm
}

### Destroys a espionage operation site in right hand site event target
## scopes = any
alias[effect:destroy_espionage_operation] = scope[espionage_operation]

### Adds information to the current stage of an espionage operation
## scopes = { espionage_operation }
alias[effect:add_espionage_information] = value_field

### Adds victory score to a country
## scopes = { country }
alias[effect:add_victory_score] = {
    source = localisation
    score = value_field
}

### Stores a copy of the specified data of the scoped country. The values default to 'no'.
## scopes = { country }
alias[effect:store_country_backup_data] = {
    ## cardinality = 0..1
    flag = bool
    ## cardinality = 0..1
    room = bool
    ## cardinality = 0..1
    name = bool
    ## cardinality = 0..1
    ethics = bool
    ## cardinality = 0..1
    government = bool
}

### Restores backed up data to the country
## scopes = { country }
alias[effect:restore_country_backup_data] = bool

### Activates crisis progression for the country
## scopes = { country }
alias[effect:activate_crisis_progression] = <crisis_path>

### Sets the room background of the empire. Provide an empty string to remove the override.
## scopes = { country }
alias[effect:room_name_override] = <asset_selector.room>  ###这一个写法存疑，疑似没有效果
### Sets the room background of the empire. Provide an empty string to remove the override.
## scopes = { country }
alias[effect:room_name_override] = ""
### Sets the room background of the empire. Provide an empty string to remove the override.
## scopes = { country }
alias[effect:room_name_override] = icon[gfx/portraits/city_sets] # 经过测试，这个可以进行

### Sets the AI personality of a country to a new one
## scopes = { country }
alias[effect:set_ai_personality] = <ai_personality>

### Sets whether or not the scoped country is the Galactic Custodian
## scopes = { country }
alias[effect:set_galactic_custodian] = bool

### Sets whether or not the scoped country is the Galactic Emperor
## scopes = { country }
alias[effect:set_galactic_emperor] = bool

### Sets whether the Galactic Defense force or Imperial Armada exists
## scopes = any
alias[effect:set_galactic_defense_force] = bool

### Add imperial_authority
## scopes = any
alias[effect:add_imperial_authority] = value_field

### Adds a specific modifier to the current espionage operation stage for a set duration or until stage is changed
## scopes = { espionage_operation astral_rift }
alias[effect:add_stage_modifier] = {
    modifier = <static_modifier>
    # severity = info
    ## cardinality = 0..1
    enum[days_months_year] = int
    ## cardinality = 0..1
    multiplier = float #no variables here atm
}

### Removes a specific modifier from the espionage operation current stage
## scopes = { espionage_operation astral_rift }
alias[effect:remove_stage_modifier] = <static_modifier>

### Moves all owned GDF fleets to the target.
## scopes = { country }
alias[effect:transfer_galactic_defense_force_fleets] = scope_group[target_country]

### Immediately cancels/removes the latest active/passed/proposed/voting for/failed resolution of this type
## scopes = { country }
alias[effect:cancel_resolution] = <resolution>

### Adds the intel level for the category selected. Default duration (0) is forever.
## scopes = { country }
alias[effect:add_intel_report] = {
    category = <intel_category>
    level = int
    ## cardinality = 0..1
    days = int
    who = scope_group[target_country]
}

### Removes all the intel reports related to the provided category.
## scopes = { country }
alias[effect:clear_intel_report] = {
    category = <intel_category>
    who = scope_group[target_country]
}

### Rounds a previously-set variable to the closest integer.
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:round_variable] = value[variable]

### Rounds a previously-set variable down to the previous integer.
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:floor_variable] = value[variable]

### Rounds a previously-set variable up to the next integer.
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:ceiling_variable] = value[variable]

### Exports the value of a trigger to a specified variable (so for num_pops, it'll export the number of pops).
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:export_trigger_value_to_variable] = {
    trigger = alias_keys_field[trigger]
    ## cardinality = 0..1
    ## cardinality = 0..1
    parameters = $any
    variable = value_set[variable]
    ### default: no
    ## cardinality = 0..1
    rounded = yes
}

### Exports the value of the current country's stockpile of the specified resource to a variable.
## scopes = { country }
alias[effect:export_resource_stockpile_to_variable] = {
    resource = <resource>
    variable = value_set[variable]
}

### Exports the value of the current country's monthly income of the specified resource to a variable.
## scopes = { country }
alias[effect:export_resource_income_to_variable] = {
    resource = <resource>
    variable = value_set[variable]
}

### Exports the value of the current country's maximum of the specified resource to a variable.
## scopes = { country }
alias[effect:export_resource_maximum_to_variable] = {
    resource = <resource>
    variable = value_set[variable]
}

### Exports the value of a specified modifier in the current scope to a specified variable.
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army species pop_faction }
alias[effect:export_modifier_to_variable] = {
    modifier = alias_keys_field[modifier]
    variable = value_set[variable]
}

### Sets the target country as hostile. This will work on countries you don't have comms with, unlike set_faction_hostility.
## scopes = { country }
alias[effect:set_hostile] = scope_group[target_country]

### Add specified country as an associate member
## scopes = { federation }
alias[effect:add_associate_member] = {
    who = scope_group[target_country]
    override_requirements = bool
}

### Removes a specific associate member from the federation
## scopes = { federation }
alias[effect:remove_associate_member] = {
    who = scope_group[target_country]
    override_requirements = bool
}

### Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type that has the specified target. Ignores whether the target is valid or not.
## scopes = { country }
alias[effect:pass_targeted_resolution] = {
    resolution = <resolution>
    target = scope_group[target_country]
}

### Increase the current Custodian term time
## scopes = any
alias[effect:add_custodian_term_days] = int_value_field

### Set the current Custodian term time. -1 will make the Custodianship permanent.
## scopes = any
alias[effect:set_custodian_term_days] = int_value_field

### The scoped country wins the game
## scopes = { country }
alias[effect:win] = yes

### Adds levels to the current Spy Network
## scopes = { spy_network }
alias[effect:add_spy_network_level] = int_value_field

### Dissolved the current federation
## scopes = { federation }
alias[effect:dissolve_federation] = yes

# 3.1

### Sets the country's male ruler title to a custom value
## scopes = { country }
alias[effect:set_male_ruler_title] = localisation
### Sets the country's female ruler title to a custom value
## scopes = { country }
alias[effect:set_female_ruler_title] = localisation
### Sets the country's male heir title to a custom value
## scopes = { country }
alias[effect:set_male_heir_title] = localisation
### Sets the country's female heir title to a custom value
## scopes = { country }
alias[effect:set_female_heir_title] = localisation
### Clears all custom ruler and heir titles from the country, resetting them to default values
## scopes = { country }
alias[effect:clear_custom_ruler_and_heir_titles] = yes

### Adds a blocker to a planet, with some control over what it is set to block (add_deposit will add a random planetary deposit to block)
## scopes = { planet }
alias[effect:add_blocker] = {
    type = <deposit.blocker>
    ## cardinality = 0..1
    ### none is default, if you specify a scope or random then it copies the type to the blocked deposit but any flags or variables are lost
    blocked_deposit = random
    ## cardinality = 0..1
    blocked_deposit = none
    ## cardinality = 0..1
    blocked_deposit = scope[deposit]
}

### Sets an arbitrarily-named date flag for the scoped object. Acts both as an <scope object>_flag and as a means for saving a date. The flag can then be referred to in localisations [This.<flag>] to produce the date.
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[effect:set_saved_date] = {
    ### Refer to this in locs; note: this is actually a <country/whatever>_flag
    key = value_set[variable] # TODO actually a flag of the current scope type, currently threat as a variable
    ## cardinality = 0..1
    ### Time until the date you wish to save. Default is present
    days_from_present = int_value_field
    ## cardinality = 0..1
    ### Time until the saved date is cleared, default is never
    expires = int_value_field
}

### Rerolls the random seed. Use if you want to have a second random_list return a different result. Do not use in tooltips that show random results, because the tooltip will be wrong!
## scopes = any
alias[effect:reroll_random] = yes

### Sets the target system as 'visited' (i.e. low system intel on the map)
## scopes = { country }
alias[effect:set_visited] = scope[system]

### Creates a new Nebula with a given radius centered around the current system.
## scopes = { galactic_object }
alias[effect:create_nebula] = {
    ## cardinality = 0..1
    ### (loc, optional - default is random)
    name = localisation
    ## required
    radius = int_value_field
    ## cardinality = 0..1
    ## push_scope = galactic_object
    ### effects on every system in the new nebula
    effect = single_alias_right[effect_clause]
}

# 3.3

### Begins a situation.
## scopes = { country }
alias[effect:start_situation] = {
    type = <situation_type>
    ## cardinality = 0..1
    target = scope[any]
    ## cardinality = 0..1
    ## push_scope = situation
    effect = single_alias_right[effect_clause]
}

### Destroys a situation in right hand side event target, use once situation is complete (on_fail/on_complete/on_abort is not called)
## scopes = any
alias[effect:destroy_situation] = scope[situation]
### Adds a sum of progress scoped situation
## scopes = { situation }
alias[effect:add_situation_progress] = value_field
### Sets the approach to the Situation. Respects allow and potential triggers.
## scopes = { situation }
alias[effect:set_situation_approach] = enum[situation_approach]
### Sets the planet's ascension tier to the specified value
## scopes = { planet }
alias[effect:set_planetary_ascension_tier] = int_value_field
### Disables a single instance of a specific building on the scoped planet
## scopes = { planet }
alias[effect:disable_building] = <building>
### Ruins a single instance of a specific building on the scoped planet
## scopes = { planet }
alias[effect:ruin_building] = <building>
### Ruins a single instance of a specific building on the scoped planet
## scopes = { planet }
alias[effect:ruin_building] = random_no_capital
### Locks the Situation so it will not progress until unlocked.
## scopes = { situation }
alias[effect:set_situation_locked] = bool
### Changes the agreement term for whether the Subject can be integrated
## scopes = { agreement }
alias[effect:set_rule_can_subject_be_integrated] = bool
### Changes the agreement term for whether the Subject can do diplomacy
## scopes = { agreement }
alias[effect:set_rule_can_subject_do_diplomacy] = bool
### Changes the agreement term for whether the Subject can expand
## scopes = { agreement }
alias[effect:set_rule_can_subject_expand] = enum[agreement_subject_expand]
### Changes the agreement term for whether the Subject can vote independently of its overlord in GalCom/federations
## scopes = { agreement }
alias[effect:set_rule_can_subject_vote] = bool
### Changes the agreement term for Subject to join Overlord wars
## scopes = { agreement }
alias[effect:set_rule_join_overlord_wars] = enum[agreement_war]
### Changes the agreement term for Overlord to wars of its Subject
## scopes = { agreement }
alias[effect:set_rule_join_subject_wars] = enum[agreement_war]
### Changes the agreement term for whether the Subject can access the overlord's territory (and territories the overlord has access to) despite closed borders
## scopes = { agreement }
alias[effect:set_rule_subject_has_access] = bool
### Changes the agreement term for whether the Subject gets sensors data from Overlord
## scopes = { agreement }
alias[effect:set_rule_subject_has_sensors] = bool
### Passes the scoped debris ownership to the specified country
## scopes = { debris }
alias[effect:pass_debris_ownership] = {
    owner = scope_group[target_country]
}

### Replace/removes all invalid (potential trigger not fulfilled) buildings and districts, then repairs all ruined buildings on the scoped planet
## scopes = { planet }
alias[effect:validate_and_repair_planet_buildings_and_districts] = yes

### Removes a specific holding from the scoped planet
## scopes = { planet }
alias[effect:remove_holding] = {
    holding = <building.corporate>
    holding = <building.holding>
    owner = scope_group[target_country]
}
### Begins construction of a specific holding on the scoped planet
## scopes = { planet }
alias[effect:add_holding] = {
    holding = <building.corporate>
    holding = <building.holding>
    owner = scope_group[target_country]
}
### Removes a secret fealty pact between the scoped subject country and the target empire
## scopes = { country }
alias[effect:remove_secret_fealty] = scope_group[target_country]

### Clears relations between scoped and target countries
## scopes = { country }
alias[effect:clear_relations] = {
    target = scope[country]
    relations = { enum[country_relation] }
}

### Sets agreement terms of the agreement. Can be used to set multiple terms at once, including resource subsidies.
## scopes = { agreement }
alias[effect:set_agreement_terms] = {
    ## cardinality = 0..inf
    <agreement_term.discrete> = <agreement_term_value.discrete>
    ## cardinality = 0..inf
    <agreement_term.discrete_number> = <agreement_term_value.discrete_number>
    ## cardinality = 0..inf
    <agreement_term.specialist_type> = <agreement_term_value.specialist_type>
    ## cardinality = 0..inf
    <agreement_term.resource> = value_field[-1.0..1.0]
}
### Sets the preset of an agreement and applies its terms on the agreement if 'apply_terms' is 'yes'.
## scopes = { agreement }
alias[effect:set_agreement_preset] = {
    preset = <agreement_preset>
    ## cardinality = 0..1
    ### Defaults to 'yes'
    apply_terms = bool
}
### Adds a ship component to a starbase, standalone from any module or building
## scopes = { starbase }
alias[effect:add_starbase_component] = {
    component = <component_template>
}
### Removes the specified ship component to a starbase. Only works for components that are standalone from any module or building.
## scopes = { starbase }
alias[effect:remove_starbase_component] = {
    component = <component_template>
}
### Add loyalty to subject of an agreement
## scopes = { agreement }
alias[effect:add_loyalty] = int_value_field
### Sets an arbitrarily-named flag on the scoped design
## scopes = { design }
## severity = warning
alias[effect:set_design_flag] = value_set[design_flag]
### Removes a flag from the scoped design
## scopes = { design }
## severity = warning
alias[effect:remove_design_flag] = value[design_flag]
### Destroys a situation in right hand side event target, firing on_abort (use to cancel and fire that effect)
## scopes = any
alias[effect:abort_situation] = scope[situation]
### Starts the process of converting the subject of the scoped agreement to the given specialist type.
### Can also be used to remove the specialization from a subject, by using 'none' as value
## scopes = { agreement }
alias[effect:convert_to_specialist] = <agreement_term_value.specialist_type>
### Starts the process of converting the subject of the scoped agreement to the given specialist type.
### Can also be used to remove the specialization from a subject, by using 'none' as value
## scopes = { agreement }
alias[effect:convert_to_specialist] = none
### Removes a specific ship design from the scoped country
## scopes = { country }
alias[effect:remove_ship_design] = <global_ship_design>
### Removes a specific ship design from the scoped country
## scopes = { country }
alias[effect:remove_ship_design] = scope[design]
### Removes a specific ship design from the scoped country
## scopes = { country }
alias[effect:remove_ship_design] = last_created_design
### Removes a specific global design from the game
## scopes = any
alias[effect:remove_global_ship_design] = <global_ship_design>
### Passes special trade offer data from the target enclave country to the scoped country.
### Only works inside certain parts of the script marked as ai_trade_facility.
## scopes = { country }
alias[effect:get_trade_data] = {
    target = scope_group[target_country]
}
### Makes special trade deal between the target enclave country and the scoped country.
### Only works inside certain parts of the script marked as ai_trade_facility.
## scopes = { country }
alias[effect:make_special_trade] = {
    target = scope_group[target_country]
}
### Leases fleet out to the new controller country for a numbed of days
## scopes = { fleet }
alias[effect:give_fleet] = {
    controller = scope_group[target_country]
    days = int_value_field
}

# 3.5

### Multiplies crisis strength by this factor.
## scopes = any
alias[effect:multiply_crisis_strength] = value_field

### Sets the scoped leader immortal. The 'no' case will not override immortality granted by species characteristics (but will disable immortality granted by this effect).
## scopes = { leader }
alias[effect:set_immortal] = bool

### Finish the current operation phase
### yes - trigger stage completed for each stage and current excavator.
### no - do not trigger any stage completed
## scopes = { espionage_operation }
alias[effect:finish_current_operation_stage] = bool

### Breaks fleet lease contract
## scopes = { fleet }
alias[effect:end_fleet_contract] = yes

### Breaks fleet lease contract
## scopes = { fleet }
alias[effect:end_fleet_contract] = {
    initiator = scope[country]
    reason = broken
    reason = cancelled
}

### Sets awareness for the scoped (pre-FTL) country
## scopes = { country }
alias[effect:set_awareness] = float[0.0..100.0]

### Sets awareness for the scoped (pre-FTL) country
## scopes = { country }
alias[effect:add_awareness] = float

# 3.8

### Changes the background ethic of a leader
## scopes = { leader }
alias[effect:change_background_ethic] = <ethic>

### Changes the background job of a leader
## scopes = any
alias[effect:change_background_job] = <job>

### Starts terraforming process of scoped planet
## scopes = { planet }
alias[effect:start_terraform_process] = <planet_class>
### Starts terraforming process of scoped planet
## scopes = { planet }
alias[effect:start_terraform_process] = <planet_class_random_list>
### Starts terraforming process of scoped planet
## scopes = { planet }
alias[effect:start_terraform_process] = {
    class = <planet_class>
    inherit_entity = bool
}
### Starts terraforming process of scoped planet
## scopes = { planet }
alias[effect:start_terraform_process] = {
    class = <planet_class_random_list>
    inherit_entity = bool
}

### Removes all negative traits from the scoped leader
## scopes = { leader }
alias[effect:remove_all_negative_traits] = bool

### Removes all non-negative traits from the scoped leader
## scopes = { leader }
alias[effect:remove_all_positive_traits] = bool

### Removes all traits from the scoped leader
## scopes = { leader }
alias[effect:remove_all_traits] = bool

### Resets the cooldown period of all policies for a country
## scopes = { country }
alias[effect:reset_policy_cooldowns] = bool

### Copies years served duration from the target
## scopes = { leader }
alias[effect:set_years_served] = scope[leader]

### Sets the gender of the scoped leader
## scopes = { leader }
alias[effect:set_gender] = enum[gender]

### Copies all script flags and variables from the specified scope to the current one.
## scopes = any
alias[effect:copy_flags_and_variables_from] = scope_field

### Changes the class of the leader in scope.
## scopes = { leader }
alias[effect:change_leader_class] = <leader_class>

### Sets the scoped leader immortal. The 'no' case will not override immortality granted by species characteristics (but will disable immortality granted by this effect).
### set_immortal = yes
## scopes = { leader }
alias[effect:set_immortal] = bool

### Adds random non-blocker resource deposit to the scoped planet of a certain category
## scopes = { planet }
alias[effect:add_deposit_category_effect] = <deposit_category>

### Stops terraforming process of scoped planet
## scopes = { planet }
alias[effect:stop_terraform_process] = scalar

### Resets n event chain counter for the scoped country
## scopes = { country }
alias[effect:reset_event_chain_counter] = {
    event_chain = <event_chain>
    counter = enum[event_chain_counter]
}

### Instantly adds council agenda progress
## scopes = { country }
alias[effect:add_council_agenda_progress] = int

### Unlocks council slots
## scopes = { country }
alias[effect:unlock_council_slots] = int

### Set the Country's council agenda
## scopes = { country }
alias[effect:set_council_agenda] = <agenda>

### Adds the age of the scoped leader
## scopes = { leader }
alias[effect:add_age] = value_field

### Adds to the scoped leader's skill level but does not select any traits
## scopes = { leader }
alias[effect:add_skill_without_trait_selection] = value_field

### Sets the scoped leader immortal. The 'no' case will not override immortality granted by species characteristics (but will disable immortality granted by this effect).
### set_immortal = yes
## scopes = { leader }
alias[effect:set_council_position] = <councilor>

### Prolongs fleet's lease contract for a numbed of days
## scopes = { fleet }
alias[effect:prolong_fleet_contract] = {
    days = int_value_field
}

### Unlocks council selection
## scopes = { country }
alias[effect:unlock_council_selection] = bool

# 3.9.1

### Changes which design a ship uses/all ships in a fleet use, to the target design
## scopes = { ship fleet }
alias[effect:set_ship_design] = {
    ## cardinality = 0..1
    design = <global_ship_design>
    ## cardinality = 0..1
    design = scope[design]
    ## cardinality = 0..1
    design = last_created_design
    ## cardinality = 0..1
    random_existing_design = <ship_size>
}

### Gives percentage progress (-1.0-1.0) in the current agenda to the scoped country
## scopes = { country }
alias[effect:add_council_agenda_progress_percent] = value_field

### Sets the scoped country's male ruler's title.
## scopes = { country }
alias[effect:set_ruler_title_male] = localisation

### Sets the scoped country's female ruler's title.
## scopes = { country }
alias[effect:set_ruler_title_female] = localisation

### Sets the scoped country's council position's male title.
## scopes = { country }
alias[effect:set_council_position_title_male] = {
    position_tag = localisation
    title = localisation
}

### Sets the scoped country's council position's female title.
## scopes = { country }
alias[effect:set_council_position_title_female] = {
    position_tag = localisation
    title = localisation
}

# 3.10.0

### Freezes the scoped leader's age. The 'no' case will disable the freeze granted by this effect.
## scopes = { leader }
alias[effect:freeze_leader_age] = bool

### Sets an arbitrarily-named flag on the scoped astral rift
## scopes = { astral_rift }
alias[effect:set_astral_rift_flag] = value_set[astral_rift_flag]

### Removes a flag from the scoped astral rift
## scopes = { astral_rift }
alias[effect:remove_astral_rift_flag] = value[astral_rift_flag]

### Exports the remaining duration of a specified modifier in the current scope to a specified variable.
## scopes = { planet country pop_group fleet }
alias[effect:export_modifier_duration_to_variable] = {
    modifier = <modifier>
    modifier = <static_modifier>
    variable = value[variable]
}

### Deletes the target dimensional fleet
## scopes = any
alias[effect:delete_dimensional_fleet] = scope_field

### Deletes the target dimensional fleet
## scopes = any
alias[effect:delete_dimensional_fleet] = {
    target = scope_field
}

### Spawns a new astral rift in the scoped system.
### If the id is not set or equal to none, spawns a random rift from the pool once exploration begins.
### Can be spawned relatively to an existing spatial object, tolerance is applied to the angle to avoid already existing planets.
## scopes = { galactic_object }
alias[effect:spawn_astral_rift] = {
    ## cardinality = 0..1
    in_place_of = scope[system]
    ### default = no, exclusive with relative_to and in_place_of
    ## cardinality = 0..1
    random_pos = bool
    ## cardinality = 0..1
    orbit_distance = float
    ## cardinality = 0..1
    orbit_distance = { min = float max = float }
    ## cardinality = 0..1
    orbit_angle = int
    ## cardinality = 0..1
    tolerance = int
    ## cardinality = 0..1
    id = <astral_rift>
    ## cardinality = 0..1
    id = none
    ## cardinality = 0..1
    relative_to = scope_field
    ## cardinality = 0..1
    in_place_of = scope_group[spatial_object]
    ## cardinality = 0..1
    graphics_entity_name = <model_entity>
    ### default = yes
    ## cardinality = 0..1
    spawn_sound = bool
    ## cardinality = 0..1
    ## push_scope = astral_rift
    init_effect = single_alias_right[effect_clause]
}

### Destroys target Astral Rift
## scopes = any
alias[effect:destroy_astral_rift] = scope[astral_rift]

### Changes the target of a Situation.
## scopes = { situation }
alias[effect:change_situation_target] = scope_field

### Changes the target of a Situation.
## scopes = { situation }
alias[effect:change_situation_target] = none

### Assigns a council position to the country's council, if possible.
## scopes = { country }
alias[effect:set_council_position_to_council] = <councilor>

### Renew a Bypass Lock's duration as if it was just built.
## scopes = { bypass }
alias[effect:renew_bypass_lock] = bool

### Lock a Bypass for exclusive access for a given country.
## scopes = { bypass }
alias[effect:lock_bypass] = {
    country = scope[country]
    duration = int_value_field
}

### Starts the cooldown of an astral action defined with uses_custom_cooldown = yes
### start_astral_action_cooldown=<key>
## scopes = { country }
alias[effect:start_astral_action_cooldown] = <astral_action.uses_custom_cooldown>

### Unlocks Astral Actions that have become unlockable since the last time this effect was called.
## scopes = { country }
alias[effect:perform_astral_action_unlock_check] = bool

### Fires an astral rift event with optional DAYS and RANDOM
### delay
## scopes = { astral_rift }
alias[effect:astral_rift_event] = {
    id = <event.scopeless>
    id = <event.astral_rift>
    ### optional: specify delay
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ### optional: specify random delay from 0 to value, which is added on to the 'days' delay
    ## cardinality = 0..1
    random = int_value_field
    ### optional: specify scope overrides
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Fills the astral rift event pool for every playable country.
## scopes = { country }
alias[effect:fill_astral_rift_event_pool] = bool

### Fires a bypass event for the scoped bypass, with optional DAYS and RANDOM delay
## scopes = { bypass }
alias[effect:bypass_event] = {
    id = <event.scopeless>
    id = <event.situation>
    ## cardinality = 0..1
    days = int_value_field
    ## cardinality = 0..1
    months = int_value_field
    ## cardinality = 0..1
    years = int_value_field
    ## cardinality = 0..1
    random = int_value_field
    ## cardinality = 0..1
    scopes = {
        ## cardinality = 0..1
        from = scope[any]
        ## cardinality = 0..1
        fromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfrom = scope[any]
        ## cardinality = 0..1
        fromfromfromfrom = scope[any]
    }
}

### Ends the Astral Rift exploration
## scopes = { astral_rift }
alias[effect:finish_astral_rift] = bool

### Sets next Astral Rift event through an astral rift event ID, and another astral rift event ID to be called in case of a roll failed, alongside a trigger probability.	To fire an Astral Rift event immediately, use astral_rift_event instead.
## scopes = { astral_rift }
alias[effect:set_next_astral_rift_event] = {
    id = <event>
    ### optional: specify astral rift event set when a roll fails
    ## cardinality = 0..1
    ### optional: specify astral rift event probability to trigger on a failed roll
    on_roll_failed = <event>
    ## cardinality = 0..1
    fail_probability = float
}

### Unlocks an exhibit for given category from the target country.
## scopes = { country }
alias[effect:unlock_exhibit] = <specimen_types>

# missing effects in effects.log

## scopes = { country }
alias[effect:ai_trade_facility] = {
    ### default: no
    ## cardinality = 0..1
    offer_hire_mercenary_fleet = bool
    ### default: no
    ## cardinality = 0..1
    offer_prolong_fleet_contract = bool
    ## cardinality = 0..1
    info_gathering = {
        alias_name[effect] = alias_match_left[effect]
    }
    ## cardinality = 0..1
    option_selection = {
        alias_name[effect] = alias_match_left[effect]
    }
    ## cardinality = 0..1
    allow = {
        alias_name[trigger] = alias_match_left[trigger]
    }
    alias_name[effect] = alias_match_left[effect]
}

### without this immediate is not invoked when event runs in a special mode that allows AI to collect trade data
## scopes = { country }
alias[effect:run_in_ai_mode] = bool

# fleet actions

### Adds actions to the scoped fleet's action queue
## scopes = { fleet }
alias[effect:queue_actions] = {
    alias_name[fleet_action] = alias_match_left[fleet_action]
}

### Sets current fleet's cloaking status
## scopes = { fleet }
alias[effect:set_cloaking_active] = bool

### Advances country to next pre-FTL technology level if possible. Does nothing if has_next_pre_ftl_age would be false, or if argument is 'no'.
## scopes = { country }
alias[effect:go_to_next_pre_ftl_age] = bool

### Set pre-FTL technology level. Does nothing if the country is not pre-FTL.
## scopes = { country }
alias[effect:set_pre_ftl_age] = <pre_ftl_age>

### Remove communications between scoped country and target country
## scopes = { country }
alias[effect:remove_communications] = scope[country]

### Removes any envoys from scoped country assigned to target country
## scopes = { country }
alias[effect:remove_envoys_to] = scope[country]

### The scoped country is removed from any federation its in
## scopes = { country }
alias[effect:remove_from_federation] = yes

### Repairs a single instance of a specific building on the scoped planet
## scopes = { planet }
alias[effect:repair_building] = <building>

# scope links

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country fleet }
## push_scope = ship
alias[effect:every_owned_ship] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country fleet }
## push_scope = ship
alias[effect:random_owned_ship] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = country
alias[effect:random_country] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Executes enclosed effects on a random pop_group that meets the limit criteria. Warning: deprecated, use random_owned_pop
## scopes = { planet }
## push_scope = pop_group
alias[effect:random_pop] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all owned pops - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet country pop_faction sector }
## push_scope = pop_group
alias[effect:every_owned_pop_group] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}


### Iterate through all countries - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = country
alias[effect:every_country] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all playable countries - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = country
alias[effect:every_playable_country] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = country
alias[effect:random_playable_country] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each planet (colony or not) in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = planet
alias[effect:random_system_planet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each deposit on the planet - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = deposit
alias[effect:every_deposit] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = deposit
alias[effect:random_deposit] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = planet
alias[effect:random_moon] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each moon of the planet - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = planet
alias[effect:every_moon] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet within the current empire's borders - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = planet
alias[effect:every_planet_within_border] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all rim systems - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = system
alias[effect:every_rim_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = system
alias[effect:random_rim_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each leader that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = leader
alias[effect:every_owned_leader] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = leader
alias[effect:random_owned_leader] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet country pop_faction sector }
## push_scope = pop_group
alias[effect:random_owned_pop_group] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Executes enclosed effects on a system -within a specific number of jumps span- that meets the limit criteria. This completely ignores bypasses (wormholes and gateways)
## scopes = any
## push_scope = system
alias[effect:closest_system] = {
    ## cardinality = 0..1
    min_steps = int
    ## cardinality = 0..1
    max_steps = int
    ## cardinality = 0..1
    use_bypasses = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = fleet
alias[effect:random_owned_fleet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = ambient_object
alias[effect:random_ambient_object] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = ambient_object
alias[effect:random_system_ambient_object] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every ambient object in the game - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = ambient_object
alias[effect:every_ambient_object] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every ambient object in the solar system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = ambient_object
alias[effect:every_system_ambient_object] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = fleet
alias[effect:every_fleet_in_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = fleet
alias[effect:random_fleet_in_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = system
alias[effect:every_neighbor_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = system
alias[effect:random_neighbor_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all war participants - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { war }
## push_scope = country
alias[effect:every_war_participant] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = fleet
alias[effect:every_owned_fleet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all subjects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_subject] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_subject] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = planet
alias[effect:random_planet_within_border] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Executes enclosed effects on every system in the cluster that meet the limit criteria
## scopes = any
## push_scope = system
alias[effect:every_system_in_cluster] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all the country's pop_group factions - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = pop_faction
alias[effect:every_pop_faction] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all the country's pop_group factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = pop_faction
alias[effect:random_pop_faction] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each planet (colony or not) in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = planet
alias[effect:every_system_planet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each agreement - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country no_scope }
## push_scope = agreement
alias[effect:random_agreement] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each agreement - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country no_scope }
## push_scope = agreement
alias[effect:ordered_agreement] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each agreement - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country no_scope }
## push_scope = agreement
alias[effect:every_agreement] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = ambient_object
alias[effect:ordered_ambient_object] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = ambient_object
alias[effect:ordered_system_ambient_object] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every archaeological sites - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = archaeological_site
alias[effect:random_archaeological_site] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every archaeological sites - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = archaeological_site
alias[effect:ordered_archaeological_site] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every archaeological sites - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = archaeological_site
alias[effect:every_archaeological_site] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = army
alias[effect:random_owned_army] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = army
alias[effect:ordered_owned_army] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = army
alias[effect:every_owned_army] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = army
alias[effect:random_planet_army] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = army
alias[effect:ordered_planet_army] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = army
alias[effect:every_planet_army] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = army
alias[effect:random_ground_combat_defender] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = army
alias[effect:ordered_ground_combat_defender] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = army
alias[effect:every_ground_combat_defender] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = army
alias[effect:random_ground_combat_attacker] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = army
alias[effect:ordered_ground_combat_attacker] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = army
alias[effect:every_ground_combat_attacker] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = country
alias[effect:ordered_country] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_relation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_relation] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all relations - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_relation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_neighbor_country] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_neighbor_country] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all neighbor countries - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_neighbor_country] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = country
alias[effect:random_country_neighbor_to_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = country
alias[effect:ordered_country_neighbor_to_system] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = country
alias[effect:every_country_neighbor_to_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_rival_country] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_rival_country] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries rivalled by the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_rival_country] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = country
alias[effect:random_federation_ally] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_federation_ally] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all countries in a federation with the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = country
alias[effect:every_federation_ally] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = country
alias[effect:ordered_playable_country] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = country
alias[effect:ordered_subject] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = debris
alias[effect:random_available_debris] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = debris
alias[effect:ordered_available_debris] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = debris
alias[effect:every_available_debris] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}


### Iterate through all designs owned by the current country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = design
alias[effect:random_owned_design] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all designs owned by the current country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = design
alias[effect:ordered_owned_design] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all designs owned by the current country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = design
alias[effect:every_owned_design] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country no_scope }
## push_scope = spy_network
alias[effect:random_spynetwork] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country no_scope }
## push_scope = spy_network
alias[effect:ordered_spynetwork] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each spynetwork - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country no_scope }
## push_scope = spy_network
alias[effect:every_spynetwork] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country no_scope spy_network }
## push_scope = espionage_operation
alias[effect:random_espionage_operation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country no_scope spy_network }
## push_scope = espionage_operation
alias[effect:ordered_espionage_operation] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each espionage operation - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country no_scope spy_network }
## push_scope = espionage_operation
alias[effect:every_espionage_operation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { no_scope spy_network espionage_operation }
## push_scope = espionage_asset
alias[effect:random_espionage_asset] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { no_scope spy_network espionage_operation }
## push_scope = espionage_asset
alias[effect:ordered_espionage_asset] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each espionage asset - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { no_scope spy_network espionage_operation }
## push_scope = espionage_asset
alias[effect:every_espionage_asset] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every exhibit - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## copes = { country }
alias[effect:random_exhibit] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every exhibit - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## copes = { country }
alias[effect:ordered_exhibit] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    ### (default: no - if yes, then 0 is lowest rather than highest)
    ## cardinality = 0..1
    inverse = bool
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every exhibit - executes the enclosed effects on all of them for which the limit triggers return true
## copes = { country }
alias[effect:every_exhibit] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = federation
alias[effect:random_federation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}


### Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = federation
alias[effect:ordered_federation] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each federation - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = federation
alias[effect:every_federation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = first_contact
alias[effect:random_first_contact] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = first_contact
alias[effect:ordered_first_contact] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = first_contact
alias[effect:every_first_contact] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = first_contact
alias[effect:random_active_first_contact] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = first_contact
alias[effect:ordered_active_first_contact] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = first_contact
alias[effect:every_active_first_contact] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = fleet
alias[effect:random_galaxy_fleet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = fleet
alias[effect:ordered_galaxy_fleet] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the entire game - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = fleet
alias[effect:every_galaxy_fleet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { fleet }
## push_scope = fleet
alias[effect:random_combatant_fleet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { fleet }
## push_scope = fleet
alias[effect:ordered_combatant_fleet] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet this fleet is in combat with - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { fleet }
## push_scope = fleet
alias[effect:every_combatant_fleet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = fleet
alias[effect:ordered_fleet_in_system] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = fleet
alias[effect:ordered_owned_fleet] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = fleet
alias[effect:random_controlled_fleet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each fleet controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = fleet
alias[effect:ordered_controlled_fleet] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = fleet
alias[effect:every_controlled_fleet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { megastructure planet starbase }
## push_scope = fleet
alias[effect:random_fleet_in_orbit] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { megastructure planet starbase }
## push_scope = fleet
alias[effect:ordered_fleet_in_orbit] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { megastructure planet starbase }
## push_scope = fleet
alias[effect:every_fleet_in_orbit] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country galactic_object }
## push_scope = fleet
alias[effect:random_orbital_station] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country galactic_object }
## push_scope = fleet
alias[effect:ordered_orbital_station] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country galactic_object }
## push_scope = fleet
alias[effect:every_orbital_station] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = country
alias[effect:random_galcom_member] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = country
alias[effect:ordered_galcom_member] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the galactic community - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = country
alias[effect:every_galcom_member] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}


### Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = country
alias[effect:random_council_member] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = country
alias[effect:ordered_council_member] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the galactic council - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = country
alias[effect:every_council_member] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = leader
alias[effect:ordered_owned_leader] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = leader
alias[effect:random_pool_leader] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = leader
alias[effect:ordered_pool_leader] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each leader that is recruitable for the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = leader
alias[effect:every_pool_leader] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = leader
alias[effect:random_envoy] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = leader
alias[effect:ordered_envoy] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each envoy available to the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = leader
alias[effect:every_envoy] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = megastructure
alias[effect:random_megastructure] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = megastructure
alias[effect:ordered_megastructure] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each megastructure - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = megastructure
alias[effect:every_megastructure] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = megastructure
alias[effect:random_owned_megastructure] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = megastructure
alias[effect:ordered_owned_megastructure] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each owned megastructure - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = megastructure
alias[effect:every_owned_megastructure] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = megastructure
alias[effect:random_system_megastructure] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = megastructure
alias[effect:ordered_system_megastructure] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each megastructure in system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = megastructure
alias[effect:every_system_megastructure] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { federation }
## push_scope = country
alias[effect:random_member] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { federation }
## push_scope = country
alias[effect:ordered_member] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each member of the federation - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { federation }
## push_scope = country
alias[effect:every_member] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { federation }
## push_scope = country
alias[effect:random_associate] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { federation }
## push_scope = country
alias[effect:ordered_associate] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each associate member of the federation - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { federation }
## push_scope = country
alias[effect:every_associate] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet (colony or not) in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = planet
alias[effect:ordered_system_planet] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each colony in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = planet
alias[effect:random_system_colony] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each colony in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = planet
alias[effect:ordered_system_colony] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each colony in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = planet
alias[effect:every_system_colony] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = planet
alias[effect:ordered_planet_within_border] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country sector }
## push_scope = planet
alias[effect:random_owned_planet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country sector }
## push_scope = planet
alias[effect:ordered_owned_planet] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}


### Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country sector }
## push_scope = planet
alias[effect:every_owned_planet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = planet
alias[effect:random_controlled_planet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}


### Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = planet
alias[effect:ordered_controlled_planet] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = planet
alias[effect:every_controlled_planet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = planet
alias[effect:random_galaxy_planet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = planet
alias[effect:ordered_galaxy_planet] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = planet
alias[effect:every_galaxy_planet] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = deposit
alias[effect:ordered_deposit] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = planet
alias[effect:ordered_moon] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet country pop_faction sector }
## push_scope = pop_group
alias[effect:ordered_owned_pop_group] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each pop_group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { species }
## push_scope = pop_group
alias[effect:random_species_pop_group] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each pop_group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { species }
## push_scope = pop_group
alias[effect:ordered_species_pop_group] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each pop_group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { species }
## push_scope = pop_group
alias[effect:every_species_pop_group] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all owned pop jobs - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet country sector }
## push_scope = pop_job
alias[effect:random_owned_pop_job] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all owned pop jobs - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet country sector }
## push_scope = pop_job
alias[effect:ordered_owned_pop_job] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all owned pop jobs - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet country sector }
## push_scope = pop_job
alias[effect:every_owned_pop_job] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all the country's pop_group factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = pop_faction
alias[effect:ordered_pop_faction] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = sector
alias[effect:random_galaxy_sector] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = sector
alias[effect:ordered_galaxy_sector] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all sectors in the game - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = sector
alias[effect:every_galaxy_sector] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = sector
alias[effect:random_owned_sector] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = sector
alias[effect:ordered_owned_sector] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned sector - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = sector
alias[effect:every_owned_sector] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country fleet }
## push_scope = ship
alias[effect:ordered_owned_ship] = {
    ## cardinality = 0..1
    position = int
    ## cardinality = 0..1
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}


### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country fleet }
## push_scope = ship
alias[effect:random_controlled_ship] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country fleet }
## push_scope = ship
alias[effect:ordered_controlled_ship] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country fleet }
## push_scope = ship
alias[effect:every_controlled_ship] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = ship
alias[effect:random_ship_in_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = ship
alias[effect:ordered_ship_in_system] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each ship in the current system - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = ship
alias[effect:every_ship_in_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = situation
alias[effect:random_situation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = situation
alias[effect:ordered_situation] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each situation a country is experiencing - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = situation
alias[effect:every_situation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each situation that is targeting the current planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet }
## push_scope = situation
alias[effect:random_targeting_situation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each situation that is targeting the current planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet }
## push_scope = situation
alias[effect:ordered_targeting_situation] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each situation that is targeting the current planet - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet }
## push_scope = situation
alias[effect:every_targeting_situation] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = species
alias[effect:random_owned_pop_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = species
alias[effect:ordered_owned_pop_species] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each species of a country's owned pops - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = species
alias[effect:every_owned_pop_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = species
alias[effect:random_galaxy_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = species
alias[effect:ordered_galaxy_species] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = species
alias[effect:every_galaxy_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet country }
## push_scope = species
alias[effect:random_owned_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet country }
## push_scope = species
alias[effect:ordered_owned_species] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet country }
## push_scope = species
alias[effect:every_owned_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { planet country }
## push_scope = species
alias[effect:random_enslaved_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { planet country }
## push_scope = species
alias[effect:ordered_enslaved_species] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { planet country }
## push_scope = species
alias[effect:every_enslaved_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all existing species traits in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = trait
alias[effect:random_existing_species_traits] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all existing species traits in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = trait
alias[effect:ordered_existing_species_traits] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all existing species traits in the game - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = trait
alias[effect:every_existing_species_traits] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each trait that the scoped species has
## scopes = { pop_group leader species }
## push_scope = trait
alias[effect:random_trait_of_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each trait that the scoped species has
## scopes = { pop_group leader species }
## push_scope = trait
alias[effect:ordered_trait_of_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through each trait that the scoped species has
## scopes = { pop_group leader species }
## push_scope = trait
alias[effect:every_trait_of_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all species traits and check if scope species doesn't have this trait
## scopes = { pop_group leader species }
## push_scope = trait
alias[effect:random_trait_available_for_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all species traits and check if scope species doesn't have this trait
## scopes = { pop_group leader species }
## push_scope = trait
alias[effect:ordered_trait_available_for_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all species traits and check if scope species doesn't have this trait
## scopes = { pop_group leader species }
## push_scope = trait
alias[effect:every_trait_available_for_species] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned primary starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = starbase
alias[effect:random_owned_starbase] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every owned primary starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = starbase
alias[effect:ordered_owned_starbase] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned primary starbase - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = starbase
alias[effect:every_owned_starbase] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = starbase
alias[effect:random_owned_nonprimary_starbase] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = starbase
alias[effect:ordered_owned_nonprimary_starbase] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = starbase
alias[effect:every_owned_nonprimary_starbase] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every starbase in the scoped galactic object. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = starbase
alias[effect:random_starbase_in_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every starbase in the scoped galactic object. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = starbase
alias[effect:ordered_starbase_in_system] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every starbase in the scoped galactic object. - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = starbase
alias[effect:every_starbase_in_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = system
alias[effect:random_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = system
alias[effect:ordered_system] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = system
alias[effect:every_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = system
alias[effect:ordered_rim_system] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}


### Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country sector }
## push_scope = system
alias[effect:random_system_within_border] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country sector }
## push_scope = system
alias[effect:ordered_system_within_border] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country sector }
## push_scope = system
alias[effect:every_system_within_border] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = system
alias[effect:ordered_neighbor_system] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all a system's neigboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = system
alias[effect:random_neighbor_system_euclidean] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = system
alias[effect:ordered_neighbor_system_euclidean] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = system
alias[effect:every_neighbor_system_euclidean] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { war }
## push_scope = country
alias[effect:random_war_participant] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { war }
## push_scope = country
alias[effect:ordered_war_participant] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { war }
## push_scope = country
alias[effect:random_attacker] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { war }
## push_scope = country
alias[effect:ordered_attacker] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all attackers in the current war - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { war }
## push_scope = country
alias[effect:every_attacker] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { war }
## push_scope = country
alias[effect:random_defender] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { war }
## push_scope = country
alias[effect:ordered_defender] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all defenders in the current war - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { war }
## push_scope = country
alias[effect:every_defender] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = war
alias[effect:random_war] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = war
alias[effect:ordered_war] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all wars the country is engaged in - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = war
alias[effect:every_war] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country sector }
## push_scope = country
alias[effect:random_pre_ftl_within_border] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country sector }
## push_scope = country
alias[effect:ordered_pre_ftl_within_border] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country sector }
## push_scope = country
alias[effect:every_pre_ftl_within_border] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country sector }
## push_scope = country
alias[effect:random_observed_pre_ftl_within_border] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country sector }
## push_scope = country
alias[effect:ordered_observed_pre_ftl_within_border] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country sector }
## push_scope = country
alias[effect:every_observed_pre_ftl_within_border] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every astral rift - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = astral_rift
alias[effect:random_astral_rift] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every astral rift - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = astral_rift
alias[effect:ordered_astral_rift] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every astral rift - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = astral_rift
alias[effect:every_astral_rift] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every bypass - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = bypass
alias[effect:random_bypass] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
    ### adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
}

### Iterate through every bypass - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = bypass
alias[effect:ordered_bypass] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every bypass - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = bypass
alias[effect:every_bypass] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every bypass in the scoped galactic object. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { galactic_object }
## push_scope = bypass
alias[effect:random_bypass_in_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    weights = { alias_name[modifier_rule] = alias_match_left[modifier_rule] }
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every bypass in the scoped galactic object. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { galactic_object }
## push_scope = bypass
alias[effect:ordered_bypass_in_system] = {
    position = int
    order_by = value_field
    ## cardinality = 0..1
    inverse = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through every bypass in the scoped galactic object. - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { galactic_object }
## push_scope = bypass
alias[effect:every_bypass_in_system] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Signals to portrait objects that they need to refresh some of their properties
## scopes = { country }
alias[effect:refresh_portraits] = enum[refresh_portraits]

### Used after an advanced authority swap to make sure things are changed properly
## scopes = { country }
alias[effect:advanced_authority_refresh] = bool

### Enables or disables the date distortion effect
## scopes = any
alias[effect:date_distortion] = bool

### Creates cloud effect at every star system controlled by the country
## scopes = country
alias[effect:activate_fog_machine] = <dust_clouds>

### Deactivates country fog machine
## scopes = country
alias[effect:deactivate_fog_machine] = yes

### Switches on/off galactic object ownership auto tracking for country fog machine
## scopes = country
alias[effect:fog_machine_auto_tracking] = bool

### Sets the scope faction as extorted and removes extortion from any other ones
## scopes = pop_faction
alias[effect:set_faction_extorted] = bool

### Creates a cosmic storm
## scopes = any
alias[effect:create_cosmic_storm] = {
    ## cardinality = 0..1
    storm_start_position = scope[galactic_object]
    ## cardinality = 0..1
    storm_end_position = scope[galactic_object]
    ## cardinality = 0..1
    storm_min_radius = value_field
    ## cardinality = 0..1
    storm_max_radius = value_field
    ## cardinality = 0..1
    storm_max_range = value_field
    ## cardinality = 0..1
    type = <storm_types>
    ## cardinality = 0..1
    immediate = bool
    ## cardinality = 0..1
    cosmic_storm_start_position = scope[system]
    ## cardinality = 0..1
    cosmic_storm_start_position = random
}

### Destroy the scoped storm.
## scopes = { cosmic_storm }
alias[effect:destroy_cosmic_storm] = yes

### Iterate through all cosmic storms in the galaxy - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = cosmic_storm
alias[effect:every_cosmic_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Sets wether or not the design automatically upgrades its components.
## scopes = { design }
alias[effect:set_auto_upgrade_components] = bool

### Spawn a random storm type with a random start and end position
## scopes = any
alias[effect:spawn_random_storm] = {
    ## cardinality = 0..1
    type = <storm_types>
    ## cardinality = 0..1
    cosmic_storm_start_position = scope[system]
    ## cardinality = 0..1
    cosmic_storm_start_position = random
    ## cardinality = 0..1
    immediate = yes
}

### Creates a storm influence field in a certain radius
## scopes = { planet starbase }
alias[effect:create_cosmic_storm_influence_field] = {
    ## cardinality = 1..1
    center = scope[system]
    ## cardinality = 1..1
    radius = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }
    ## cardinality = 0..1
    is_timed_influence_field = yes
}

### Destroys a storm influence field with center
## scopes = { planet starbase }
alias[effect:destroy_cosmic_storm_influence_field] = {
    ## cardinality = 1..1
    center = scope[system]
}

### Recalculates the influence for each system in an influence field
## scopes = { cosmic_storm_influence_field }
alias[effect:recalculate_storm_influence_field] = yes

### Sets Space Fauna growth stance. Setting to 'none' resets stance to use default country policy. (controlled/excessive/none)
## scopes = { country fleet }
alias[effect:set_fauna_fleet_growth_stance] = enum[growth_stance]

### Starts the storm placing mode with radius
## scopes = any
alias[effect:start_storm_area_placing] = {
    ## cardinality = 0..1
    sacrifice_leader_with_ui = yes
    ## cardinality = 1..1
    cosmic_storm = <storm_types>
    ## cardinality = 0..1
    immediate = yes

    ## cardinality = 1..1
    reticle_radius = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    ## cardinality = 1..1
    max_range = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    ## cardinality = 0..1
    on_confirm = {
        single_alias_right[effect_clause]
    }

    ## cardinality = 0..1
    on_cancel = {
        single_alias_right[effect_clause]
    }
}

### Gives a given specimen to the target country.
## scopes = { country }
alias[effect:give_specimen] = {
    key = <specimen>
    ## cardinality = 0..1
    origin = localisation
}

### Removes specified specimen from the target country.
## scopes = { country }
alias[effect:remove_specimen] = <specimen>

### Sets whether the emergency fund should be active or not.
## scopes = any
alias[effect:set_emergency_fund_active] = bool

### Applies Cosmic Storm Aftermath Modifiers. You can specify up to a max of 10 Severities and each one will be chosen based on it's chance.
## scopes = any
alias[effect:storm_apply_aftermath_modifier] = {
    severity = {
        ## cardinality = 1..1
        modifier = <static_modifier>
        ## cardinality = 1..1
        days = int

        ## cardinality = 0..1
        chance = {
            alias_name[modifier_rule] = alias_match_left[modifier_rule]
        }

        ## cardinality = 0..1
        effect  = {
            single_alias_right[effect_clause]
        }

    }
}


### Sets a storm on a system
## scopes = { galactic_object }
alias[effect:set_cosmic_storm] = {
    cosmic_storm = scope[cosmic_storm]
}

### Unsets a storm on a system
## scopes = { galactic_object }
alias[effect:unset_cosmic_storm] = bool

### Sets rate for contributions to the emergency fund.
## scopes = any
alias[effect:set_emergency_fund_contribution_rate] = value_field

### Tries to finish the current council agenda for the scoped country
## scopes = { country }
alias[effect:finish_council_agenda] = bool

### Increments (or decrements with negative values) a mission counter for the scoped country by a specific amount
## scopes = { country }
alias[effect:add_mission_counter] = {
    mission = <missions>
    counter = enum[mission_counter]
    amount = int_value_field
}

### Sets an arbitrarily-named flag on the scoped cosmic storm.(note: one can use e.g. my_flag@from to track relationships between objects)
## scopes = { cosmic_storm }
alias[effect:set_storm_flag] = value_set[storm_flag]

### Sets a mission counter for the scoped country to a specific amount
## scopes = { country }
alias[effect:set_mission_counter] = {
    mission = <missions>
    counter = enum[mission_counter]
    amount = int_value_field
}

### Stops the mission with the given status, triggering the relevant effects.
## scopes = { planet country ship pop_group }
alias[effect:stop_mission] = {
    mission = <missions>
    status = enum[mission_status]
}

### Gives associated culling rewards from a space fauna design to the target country.
## scopes = { country }
alias[effect:give_culling_rewards] = {
    ## cardinality = 0..1
    design = <global_ship_design>
    ## cardinality = 0..1
    design = scope[design]
    ## cardinality = 0..1
    design = last_created_design
}

### Gives given space fauna DNA with given rarity to the target country.
## scopes = { country }
alias[effect:give_dna] = {
    ## cardinality = 1..1
    ship_category = <ship_categories>
    ### (optional)
    ## cardinality = 0..1
    rarity = enum[specimens_rarity]
}

### Gives Space Fauna in the Vivarium using given ship design with given rarity to the target country.
## scopes = { country }
alias[effect:add_to_vivarium] = {
    ## cardinality = 0..1
    design = <global_ship_design>
    ## cardinality = 0..1
    design = scope[design]
    ## cardinality = 0..1
    design = last_created_design
    ## cardinality = 0..1
    rarity = enum[ship_rarity]
    ## cardinality = 0..1
    amount = int_value_field
}

### Reanimates Space Fauna ship(s) back to life in zombie form.
## scopes = { ship debris }
alias[effect:reanimate_space_fauna] = {
    ## cardinality = 1..1
    fleet = <fleet>
}

### Spawns a custom debris project with the current fleet.
## scopes = { fleet }
alias[effect:spawn_custom_debris] = {
    ## cardinality = 1..1
    for = scope_group[target_country]
    ### (optional) used to check if the ship must be added to the debris.
    ## cardinality = 0..1
    should_add_ship_to_debris = single_alias_right[trigger_clause]
    ### (default no) used to specify and override country behaviour towards this debris.
    ## cardinality = 0..1
    must_scavenge= bool
    ### (default no) used to specify and override country behaviour towards this debris.
    ## cardinality = 0..1
    must_research = bool
    ### (default no) used to force the fleet to reset its killed ships designs.
    ## cardinality = 0..1
    reset_killed_ship_designs = bool
}

### Selects a decision on a planet
## scopes = { planet }
alias[effect:select_decision] = {
    name = <decision>
}

### Returns the leader from a custom name
## scopes = { country }
alias[effect:return_leader_from_exile] = value[exiled_leader]

### Kills the scoped leader saved with a custom name
## scopes = { country }
alias[effect:kill_exiled_leader] = value[exiled_leader]

### If yes, locks a Cosmic Storm in place. If no, it advances again at its normal speed.
## scopes = { cosmic_storm }
alias[effect:lock_storm_in_place] = bool

### Set scoped starbase's current construction type
## scopes = { starbase }
alias[effect:set_ship_construction_type] = none

### Set scoped starbase's current construction type
## scopes = { starbase }
alias[effect:set_ship_construction_type] = value[construction_type]

### Link the scoped megastructure bypass to the given target megastructure bypass.
## scopes = { megastructure }
alias[effect:link_to] = from

### Steals random specimens from given country.
## scopes = { country }
alias[effect:steal_specimens] = {
    who = <country>
    category = <category_key>/all/any
    count = int_value_field
    ## cardinality = 0..1
    show_nofication = bool
}


### Releases into the wild space fauna contained in the scoped country's Vivarium, from all or given ship category.	Resulting fleet owner can be specified.	Space Fauna can be culled for resources instead by specifying 'cull_vivarium_critter = yes'.
## scopes = { country }
alias[effect:release_vivarium_fauna] = {
    ## cardinality = 1..1
    category = <ship_category>
    ## cardinality = 1..1
    category = all
    ## cardinality = 0..1
    location = scope_field
    ## cardinality = 0..1
    owner = scope[country]
    ## cardinality = 0..1
    cull_vivarium_critter = bool
}

### Releases into the wild a specific amount of space fauna contained in the scoped country's Vivarium.Rarest fauna is released in priority.	Resulting fleet owners can be specified.
## scopes = { country }
alias[effect:release_vivarium_fauna_count] = {
    ## cardinality = 0..1
    count = int_value_field
    ## cardinality = ~1..1
    location = scope_field
    ## cardinality = ~1..1
    owners = {
        ## cardinality = 0..inf
        <ship_categories> = scope[country]
    }
}

### Creates new creatures of the smaller ship size in the same fleet
## scopes = { ship }
alias[effect:create_smaller_size_creature_in_fleet] = {
    count = int_value_field
    ## cardinality = 0..1
    effect = single_alias_right[effect_clause]
}

### Triggers the sub-species integration step for a country.
## scopes = { country }
alias[effect:integrate_species] = bool

### Restores a certain percentage of shield points to the scoped ship or fleet
## scopes = { ship fleet }
alias[effect:repair_shield_percentage] = value_field[0.0..1.0]

### Restores a certain amount of hull points to the scoped ship or fleet
## scopes = { ship fleet }
alias[effect:repair_amount] = value_field[0.0..1.0]

### Restores a certain amount of armor points to the scoped ship or fleet
## scopes = { ship fleet }
alias[effect:repair_armor_amount] = int_value_field

### Restores a certain amount of shield points to the scoped ship or fleet
## scopes = { ship fleet }
alias[effect:repair_shield_amount] = int_value_field

### Sets if a country needs a colony (or a colony ship) to be considered alive
## scopes = { country }
alias[effect:set_faction_needs_colony] = bool

### Sets if country will be automatically deleted when considered dead
## scopes = { country }
alias[effect:set_faction_auto_delete] = bool

### Copies the traditions of the target country into the scoped country. Traditions are added to the existing traditions, and the potential/possible triggers are respected.the traditions listed in the exceptions list are not copied.
## scopes = { country }
alias[effect:copy_traditions_from] = {
    target = scope[country]
    exceptions = {
        <tradition>
    }
}

### Copies the Ascension Perks of the target country into the scoped country. Perks are added to the existing perks, and the potential/possible triggers are respected.the perkss listed in the exceptions list are not copied.
## scopes = { country }
alias[effect:copy_ascension_perks_from] = {
    target = scope[country]
    exceptions = {
        <ascension_perk>
    }
}

### Remove the target tradition from the scoped Country.
## scopes = { planet country ship pop_group }
alias[effect:remove_tradition] = <tradition>

### Remove the target tradition tree from the scoped Country.
## scopes = { planet country ship pop_group }
alias[effect:remove_tradition_tree] = <tradition_category>

### Adds the specified ascension perk to the scoped country.
## scopes = { country }
alias[effect:add_ascension_perk] = <ascension_perk>

### Remove the target ascension perk from the scoped Country.
## scopes = { planet country ship pop_group }
alias[effect:remove_ascension_perk] = <ascension_perk>

### Adds the defined amount of focus progress in the defined focus category
## scopes = { country }
alias[effect:add_focus_progress] = {
    category = <country_card_categories>
    amount = value_field
}

### Adds the amount of pops to the scope pop group.
## scopes = { pop_group }
alias[effect:add_pop_amount] = int_value_field

### Adds the amount of pops to the scope pop group.
## scopes = { pop_group }
alias[effect:add_pop_amount] = {
    ## cardinality = 1..1
    amount = int_value_field
    ## cardinality = 0..1
    random = int_value_field
}

### Removes the amount of pops from the scope pop group.
## scopes = { pop_group }
alias[effect:remove_pop_amount] = int_value_field
### Removes the amount of pops from the scope pop group.
## scopes = { pop_group }
alias[effect:remove_pop_amount] = {
    ## cardinality = 1..1
    amount = int_value_field
    ## cardinality = 0..1
    random = int_value_field
}
bonus_pop_growth
### Scales the amount of pops in the scope pop group
## scopes = { pop_group }
alias[effect:scale_pop_amount] = value_field

### Transfer the amount of pops from the source pop group to the target pop group
## scopes = any
alias[effect:transfer_pop_amount] = {
    source = scope[pop_group]
    target = scope[pop_group]
    ## cardinality = 0..1
    amount = int_value_field
    ## cardinality = 0..1
    percentage = float[0.0..1.0]
    ## cardinality = 0..1
    random = int_value_field
}

### Set planet preference trait for scoped species (removing the current one, if any).
## scopes = { species }
alias[effect:set_habitability_trait] = {
    ## cardinality = 0..inf
    trait = <trait.species_trait>
}

### Sets the confusion state on the target ship/fleet (all ships). Clears at the end of combat.
## scopes = { ship fleet }
alias[effect:set_confused] = bool

### Adds a specific amount of growth (non-fauna ships)
## scopes = { ship fleet }
alias[effect:add_growth] = int_value_field

### Resets growth to zero (non-fauna ships)
## scopes = { ship fleet }
alias[effect:reset_growth] = bool

### Removes a zone from the district of the planet
## scopes = { planet }
alias[effect:remove_zone] = {
    district = <district>
    zone = <zone>
    ## cardinality = 0..1
    zone_slot = <zone_slots>
    ## cardinality = 0..1
    all = bool
}

### Instantly destroys part of the assigned pops to this job
## scopes = { pop_job }
alias[effect:kill_assigned_pop_amount] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    amount = int_value_field
    ## cardinality = 0..1
    random = int_value_field
    ## cardinality = 0..1
    percentage = float[0.0..1.0]
}

### Triggers the merge of similar sub-species for a country.
## scopes = { country }
alias[effect:merge_species] = yes

### Enables a mission for target country
## scopes = any
alias[effect:enable_mission] = {
    name = <missions>
}

### Refreshes the scoped country's leader pool.
## scopes = { country }
alias[effect:refresh_leader_pool] = yes

### Adds specific resource to the stockpile for the country scope and creates a debris notification:
## scopes = { country }
alias[effect:add_resource_from_debris] = {
    ## cardinality = 0..inf
    <resource> = value_field
    ## cardinality = 0..1
    system = scope[system]
    ### optional: multiplies all gained resources by a variable)
    ## cardinality = 0..1
    mult = value_field
}

### Adds a percentage to the total time of the current terraforminog process on the planet
## scopes = { planet }
alias[effect:terraformation_total_time_mult] = value_field

### Iterate through all cosmic storms in the galaxy - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = cosmic_storm
alias[effect:random_cosmic_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    alias_name[effect] = alias_match_left[effect]
}


### Iterate through all cosmic storms in the galaxy - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = cosmic_storm
alias[effect:ordered_cosmic_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### integer, starting with 0
    ## cardinality = 1..1
    position = int

    ### <variable>/trigger:<trigger>
    ## cardinality = 1..1
    order_by = value_field


    ### default: no - if yes, then 0 is lowest rather than highest	## cardinality = 0..1
    inverse = bool

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems within the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:random_system_within_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    alias_name[effect] = alias_match_left[effect]

}

### Iterate through all systems within the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:ordered_system_within_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### integer, starting with 0
    ## cardinality = 1..1
    position = int

    ### <variable>/trigger:<trigger>
    ## cardinality = 1..1
    order_by = value_field


    ### default: no - if yes, then 0 is lowest rather than highest	## cardinality = 0..1
    inverse = bool

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems within the storm - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:every_system_within_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems valid to be a storms start position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = cosmic_storm
alias[effect:random_cosmic_storm_start_position] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems valid to be a storms start position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = cosmic_storm
alias[effect:ordered_cosmic_storm_start_position] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### integer, starting with 0
    ## cardinality = 1..1
    position = int

    ### <variable>/trigger:<trigger>
    ## cardinality = 1..1
    order_by = value_field

    ### default: no - if yes, then 0 is lowest rather than highest
    ## cardinality = 0..1
    inverse = bool

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems valid to be a storms start position - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = cosmic_storm
alias[effect:every_cosmic_storm_start_position] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems valid to be a storms end position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = any
## push_scope = cosmic_storm
alias[effect:random_cosmic_storm_end_position] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems valid to be a storms end position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = any
## push_scope = cosmic_storm
alias[effect:ordered_cosmic_storm_end_position] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### integer, starting with 0
    ## cardinality = 1..1
    position = int

    ### <variable>/trigger:<trigger>
    ## cardinality = 1..1
    order_by = value_field

    ### default: no - if yes, then 0 is lowest rather than highest
    ## cardinality = 0..1
    inverse = bool

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems valid to be a storms end position - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = any
## push_scope = cosmic_storm
alias[effect:every_cosmic_storm_end_position] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems added to the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:random_system_added_to_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems added to the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:ordered_system_added_to_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### integer, starting with 0
    ## cardinality = 1..1
    position = int

    ### <variable>/trigger:<trigger>
    ## cardinality = 1..1
    order_by = value_field

    ### default: no - if yes, then 0 is lowest rather than highest
    ## cardinality = 0..1
    inverse = bool

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems added to the storm - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:every_system_added_to_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems removed from storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:random_system_removed_from_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems removed from storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:ordered_system_removed_from_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### integer, starting with 0
    ## cardinality = 1..1
    position = int

    ### <variable>/trigger:<trigger>
    ## cardinality = 1..1
    order_by = value_field

    ### default: no - if yes, then 0 is lowest rather than highest
    ## cardinality = 0..1
    inverse = bool

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all systems removed from storm - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { cosmic_storm }
## push_scope = system
alias[effect:every_system_removed_from_storm] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { country }
## push_scope = cosmic_storm_influence_field
alias[effect:random_owned_storm_influence_field] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { country }
## push_scope = cosmic_storm_influence_field
alias[effect:ordered_owned_storm_influence_field] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### integer, starting with 0
    ## cardinality = 1..1
    position = int

    ### <variable>/trigger:<trigger>
    ## cardinality = 1..1
    order_by = value_field

    ### default: no - if yes, then 0 is lowest rather than highest
    ## cardinality = 0..1
    inverse = bool

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all influence fields owned by a country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { country }
## push_scope = cosmic_storm_influence_field
alias[effect:every_owned_storm_influence_field] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
## scopes = { cosmic_storm_influence_field }
## push_scope = system
alias[effect:random_system_in_cosmic_storm_influence_field] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### optional - adds weights to affect the chance a specific object is selected
    ## cardinality = 0..1
    weights = {
        alias_name[modifier_rule] = alias_match_left[modifier_rule]
    }

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
## scopes = { cosmic_storm_influence_field }
## push_scope = system
alias[effect:ordered_system_in_cosmic_storm_influence_field] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]

    ### integer, starting with 0
    ## cardinality = 1..1
    position = int

    ### <variable>/trigger:<trigger>
    ## cardinality = 1..1
    order_by = value_field

    ### default: no - if yes, then 0 is lowest rather than highest
    ## cardinality = 0..1
    inverse = bool

    alias_name[effect] = alias_match_left[effect]
}

### Iterate through all influence fields owned by a country - executes the enclosed effects on all of them for which the limit triggers return true
## scopes = { cosmic_storm_influence_field }
## push_scope = system
alias[effect:every_system_in_cosmic_storm_influence_field] = {
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[effect] = alias_match_left[effect]
}

