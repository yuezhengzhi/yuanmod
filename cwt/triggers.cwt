# value_field/int_value_field: use == if the left hand side works in trigger:<trigger>, otherwise use =

# scripted triggers

alias[trigger:<scripted_trigger>] = bool

alias[trigger:<scripted_trigger>] == int

# triggers

## scope = any
alias[trigger:<scripted_trigger>] = {
    ## cardinality = 0..inf
    $parameter = $parameter_value
}

### Evaluates the triggers if the display_triggers of the limit are met
## scopes = any
alias[trigger:if] = {
    ## cardinality = ~1..1
    limit = single_alias_right[trigger_clause]
    alias_name[trigger] = alias_match_left[trigger]
}

### Evaluates the enclosed triggers if the display_triggers of the preceding `if` or `else_if` is not met and its own display_trigger of the limit is met
### if = { limit = { <display_triggers> } <triggers> }
## scopes = any
alias[trigger:else_if] = {
    ## cardinality = ~1..1
    limit = single_alias_right[trigger_clause]
    alias_name[trigger] = alias_match_left[trigger]
}

### Evaluates the triggers if the display_triggers of preceding 'if' or 'else_if' is not met
### if = { limit = { <display_triggers> } <triggers> }
### else = { <triggers> }
## scopes = any
alias[trigger:else] = single_alias_right[trigger_clause]


### Checks if the country has any instance of target faction type
## scopes = { country }
alias[trigger:has_faction] = <pop_faction>

### Checks the faction's type
## scopes = { pop_faction }
alias[trigger:is_pop_faction_type] = <pop_faction>

### Compares relative power between two countries. relative_power = { who = <target country> category = <fleet/economy/technology/all> value ><= <pathetic/inferior/equivalent/superior/overwhelming>
## scopes = { country federation }
alias[trigger:relative_power] = {
    who = scope_group[target_country]
    who = scope[federation]
    ## cardinality = 0..1
    category = enum[relative_power_category]
    value = enum[relative_power_value]
}

### Checks if the country has a specific election type
## scopes = { country }
alias[trigger:has_election_type] = enum[election_type]

### Checks if the scope object has a certain modifier
## scopes = { megastructure planet country ship pop_group fleet galactic_object pop_faction federation starbase spy_network espionage_operation astral_rift }
alias[trigger:has_modifier] = <static_modifier>

### Checks if the country has a specific opinion modifier towards target country or anyone
## scopes = { country }
alias[trigger:has_opinion_modifier] = {
    who = scope_group[target_country]
    modifier = <opinion_modifier>
    ## cardinality = 0..1
    is_reverse = bool
}

# flags

### Checks if the empire has a specific flag
## scopes = { country }
## severity = warning
alias[trigger:has_country_flag] = value[country_flag]
### Checks if the planet has a specific flag
## scopes = { planet }
## severity = warning
alias[trigger:has_planet_flag] = value[planet_flag]
### Checks if the pop_group faction has a specific flag
## scopes = { pop_group pop_faction }
## severity = warning
alias[trigger:has_pop_faction_flag] = value[pop_faction_flag]
### Checks if the solar system has a specific flag
## scopes = { galactic_object dlc_recommendation }
## severity = warning
alias[trigger:has_star_flag] = value[star_flag]
### Checks if the solar system has a specific flag
## scopes = { galactic_object dlc_recommendation }
## severity = warning
alias[trigger:has_star_flag] = <precursors>
### Checks if the species has a specific flag
## scopes = { species }
## severity = warning
alias[trigger:has_species_flag] = value[species_flag]
### Checks if the pop_group has a specific flag
## scopes = { pop_group }
## severity = warning
alias[trigger:has_pop_group_flag] = value[pop_group_flag]
### Checks if the fleet has a specific flag
## scopes = { fleet }
## severity = warning
alias[trigger:has_fleet_flag] = value[fleet_flag]
### Checks if the ship has a specific flag
## scopes = { ship }
## severity = warning
alias[trigger:has_ship_flag] = value[ship_flag]
### Checks if a Global Flag has been set
## scopes = any
## severity = warning
alias[trigger:has_global_flag] = value[global_flag]
### Checks if the specified variable is set on the current scope. Use to avoid unset variables errors
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
## severity = warning
alias[trigger:is_variable_set] = value[variable]
### Checks if the leader has a specific flag
## scopes = { leader }
## severity = warning
alias[trigger:has_leader_flag] = value[leader_flag]
### Checks if the ambient object has a specific flag
## scopes = { ambient_object }
## severity = warning
alias[trigger:has_ambient_object_flag] = value[ambient_object_flag]
### Checks if the mega structure has a specific flag
## scopes = { megastructure }
## severity = warning
alias[trigger:has_megastructure_flag] = value[megastructure_flag]
### Checks if the deposit has a specific flag
## scopes = { deposit }
## severity = warning
alias[trigger:has_deposit_flag] = value[deposit_flag]
### Checks if the sector has a specific flag
## scopes = { sector }
## severity = warning
alias[trigger:has_sector_flag] = value[sector_flag]
### Checks if the archaeological site has a specific flag
## scopes = { archaeological_site }
## severity = warning
alias[trigger:has_archaeology_flag] = value[archaeology_flag]
### Checks if the starbase has a specific flag
## scopes = { starbase }
## severity = warning
alias[trigger:has_starbase_flag] = value[starbase_flag]
### Checks if the spy network has a specific flag
## scopes = { spy_network }
## severity = warning
alias[trigger:has_spynetwork_flag] = value[spynetwork_flag]
### Checks if the espionage asset has a specific flag
## scopes = { espionage_asset }
## severity = warning
alias[trigger:has_espionage_asset_flag] = value[espionage_asset_flag]
### Checks if the war has a specific flag
## scopes = { war }
## severity = warning
alias[trigger:has_war_flag] = value[war_flag]
### Checks if the army has a specific flag
## scopes = { army }
## severity = warning
alias[trigger:has_army_flag] = value[army_flag]
### Checks if the situation has a specific flag
## scopes = { situation }
## severity = warning
alias[trigger:has_situation_flag] = value[situation_flag]
### Checks if the agreement has a specific flag
## scopes = { agreement }
## severity = warning
alias[trigger:has_agreement_flag] = value[agreement_flag]

### Checks if the country has a relation flag towards target country
## scopes = { country }
alias[trigger:has_relation_flag] = {
    who = scope_group[target_country]
    flag = value[relation_flag]
}

### Checks if the target country has a relation flag towards the country
## scopes = { country }
alias[trigger:reverse_has_relation_flag] = {
    who = scope_group[target_country]
    flag = value[relation_flag]
}

### Checks if the country has a specific government type, or any government at all
## scopes = { country }
alias[trigger:has_government] = <government>
### Checks if the country has a specific government type, or any government at all
## scopes = { country }
alias[trigger:has_government] = bool

### Checks if the current country has the specified government authority
## scopes = { country dlc_recommendation }
alias[trigger:has_authority] = <authority>

### Checks if the current country has a certain civic and if its validated
## scopes = { country }
alias[trigger:has_valid_civic] = <civic_or_origin.civic>

### Checks if the current country has the specified civic
## scopes = { country dlc_recommendation }
alias[trigger:has_civic] = <civic_or_origin.civic>

### Checks if the current country has a certain civic and if its invalidated
## scopes = { country }
alias[trigger:has_invalid_civic] = <civic_or_origin.civic>

### Checks if the country has a specific policy
## scopes = { country }
alias[trigger:has_policy_flag] = enum[policy_flag]

### Checks if the current scope and the target scope are the same thing
## scopes = any
alias[trigger:is_same_value] = scope[any]


#should check for <> too
### Checks the percentage of pops in the scope that fulfill the specified criteria
## scopes = { planet country pop_faction sector }
## push_scope = pop_group
alias[trigger:pop_amount_percentage] = {
    limit = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    ### (optional: specifies pops to exclude from the calculation)
    exclude = single_alias_right[trigger_clause]
    percentage = value_field[0.0..1.0]
}

#should check for <> too
### Checks the faction's support level
### support > 0.5
## scopes = { leader pop_faction }
alias[trigger:support] == value_field[0.0..1.0]
### Checks the country's used naval capacity in relative terms (0.00-1.00)
## scopes = { country }
alias[trigger:used_naval_capacity_percent] == value_field
### Checks if the country is a specific type
## scopes = { country }
alias[trigger:is_country_type] = <country_type>
### Checks if a country has a certain ethos
## scopes = { country pop_group leader pop_faction dlc_recommendation }
alias[trigger:has_ethic] = <ethic>
### Checks if the pop_group has a specific ethos
## scopes = { pop_group }
alias[trigger:pop_group_has_ethic] = <ethic>

### Checks the country's used starbase capacity in relative terms (0.00-1.00)
## scopes = { country }
alias[trigger:used_starbase_capacity_percent] == value_field
### Checks the starbases's used defense platform capacity in relative terms (0.00-1.00)
## scopes = { starbase }
alias[trigger:used_defense_platform_capacity_percent] == value_field
### Checks the country's used starbase capacity in absolute numbers
## scopes = { country }
alias[trigger:used_starbase_capacity_integer] == int_value_field

#country only
### Checks if the country has an angry attitude towards target country
## scopes = { country }
alias[trigger:is_angry_to] = scope_group[target_country]
### Checks if the country has a patronizing attitude towards target country
## scopes = { country }
alias[trigger:is_patronizing_to] = scope_group[target_country]
### Checks if the country has a dismissive attitude towards target country
## scopes = { country }
alias[trigger:is_dismissive_to] = scope_group[target_country]
### Checks if the country has a threatened attitude towards target country
## scopes = { country }
alias[trigger:is_threatened_to] = scope_group[target_country]
### Checks if the country has a protective attitude towards target country
## scopes = { country }
alias[trigger:is_protective_to] = scope_group[target_country]
### Checks if the country has a neutral attitude towards target country
## scopes = { country }
alias[trigger:is_neutral_to] = scope_group[target_country]
### Checks if the country has a friendly attitude towards target country
## scopes = { country }
alias[trigger:is_friendly_to] = scope_group[target_country]
### Checks if the country has a loyal attitude towards target country
## scopes = { country }
alias[trigger:is_loyal_to] = scope_group[target_country]
### Checks if the country has a cordial attitude towards target country
## scopes = { country }
alias[trigger:is_cordial_to] = scope_group[target_country]
### Checks if the country has a belligerent attitude towards target country
## scopes = { country }
alias[trigger:is_belligerent_to] = scope_group[target_country]
### Checks if the country has a imperious attitude towards target country
## scopes = { country }
alias[trigger:is_imperious_to] = scope_group[target_country]
### Checks if the country has a arrogant attitude towards target country
## scopes = { country }
alias[trigger:is_arrogant_to] = scope_group[target_country]
### Checks if the country has a enigmatic attitude towards target country
## scopes = { country }
alias[trigger:is_enigmatic_to] = scope_group[target_country]
### Checks if the country has a berserker attitude towards target country
## scopes = { country }
alias[trigger:is_berserker_to] = scope_group[target_country]
### Checks if the country has a hostile attitude towards target country
## scopes = { country }
alias[trigger:is_hostile_to] = scope_group[target_country]
### Checks if the country has a domineering attitude towards target country
## scopes = { country }
alias[trigger:is_domineering_to] = scope_group[target_country]
### Checks if the country has an unfriendly attitude towards target country
## scopes = { country }
alias[trigger:is_unfriendly_to] = scope_group[target_country]
### Checks if the country has a disloyal attitude towards target country
## scopes = { country }
alias[trigger:is_disloyal_to] = scope_group[target_country]
### Checks if the country has a custodial attitude towards target country
## scopes = { country }
alias[trigger:is_custodial_to] = scope_group[target_country]
### Checks the number of pops assigned to the job (in total or from a specific pop group)
## scopes = { pop_job }
alias[trigger:num_pops_assigned_to_job] = {
    ### (if not specified, check total number)
    pop_group = scope[pop_group]
    value == value_field
}
### Checks if the country has a rival attitude towards target country
## scopes = { country }
alias[trigger:is_rival] = scope_group[target_country]
### Checks if the country is in a federation with target country
## scopes = { country }
alias[trigger:is_in_federation_with] = scope_group[target_country]
### Checks if the country has a defensive pact with target country
## scopes = { country }
alias[trigger:has_defensive_pact] = scope_group[target_country]
### Checks if two countries have a research agreement.
## scopes = { country }
alias[trigger:has_research_agreement] = scope_group[target_country]
### Checks if the country has established communications with target country
## scopes = { country }
alias[trigger:has_communications] = scope_group[target_country]
### Checks if the country is guaranteeing the independence of target country
## scopes = { country }
alias[trigger:is_guaranteeing] = scope_group[target_country]
### Checks if the country has a truce with target country
## scopes = { country }
alias[trigger:has_truce] = scope_group[target_country]
### Checks if the country is at war with the target country
## scopes = { country }
alias[trigger:is_at_war_with] = scope_group[target_country]
### Checks if the planet/system/fleet/ship is within the borders of the target country
## scopes = { planet ship fleet galactic_object }
alias[trigger:is_within_borders_of] = scope_group[target_country]
### Check if the country has a non-aggression pact with target country
## scopes = { country }
alias[trigger:has_non_aggression_pact] = scope_group[target_country]
### Checks if the planet/ship/fleet is controlled by the target country
## scopes = { planet ship fleet astral_rift }
alias[trigger:is_controlled_by] = scope_group[target_country]
### Checks if the country/planet is neighbors with target country
## scopes = { planet country ship fleet galactic_object }
alias[trigger:is_neighbor_of] = scope_group[target_country]
### Checks if the target country is the planet's original owner
## scopes = { planet }
alias[trigger:is_original_owner] = scope_group[target_country]
### Checks if the planet/system/army/ship is owned by the target country
## scopes = { megastructure planet ship pop_group fleet galactic_object leader army pop_faction starbase deposit sector archaeological_site first_contact spy_network espionage_operation agreement situation }
alias[trigger:is_owned_by] = scope_group[target_country]
### Checks if the country is the same as another, target country
## scopes = { country }
alias[trigger:is_same_empire] = scope_group[target_country]
### Checks if the country has migration access to target country
## scopes = { country }
alias[trigger:has_migration_access] = scope_group[target_country]
### Check if the country has closed its borders to target country
## scopes = { country }
alias[trigger:has_closed_borders] = scope_group[target_country]
### Checks if the country has a secret fealty from any of the target country's subjects
## scopes = { country }
alias[trigger:has_secret_fealty_from_subject_of] = scope_group[target_country]

### Checks if the pop_group/species/leader has rights
## scopes = { pop_group leader species }
alias[trigger:has_citizenship_rights] = bool

### checks if the scoped object is of the same species as another object
## scopes = { country ship pop_group leader army species }
alias[trigger:is_same_species] = scope_group[target_species]

### Checks if the scoped object is originally of the same species, or currently of the exact same species instance, as another object
## scopes = { country ship pop_group leader army species }
alias[trigger:is_exact_same_species] = scope_group[target_species]
### Checks if the pop group/country/species is a subspecies of the target species
## scopes = { country pop_group leader species }
alias[trigger:is_subspecies] = scope_group[target_species]
#any scope
### Checks if a target scope exists
## scopes = any
alias[trigger:exists] = scope[any]

### Checks if the country is hostile towards target country
## scopes = { country }
alias[trigger:is_hostile] = scope_group[target_country]

### Checks if the planet is the same as target planet
## scopes = { planet }
alias[trigger:is_planet] = scope_group[target_planet]
### Checks if the ship is the same as target ship
## scopes = { ship }
alias[trigger:is_ship] = scope[ship]
### Checks if the army is the same as target army
## scopes = { army }
alias[trigger:is_army] = scope[army]
### Checks if the country is the same as target country
## scopes = { country }
alias[trigger:is_country] = scope_group[target_country]


#should also check < >
### Checks the planet's habitability (0 to 1) for target pop_group/species
## scopes = { planet }
alias[trigger:habitability] = {
    who = scope_group[target_species]
    value = value_field[0.0..1.0]
}

#should also check < >
### Checks the ship's hull points
## scopes = { ship }
alias[trigger:has_hp] == value_field
### Checks a fleet or ship's hit points percentage
## scopes = { ship fleet }
alias[trigger:has_hp_percentage] == value_field[0.0..1.0]
### Checks a fleet or ship's armor hit points percentage
## scopes = { ship fleet }
alias[trigger:has_armor_percentage] == value_field[0.0..1.0]
### Checks a fleet or ship's shield hit points percentage
## scopes = { ship fleet }
alias[trigger:has_shield_percentage] == value_field[0.0..1.0]

#should also check < > and <=
### Checks the number of in-game years passed since the end-game start date
## scopes = any
alias[trigger:end_game_years_passed] == int_value_field
### Checks the number of in-game years passed since the mid-game start date
## scopes = any
alias[trigger:mid_game_years_passed] == int_value_field

### Checks if the country is in a federation
## scopes = { country }
alias[trigger:has_federation] = bool
### Checks if the country is at war
## scopes = { country }
alias[trigger:is_at_war] = bool
### Checks if the country is played by the AI
## scopes = { country }
alias[trigger:is_ai] = bool
### Checks whether a planet is under bombardment
## scopes = { planet }
alias[trigger:has_orbital_bombardment] = bool
### Checks if the planet is colonized (in planet scope) or the system has an owner (in system scope)
## scopes = { planet galactic_object }
alias[trigger:has_owner] = bool
### Checks if ground combat is taking place on the planet
## scopes = { planet }
alias[trigger:has_ground_combat] = bool
### Sets trigger to be either always true or false
## scopes = any
alias[trigger:always] = bool
### Checks if the country is a subject of any other country
## scopes = { country }
alias[trigger:is_subject] = bool
### Checks if the planet is being colonized
## scopes = { planet }
alias[trigger:is_under_colonization] = bool
### Checks if the country recently lost a war ('recently' meaning recent enough to have a truce)
## scopes = { country }
alias[trigger:recently_lost_war] = bool
### Checks if the planet is colonized
## scopes = { planet }
alias[trigger:is_colony] = bool
### Checks if the ship/fleet is engaged in combat
## scopes = { ship fleet }
alias[trigger:is_in_combat] = bool
### Checks if the planet is a star
## scopes = { planet }
alias[trigger:is_star] = bool
### Checks if the planet is an asteroid
## scopes = { planet }
alias[trigger:is_asteroid] = bool
### Checks if the planet has any strategic resource
## scopes = { planet }
alias[trigger:has_any_strategic_resource] = bool
### Checks if the country leads in a war
## scopes = { country pop_faction }
alias[trigger:is_war_leader] = bool
### Checks if the planet is under military occupation
## scopes = { planet }
alias[trigger:is_occupied_flag] = bool

### Checks if the planet is of a certain class
## scopes = { planet dlc_recommendation }
alias[trigger:is_planet_class] = <planet_class>
### Checks if the planet is of a certain class
## scopes = { planet dlc_recommendation }
alias[trigger:is_planet_class] = scope_group[target_planet]
### Checks if the system/planet(star) is of a certain class
## scopes = { planet galactic_object }
alias[trigger:is_star_class] = <star_class>
### Checks if the system/planet(star) is of a certain class
## scopes = { planet galactic_object }
alias[trigger:is_star_class] = scope[system]
### Checks if the planet is a ringworld
## scopes = { planet }
alias[trigger:is_ringworld] = bool
### Checks if the planet is its owner's homeworld
## scopes = { planet }
alias[trigger:is_homeworld] = bool
### checks if the planet/ship/fleet/system is inside a nebula
## scopes = { planet ship fleet galactic_object }
alias[trigger:is_inside_nebula] = bool
### Checks if the planet has a moon
## scopes = { planet }
alias[trigger:has_moon] = bool
### Checks the planet's number of moons
## scopes = { planet }
alias[trigger:num_moons] == int_value_field
### Checks if the planet can theoretically be colonized
## scopes = { planet }
alias[trigger:is_colonizable] = bool

### Checks if the planet is of the ideal class for target country, species or pop
## scopes = { planet }
alias[trigger:is_ideal_planet_class] = {
    who = scope_group[target_species]
    status = bool
}

### Returns true if the scopes system contains at least one natural wormhole
## scopes = { galactic_object }
alias[trigger:has_natural_wormhole] = bool


### Checks if the country has a specific edict enabled
## scopes = { country }
alias[trigger:has_edict] = <edict>

### Checks if target country is participating in the war on the specified side
## scopes = { country war }
alias[trigger:is_war_participant] = {
    ## cardinality = 0..1
    who = scope_group[target_country]
    ## cardinality = 0..1
    war = scope[war]
    ## cardinality = 0..1
    side = scope_group[target_country]
    ## cardinality = 0..1
    side = enum[war_side]
}
### Checks if target country is participating in the war on the specified side
## scopes = { country war }
alias[trigger:is_war_participant] = scope_group[target_country]
### Checks if target country is participating in the war on the specified side
## scopes = { country war }
alias[trigger:is_war_participant] = scope[war]

### Checks the country's opinion of the target country
## scopes = { country }
alias[trigger:opinion] = {
    who = scope_group[target_country]
    value = int_value_field
}

#should check <>
### Checks the pop_group's happiness percentage
## scopes = { pop_group }
alias[trigger:happiness] == value_field[0.0..1.0]
### Checks the country's number of subjects with agreement preset 'preset_vassal'
## scopes = { country }
alias[trigger:vassals] == int_value_field
### Checks the country's number of subjects
## scopes = { country }
alias[trigger:subjects] == int_value_field
### Checks the number of regular empires in the galaxy
## scopes = { country }
alias[trigger:num_empires] == int_value_field
# ### Checks the number of members in the alliance
#alias[trigger:members] == int_value_field
### Checks the country's number of established communications
## scopes = { country }
alias[trigger:num_communications] == int_value_field
### Compares the number of AP points the country has spent with the given value
## scopes = { country }
alias[trigger:num_ascension_perks] == int_value_field
### Compares the number of unlocked ascension perk slots of the scope with the given value
### num_ascension_perks > 7
## scopes = { country }
alias[trigger:num_ascension_perk_slots] == int_value_field
### Checks the number of active gateways owned by the scoped country
## scopes = { country }
alias[trigger:num_owned_active_gateways] == int_value_field
### Checks the number of active gateways in the galaxy
## scopes = any
alias[trigger:num_active_gateways] == int_value_field

### Checks the country/pop_group/leader/species' number of traits points spent
## scopes = { country pop_group leader species }
alias[trigger:num_trait_points] == int_value_field

### Checks if the leader has a specific experience level
## scopes = { leader }
alias[trigger:has_base_skill] == int_value_field

### Checks if the leader has a specific total (base + effective) experience level
## scopes = { leader }
alias[trigger:has_total_skill] == int_value_field

### Checks the war exhaustion of the war's defenders
## scopes = { war }
alias[trigger:defender_war_exhaustion] == value_field[0.0..1.0]
### Checks the country's total war exhaustion for all offensive wars
## scopes = { country }
alias[trigger:off_war_exhaustion_sum] == value_field
### Checks the country's total war exhaustion for all defensive wars
## scopes = { country }
alias[trigger:def_war_exhaustion_sum] == value_field

### Checks the scope's total fleet power
## scopes = { country fleet federation }
alias[trigger:fleet_power] == value_field

### Compares the type of scope's mega structure to a type from the database.
## scopes = { megastructure }
alias[trigger:is_megastructure_type] = <megastructure>
### Checks if the scope's fleet or mega structure is currently upgrading.
## scopes = { megastructure fleet }
alias[trigger:is_upgrading] = bool
### Checks if the scope's fleet, ship, starbase or megastructure can be upgraded.
## scopes = { megastructure ship fleet starbase }
alias[trigger:can_be_upgraded] = bool
### Checks if the planet has a planetary ring
## scopes = { planet }
alias[trigger:has_ring] = bool
### Checks if the planet is the moon of another planet
## scopes = { planet }
alias[trigger:is_moon] = bool
#alias[trigger:pops_have_happiness] = bool				#deprecated
### Checks if the country is a pirate country
## scopes = { country }
alias[trigger:is_pirate] = bool
# ### Checks if the planet/fleet is controlled by a sector
#alias[trigger:sector_controlled] = bool
### Checks if the scoped ship design, ship or fleet (all ships) has a designable ship size.
## scopes = { ship fleet design ship_growth_stage }
alias[trigger:is_designable] = bool

### Checks if the leader is of a specific class
## scopes = { leader }
alias[trigger:leader_class] = <leader_class>

### Checks if the observation post has a specific mission
## scopes = { fleet }
alias[trigger:has_mission] = <observation_station_mission>

#these should check < and > too
### Checks the number of in-game years passed since the 2200 start
## scopes = any
alias[trigger:years_passed] == int_value_field
### Checks the country's or sector's number of owned planets
## scopes = { country sector }
alias[trigger:num_owned_planets] == int_value_field
### Compares the stability present on the planet with the given value
## scopes = { planet }
alias[trigger:planet_stability] == value_field[0.0..100.0]
### Checks the number of pops on the planet/country/pop_group faction/sector
## scopes = { planet country pop_faction sector }
alias[trigger:num_pops] == int_value_field
### Checks the planet's size
## scopes = { planet }
alias[trigger:planet_size] == int_value_field
### Checks the number of fallen empires in the galaxy
## scopes = { country }
alias[trigger:num_fallen_empires] == int_value_field
### Checks the planet's (colony's) age in months
## scopes = { planet }
alias[trigger:colony_age] == int_value_field
### Checks the planet's (colony's) age in years
## scopes = { planet }
alias[trigger:colony_age_years] == int_value_field
### Checks the country/pop_group's number of ethics
## scopes = { country pop_group }
alias[trigger:num_ethics] == int_value_field

### Checks if the ship/fleet/design is a specific ship size
## scopes = { ship fleet design ship_growth_stage }
alias[trigger:is_ship_size] = <ship_size>

### Checks if the ship/fleet/design is a specific class
## scopes = { ship fleet design ship_growth_stage }
alias[trigger:is_ship_class] = enum[ship_class]

### Checks the country's number available tech research options in a specific field
## scopes = { country }
alias[trigger:count_tech_options] = {
    area = enum[research_area]
    count = int_value_field
}

### Checks if the country's researcher in a specific field meets the specified criteria
## scopes = { country }
## push_scope = leader
alias[trigger:research_leader] = {
    area = enum[research_area]
    ## cardinality = 0..100
    alias_name[trigger] = alias_match_left[trigger]
}

### Checks the average ethics divergence on the planet, i.e. num of pops not of the country's ethics / total num of pops
## scopes = { planet }
alias[trigger:ethos] == value_field[0.0..1.0]

### Checks the leader's gender
## scopes = { leader }
alias[trigger:gender] = enum[genders_not_set]

### Checks what gender settings the species allows.
## scopes = { species }
alias[trigger:species_gender] = enum[genders_not_set]

### Checks if scoped leader is idle
## scopes = { leader }
alias[trigger:is_idle] = bool

### Checks if the country is a primitive, pre-FTL civilization
## scopes = { country }
alias[trigger:is_primitive] = bool

### Checks if the pop group or species is sapient
## scopes = { pop_group species }
alias[trigger:is_sapient] = bool

### Checks if the pop group or species inherits the base species' rights. Returns false if there is no parent species.
## scopes = { pop_group species }
alias[trigger:inherits_parent_rights] = bool

### Checks if the planet is prevented from generating anomalies
## scopes = { planet }
alias[trigger:is_preventing_anomaly] = bool

### Checks if the planet has an observation post
## scopes = { planet }
alias[trigger:has_observation_outpost] = bool

### Checks if the system is the starting system for any country
## scopes = { galactic_object }
alias[trigger:starting_system] = bool

### Checks if the country/ship/megastructure/species has specific graphical culture or the same graphical culture as the target. When used on a species this compares the culture of the species class to the target.
## scopes = { megastructure country ship species }
alias[trigger:graphical_culture] = <graphical_culture>

### Checks if the country/ship/megastructure/species has specific graphical culture or the same graphical culture as the target. When used on a species this compares the culture of the species class to the target.
## scopes = { megastructure country ship species }
alias[trigger:graphical_culture] = scope_group[target_graphical_culture]

### Checks if the planet is still owned by its first colonizer
## scopes = { planet }
alias[trigger:original_owner] = bool

### Checks if the pop_group is a robot
## scopes = { pop_group }
alias[trigger:is_robot_pop] = bool

### Checks if the pop_group is a robot
## scopes = { pop_group }
alias[trigger:is_robot_pop_group] = bool

### Checks if the scoped fleet is an alliance fleet.
## scopes = { fleet }
alias[trigger:is_alliance_fleet] = bool

### Checks if the planet is its owner's capital
## scopes = { planet }
alias[trigger:is_capital] = bool

#alias[trigger:has_blocker] = bool #deprecated, I think
#alias[trigger:has_blocker] = <deposit.blocker> #deprecated, I think

### Checks if the planet can be colonized by target country
## scopes = { planet }
alias[trigger:can_colonize] = {
    who = scope_group[target_country]
    status = bool
}

### Checks the relative amount of already-researched tech between the country and target country
## scopes = { country }
alias[trigger:tech_unlocked_ratio] = {
    who = scope_group[target_country]
    ratio = value_field[0.0..2.0]
}

### Checks if a country has the given ascension perk.
## scopes = { country }
alias[trigger:has_ascension_perk] = <ascension_perk>

### Checks if the country has a technology (of at least a specific level)
## scopes = { country }
alias[trigger:has_technology] = <technology>

### Checks if a country has the given tradition or tradition swap. Tradition specified must be the one giving effects, i.e. tradition swaps with 'inherit_effects = yes' are ignored and the base tradition should be specified in those cases.
## scopes = { country }
alias[trigger:has_active_tradition] = <tradition>
### Checks if a country has the given tradition or tradition swap. Tradition specified must be the one giving effects, i.e. tradition swaps with 'inherit_effects = yes' are ignored and the base tradition should be specified in those cases.
## scopes = { country }
alias[trigger:has_active_tradition] = <swapped_tradition>

### Checks a variable for the country/leader/planet/system/fleet
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[trigger:check_variable] = {
    which = value[variable]
    ## cardinality = 1..2
    value = value_field
}


### Checks the ship/fleet/planet/leader/pop_group/system's galaxy map distance to target in absolute units
## scopes = { megastructure planet ship pop_group fleet galactic_object leader ambient_object starbase deposit archaeological_site first_contact }
alias[trigger:distance] = {
    ## cardinality = 0..1
    source = scope_group[celestial_coordinate]
    ## cardinality = 0..1
    ### Must use >= or will create error log entry
    min_distance = int
    ## cardinality = 0..1
    ### Must use <= or will create error log entry
    max_distance = int
    ## cardinality = 0..1
    ### Euclidean means the shortest distance from A to B, "as the crow flies" (hyperlane by default)
    type = enum[hyperlane_euclidean]
    ## cardinality = 0..1
    ### Whether to use bypasses (wormholes/gateways) when evaluating distance (yes by default). Caligula's note: I think it is no by default. If it is "yes", it requires bypass_empire to work
    use_bypasses = bool
    ## cardinality = 0..1
    ### Determines what bypass can be used. This parameter is ignored if uses_bypass=false. If unset, bypasses will be ignored. It will check the bypasses available to the specified country. To check all possible bypasses, use e.g. the global event country.
    bypass_empire = scope_group[target_country]
    ## cardinality = 0..1
    min_jumps = int
    ## cardinality = 0..1
    max_jumps = int
    ## cardinality = 0..1
    same_solar_system = bool
}

### Checks if the pop_group/country's founder species is a specific species class
## scopes = { country pop_group species dlc_recommendation }
alias[trigger:is_species_class] = <species_class>

#could be refined to check leader or species traits depending on scope
### Checks if a pop_group/leader/species/country's dominant species has a certain trait
## scopes = { country pop_group leader species dlc_recommendation }
alias[trigger:has_trait] = <trait>

### Checks if the pop_group has a specific trait
## scopes = { pop_group }
alias[trigger:pop_group_has_trait] = <trait.species_trait>
### Checks if a leader has a certain ruler trait, even if they are not currently ruler
## scopes = { leader }
alias[trigger:has_ruler_trait] = <trait.leader_trait>

### Checks if a species/pop_group/leader has a particular citizenship type in their country
## scopes = { pop_group leader species }
alias[trigger:has_citizenship_type] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <citizenship_type>
}
### Checks if a species/pop_group/leader has a particular military service type in their country
## scopes = { pop_group leader species }
alias[trigger:has_military_service_type] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <military_service_type>
}
### Checks if a species/pop_group/leader has a particular purge type in their country
## scopes = { pop_group leader species }
alias[trigger:has_purge_type] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <purge_type>
}
### Checks if a species/pop_group/leader has a particular slavery type in their country
## scopes = { pop_group leader species }
alias[trigger:has_slavery_type] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <slavery_type>
}

### Checks if the pop_group is prevented from reproducing
## scopes = { pop_group leader species }
alias[trigger:has_population_control] = {
    type = bool
    type = <population_control>
    ## cardinality = 0..1
    country = scope_group[target_country]
}

### Checks if the pop_group is prevented from migrating
## scopes = { pop_group leader species }
alias[trigger:has_migration_control] = {
    type = bool
    type = <migration_control>
    ## cardinality = 0..1
    country = scope_group[target_country]
}

### Checks if the pop_group is prevented from migrating
## scopes = { pop_group leader species }
alias[trigger:has_colonization_control] = {
    type = bool
    type = <colonization_control>
    ## cardinality = 0..1
    country = scope_group[target_country]
}

### Checks if a species/pop_group/leader has a particular living standard in their country
## scopes = { pop_group leader species }
alias[trigger:has_living_standard] = {
    ## cardinality = 0..1
    country = scope_group[target_country]
    type = <living_standard>
}

### Replaces the tooltips for the enclosed triggers with a custom text
## scopes = any
alias[trigger:custom_tooltip] = localisation
### Replaces the tooltips for the enclosed triggers with a custom text
## scopes = any
alias[trigger:custom_tooltip] = {
    ## cardinality = 0..1
    text = ""
    ## cardinality = 0..1
    text = localisation
    ## cardinality = 0..1
    fail_text = default
    ## cardinality = 0..1
    fail_text = localisation
    ## cardinality = 0..1
    success_text = localisation
    alias_name[trigger] = alias_match_left[trigger]
}

#< >
### Checks the number of in-game years country has been at peace, with optional parameter to delay from start of game
## scopes = { country }
alias[trigger:years_of_peace] = {
    ## cardinality = 0..1
    delay = int #no variables here atm
    value = int_value_field
}
### Checks the fleet's fleet size
## scopes = { fleet }
alias[trigger:fleet_size] == int_value_field

### Checks the game's difficulty level (0 to 6, with 0 as Civilian and 6 as Grand Admiral)
## scopes = any
alias[trigger:is_difficulty] == int_value_field[0..6]

### Checks if the planet has any, or a specific, building
## scopes = { planet }
alias[trigger:has_building] = bool
### Checks if the planet has any, or a specific, building
## scopes = { planet }
alias[trigger:has_building] = <building>

### Checks if the planet has a specific building, and that that building is not disabled or ruined.
## scopes = { planet }
alias[trigger:has_active_building] = <building>

### Checks if the planet has any, or a specific, ongoing building construction
## scopes = { planet }
alias[trigger:has_building_construction] = bool
### Checks if the planet has any, or a specific, ongoing building construction
## scopes = { planet }
alias[trigger:has_building_construction] = <building>

### Checks if an AI empire has a certain personality type
## scopes = { country }
alias[trigger:has_ai_personality] = <ai_personality>
### Checks if a country has a certain AI personality behavior
## scopes = { country }
alias[trigger:has_ai_personality_behaviour] = enum[ai_personality_behaviour]


#check < >
### Checks the country's amount of a specific stored resource
## scopes = { country }
alias[trigger:has_country_resource] = {
    type = <resource>
    amount = value_field
}
### Checks if the planet has a specific amount of a specific resource
## scopes = { planet country deposit astral_rift }
alias[trigger:has_resource] = <resource>
### Checks if the planet has a specific amount of a specific resource
## scopes = { planet country deposit astral_rift }
alias[trigger:has_resource] = bool
### Checks if the planet has a specific amount of a specific resource
## scopes = { planet country deposit astral_rift }
alias[trigger:has_resource] = {
    type = <resource>
    amount = int #no variables here for some reason atm
}

### Checks if the planet has any strategic resource
## scopes = { planet astral_rift }
alias[trigger:has_strategic_resource] = bool

### Checks the country's monthly income of a specific resource
## scopes = { country }
alias[trigger:has_monthly_income] = {
    ## cardinality = 1..1
    enum[type_or_resource] = <resource>
    value = value_field
}

### Checks if the planet has any, or a specific, deposit
## scopes = { planet deposit }
alias[trigger:has_deposit] = bool
### Checks if the planet has any, or a specific, deposit
## scopes = { planet deposit }
alias[trigger:has_deposit] = <deposit>

### Checks if the planet has a deposit for a specific ship class
## scopes = { planet }
alias[trigger:has_deposit_for] = enum[ship_class]

### Checks if the country has claims on the given country or system.
## scopes = { country }
alias[trigger:has_claim] = scope_group[target_country]
### Checks if the country has claims on the given country or system.
## scopes = { country }
alias[trigger:has_claim] = scope[system]

### Checks if the local player has a specific DLC enabled
## scopes = any
alias[trigger:local_has_dlc] = enum[dlc]
### Checks if the host has a specific DLC enabled
## scopes = any
alias[trigger:host_has_dlc] = enum[dlc]
### Checks if the game is running in multiplayer
## scopes = any
alias[trigger:is_multiplayer] = bool


### Checks if the pop_group belongs to any, or a specific, faction
## scopes = { pop_group }
alias[trigger:member_of_faction] = bool
### Checks if the pop_group belongs to any, or a specific, faction
## scopes = { pop_group }
alias[trigger:member_of_faction] = scope[pop_faction]
### Checks if the pop_group belongs to any, or a specific, faction
## scopes = { pop_group }
alias[trigger:member_of_faction] = <pop_faction>

### Checks if the country has a specific event chain
## scopes = { country }
alias[trigger:has_event_chain] = <event_chain>

### Checks if the country has completed a specific counter in an event chain
## scopes = { country }
alias[trigger:has_completed_event_chain_counter] = {
    event_chain = <event_chain>
    counter = enum[event_chain_counter]
}

### Checks if the country has a specific special project available
## scopes = { country }
alias[trigger:has_special_project] = <special_project>

### Checks the army's type
## scopes = { army }
alias[trigger:army_type] = <army>


### Checks the war exhaustion of the war's attackers
## scopes = { war }
alias[trigger:attacker_war_exhaustion] == value_field[0.0..1.0]

### Checks the country's energy credit balance
## scopes = { country }
alias[trigger:balance] == value_field

### Returns true if the specified number of sub-triggers return true
## scopes = any
alias[trigger:calc_true_if] = {
    amount = int_value_field
    alias_name[trigger] = alias_match_left[trigger]
}

### Checks if the country can change a specific policy
## scopes = { country }
alias[trigger:can_change_policy] = <policy>

### Checks if the country is allowed to control target country's border access to the country
## scopes = { country }
alias[trigger:can_control_access_for] = scope_group[target_country]

### Checks if the country can declare war against target country
## scopes = { country }
alias[trigger:can_declare_war] = {
    target = scope_group[target_country]
    attacker_war_goal = <war_goal>
}


### Checks if scoped pop_group can join a faction
## scopes = { pop_group }
alias[trigger:can_join_factions] = bool

### Checks if one of the faction's parameters is the same as target scope
## scopes = { pop_faction }
alias[trigger:check_pop_faction_parameter] = {
    which = enum[pop_faction_parameter]
    value = scope[any]
}

### Checks the country's command limit
## scopes = { country }
alias[trigger:command_limit] == int_value_field

### The enclosed trigger will be completely ignored if the condition in "trigger" isn't true. Useful to hide part of tooltips that are not relevant.
## scopes = any
alias[trigger:conditional_tooltip] = {
    trigger = single_alias_right[trigger_clause]
    alias_name[trigger] = alias_match_left[trigger]
}

### Shows custom text only when the associated trigger fails
## scopes = any
alias[trigger:custom_tooltip_fail] = {
    text = localisation
    alias_name[trigger] = alias_match_left[trigger]
}


### Adjusts progress of triggers inside it
## scopes = any
alias[trigger:custom_progress] = {
    alias_name[trigger] = alias_match_left[trigger]
    ## cardinality = 0..1
    current_val_coeff = value_field
    ## cardinality = 0..1
    final_val_coeff = value_field
    ## cardinality = 0..1
    mode = enum[trigger_custom_progress]
}

### Nullifies progress of triggers inside it and returns progress '0 of 0'
## scopes = any
alias[trigger:hidden_progress] = {
    alias_name[trigger] = alias_match_left[trigger]
}

### Hides the progress of the triggers inside and returns progresses '0 of 1' or '1 of 1'
## scopes = any
alias[trigger:simple_progress] = {
    alias_name[trigger] = alias_match_left[trigger]
}

### Shows custom text only when the associated trigger passes
## scopes = any
alias[trigger:custom_tooltip_success] = {
    text = localisation
    alias_name[trigger] = alias_match_left[trigger]
}

### Trigger an assertion to stop the debugger when encountering this trigger; returns the value it is assigned
## scopes = any
alias[trigger:debug_break] = scalar


### Checks the ship/fleet/planet/leader/pop_group/system's distance to the galactic core in percent, where center = 0 and galactic rim = 100
## scopes = any
alias[trigger:distance_to_core_percent] == value_field

### Checks the ship/fleet/planet/system's galaxy map distance to target empire
## scopes = { planet ship fleet galactic_object }
alias[trigger:distance_to_empire] = {
    who = scope_group[target_country]
    distance = int_value_field
    ## cardinality = 0..1
    use_bypasses = bool
    ## cardinality = 0..1
    type = enum[hyperlane_euclidean]
}

### Checks the country's monthly energy credit expenses
## scopes = { country }
alias[trigger:expenses] == value_field

## scopes = any
alias[trigger:success_text] = localisation

### For 'desc={trigger={' use. Shows custom text when the associated trigger passes.
## scopes = any
alias[trigger:success_text] = {
    text = localisation
    ## cardinality = 0..inf
    alias_name[trigger] = alias_match_left[trigger]
}

## scopes = any
alias[trigger:fail_text] = localisation

### For 'desc={trigger={' use. Shows custom text when the associated trigger fails.
## scopes = any
alias[trigger:fail_text] = {
    text = localisation
    alias_name[trigger] = alias_match_left[trigger]
}

### Compares the former citizenship type with the given one.
## scopes = { pop_group }
alias[trigger:former_citizenship_type] = <citizenship_type>

### Compares the former living standard type with the given one.
## scopes = { pop_group }
alias[trigger:former_living_standard_type] = <living_standard>

### Compares the former migration control type with the given one.
## scopes = { pop_group }
alias[trigger:former_migration_control_type] = <migration_control>

### Checks the inner radius of a solar system
## scopes = { galactic_object }
alias[trigger:inner_radius] = int_value_field

### Compares the former military service type with the given one.
## scopes = { pop_group }
alias[trigger:former_military_service_type] = <military_service_type>

### Compares the former population control type with the given one.
## scopes = { pop_group }
alias[trigger:former_population_control_type] = <population_control>

### Compares the former purge type with the given one.
## scopes = { pop_group }
alias[trigger:former_purge_type] = <purge_type>

### Compares the former slavery type with the given one.
## scopes = { pop_group }
alias[trigger:former_slavery_type] = <slavery_type>

### Checks if the country has a specific percentage (0.00-1.00) of the galaxy within its borders
## scopes = { country }
alias[trigger:galaxy_percentage] == value_field[0.0..1.0]

### Checks the average happiness on the planet
## scopes = { planet }
alias[trigger:happiness_planet] == value_field[0.0..1.0]

### Checks if the target country is allowed to enter the system
## scopes = { galactic_object }
alias[trigger:has_access_fleet] = scope_group[target_country]

### Checks if the planet has an anomaly
## scopes = { planet }
alias[trigger:has_anomaly] = bool

### Checks if the scope has a megastructure
## scopes = { planet galactic_object }
alias[trigger:has_any_megastructure] = bool

### Checks if the planet has an army
## scopes = { planet }
alias[trigger:has_army] = bool

### Check if the country has federation association status with target country
## scopes = { country }
alias[trigger:has_association_status] = scope_group[target_country]

### Checks if the fleet/ship has an active auto-move target set
## scopes = { ship fleet }
alias[trigger:has_auto_move_target] = bool

### Checks if the country has a valid casus belli (any casus belli or a specific one) on the given country.
## scopes = { country }
alias[trigger:has_casus_belli] = {
    target = scope[country]
    ## cardinality = 0..1
    type = <casus_belli>
}

### Checks if the colony has a certain designation
## scopes = { planet }
alias[trigger:has_designation] = <colony_type>
### Checks if the colony has a certain designation
## scopes = { planet }
alias[trigger:has_designation] = scope_group[target_planet]

### Checks if a ship has a certain component
## scopes = { design ship ship_growth_stage }
alias[trigger:has_component] = <component_template>

### Checks if two countries have a migration treaty.
## scopes = { country }
alias[trigger:has_diplo_migration_treaty] = scope_group[target_country]

### Checks if the country has established contact with target country
## scopes = { country }
alias[trigger:has_established_contact] = scope_group[target_country]

### Checks if the country has a specific ship design available
## scopes = { country }
alias[trigger:has_existing_ship_design] = <ship_size>

### Checks if the leader has a specific amount of experience
## scopes = { leader }
alias[trigger:has_experience] == int_value_field

### Checks if the ship/fleet has a specific fleet order. Fleet orders include: move_to_system_point_order orbit_planet_order build_orbital_station_order build_space_station_order colonize_planet_order survey_planet_order research_discovery_orde research_anomaly_order collect_data_fleet_order upgrade_design_at_starbase_fleet_order upgrade_design_at_orbitable_fleet_order return_fleet_order repair_fleet_order evade_hostiles_order follow_order land_armies_order merge_fleet_order aggressive_stance_fleet_order auto_explore_order build_megastructure_fleet_order destroy_planet_order planet_killer_weapon_windup_order planet_killer_weapon_fire_order explore_bypass_order use_bypass_order jumpdrive_order jumpdrive_windup experimental_subspace_navigation_fleet_order excavate_archaeological_site_fleet_order
## scopes = { ship fleet }
alias[trigger:has_fleet_order] = enum[fleet_order]

### Checks if the system has a hyperlane connection to target system
## scopes = { galactic_object }
alias[trigger:has_hyperlane_to] = scope[galactic_object]
### Checks if the system has a hyperlane connection to target system
## scopes = { galactic_object }
alias[trigger:has_hyperlane_to] = scope_group[target_country]

### Checks if a country or star has a mega structure
### Does not accept boolean.
## scopes = { country galactic_object }
alias[trigger:has_megastructure] = <megastructure>

### Checks if the planet has an orbital mining station
## scopes = { planet }
alias[trigger:has_mining_station] = bool

### Checks if a country has a certain notification modifier
## scopes = { country }
alias[trigger:has_notification_modifier] = <notification_modifier>

### Checks to what degree the planet is being bombarded
## scopes = { planet }
alias[trigger:has_orbital_bombardment_stance] = <bombardment_stance>

### Checks if the planet has any kind of orbital station
## scopes = { planet }
alias[trigger:has_orbital_station] = bool

### Checks if the system has planet of specific class
## scopes = { galactic_object }
alias[trigger:has_planet_class] = <planet_class>

### Checks if the system has planet of specific class
## scopes = { galactic_object }
alias[trigger:has_planet_class] = scope_group[target_planet]

### Checks if the planet has a specific planet modifier
## scopes = { planet }
alias[trigger:has_planet_modifier] = <planet_modifier>

### Checks if the scoped country has a specific point of interest in its situation log
## scopes = { planet country ship fleet galactic_object ambient_object }
alias[trigger:has_point_of_interest] = {
    poi = value[point_of_interest]
}

### Checks if a system contains any fleets, stations, mega structures or colonized planets.
## scopes = { galactic_object }
alias[trigger:has_presence] = bool

### Checks if the planet has an orbital research station
## scopes = { planet }
alias[trigger:has_research_station] = bool

### Checks if a country has the same ethos (complete set of ethics) as a country or pop_group
## scopes = { country pop_group }
alias[trigger:has_same_ethos] = scope_group[target_country]

### Checks the scoped country has ever encountered a bypass of a given type before
## scopes = { country }
alias[trigger:has_seen_any_bypass] = <bypass>

### Checks the scoped country has encountered a specific bypass before
## scopes = { country }
alias[trigger:has_seen_specific_bypass] = scope[bypass]

### Checks if the starbase has a specific building
### WARNING: Does not count queued buildings
## scopes = { starbase }
alias[trigger:has_starbase_building] = <starbase_building>

### Checks if the starbase has a specific module
## scopes = { starbase }
alias[trigger:has_starbase_module] = <starbase_module>

### Compares the starbase ship size
## scopes = { starbase }
alias[trigger:has_starbase_size] = <ship_size.starbase>

### Checks the current status of the scoped ship or fleet.
## scopes = { ship fleet }
alias[trigger:has_status] = enum[colossus_statu]

enums = {
    enum[colossus_statu] = {
        charging
        firing
    }
}

### Checks if the country has surveyed any planet of a specific class
## scopes = { country }
alias[trigger:has_surveyed_class] = <planet_class>

### Checks if the country has a tech research option currently available
## scopes = { country }
alias[trigger:has_tech_option] = <technology>

### Checks if a country has the given tradition.
## scopes = { country }
alias[trigger:has_tradition] = <tradition>

### Checks if the country has a valid AI personality
## scopes = { country }
alias[trigger:has_valid_ai_personality] = bool

### Checks if a war goal is set. Only works in diplomatic phrases.
## scopes = any
alias[trigger:has_war_goal] = bool


### Checks if the pop_group, species or country's ideal planet class is a specific class
## scopes = { country pop_group species }
alias[trigger:ideal_planet_class] = <planet_class>

### Checks if the pop_group, species or country's ideal planet class is a specific class
## scopes = { country pop_group species }
alias[trigger:ideal_planet_class] = scope_group[target_planet]

### Checks the country's monthly energy credit income
## scopes = { country }
alias[trigger:income] == value_field

### Checks the country's intel level of target system
## scopes = { country }
alias[trigger:intel_level] = enum[intel_level]
### Checks the country's intel level of target system
## scopes = { country }
alias[trigger:intel_level] = {
    level = enum[intel_level]
    system = scope[system]
}

### Switch case for a trigger treated as NOT.
## scopes = any
alias[trigger:inverted_switch] = {
    trigger = alias_keys_field[trigger]
    ## cardinality = ~1..inf
    scalar = single_alias_right[trigger_clause]
    ## cardinality = ~1..1
    default = single_alias_right[trigger_clause]
}

### Checks if a country has an advisor
## scopes = { country }
alias[trigger:is_advisor_active] = bool

### Checks if the ship/fleet is being repaired
## scopes = { ship fleet }
alias[trigger:is_being_repaired] = bool

### Checks if the system is bottleneck within the range NDefines::NGameplay::SYSTEM_BOTTLENECK_RADIUS
## scopes = { galactic_object }
alias[trigger:is_bottleneck_system] = bool

### Checks if a system has the bridge flag or not.
## scopes = { galactic_object }
alias[trigger:is_bridge] = bool

### Checks if the scoped construction ship is building the specified thing
## scopes = { ship fleet }
alias[trigger:is_constructing] = megastructure
### Checks if the scoped construction ship is building the specified thing
## scopes = { ship fleet }
alias[trigger:is_constructing] = <megastructure>
### Checks if the scoped construction ship is building the specified thing
## scopes = { ship fleet }
alias[trigger:is_constructing] = <ship_size>
### Checks if the scoped construction ship is building the specified thing
## scopes = { ship fleet }
alias[trigger:is_constructing] = value[construction_type]


### Check if current game allows crises
## scopes = any
alias[trigger:is_crises_allowed] = bool

### Checks if the spatial object is its owner's custom capital location
## scopes = { planet ship fleet galactic_object }
alias[trigger:is_custom_capital_location] = bool

### Checks if the ship is damaged
## scopes = { ship }
alias[trigger:is_damaged] = bool

### Checks if the ship/fleet is disabled
## scopes = { ship fleet }
alias[trigger:is_disabled] = bool

### Checks if a leader is a special event leader (defined in create_leader)
## scopes = { leader }
alias[trigger:is_event_leader] = bool

### Checks if the country is the leader of their federation
## scopes = { country }
alias[trigger:is_federation_leader] = bool

### Checks if the ship/fleet is idle
## scopes = { ship fleet }
alias[trigger:is_fleet_idle] = bool

### Checks if the planet/system belongs to a specific spawning cluster
## scopes = { planet galactic_object }
alias[trigger:is_in_cluster] = value[cluster_id]

### Checks if the planet/ship/fleet/system is inside the borders of the target country
## scopes = { planet ship fleet galactic_object }
alias[trigger:is_inside_border] = scope_group[target_country]

### Check if current game is running in ironman mode
## scopes = any
alias[trigger:is_ironman] = bool

### Checks if the specified species is the majority species on the current planet.
## scopes = { planet }
alias[trigger:is_majority_species] = scope_group[target_species]

### Checks if the country is the overlord of any subject countries
## scopes = { country }
alias[trigger:is_overlord] = bool

### Checks if the country has an overlord attitude towards target country
## scopes = { country }
alias[trigger:is_overlord_to] = scope_group[target_country]

### Checks if the planet/country/ship/system/ambient object has a specific point of interest for a specific event chain for a specific country
## scopes = { planet country ship galactic_object ambient_object }
alias[trigger:is_point_of_interest] = {
    id = value[point_of_interest]
    event_chain = <event_chain>
    owner = scope_group[target_country]
}

### Checks if the country's AI prefers weapons using this component tag
## scopes = { country }
alias[trigger:is_preferred_weapons] = enum[component_tag]

### Checks if the planet is the system's primary star
## scopes = { planet }
alias[trigger:is_primary_star] = bool

### Checks if the country is currently researching a specific technology
## scopes = { country }
alias[trigger:is_researching_technology] = <technology>

### Checks if the system is on the galactic rim
## scopes = { galactic_object }
alias[trigger:is_rim_system] = bool

### Checks if the pop_group/country is of the same species class as another pop_group/country
## scopes = { country ship pop_group leader army species }
alias[trigger:is_same_species_class] = scope_group[target_species]

### Checks if the scope is set for appropriate target
## scopes = { planet country ship pop_group fleet }
alias[trigger:is_scope_set] = scope[any]

### Checks if the current scope is valid
## scopes = any
alias[trigger:is_scope_valid] = bool

### Checks if the pop_group/country's founder species is of a specific pre-defined species
## scopes = { country pop_group leader species }
alias[trigger:is_species] = scalar #TODO species

### Checks if the planet/system has been survey by target country
## scopes = { planet galactic_object astral_rift }
alias[trigger:is_surveyed] = {
    who = scope_group[target_country]
    status = bool
}

### Checks if the planet has ever been terraformed
## scopes = { planet }
alias[trigger:is_terraformed] = bool

### Checks if the planet is currently being terraformed
## scopes = { planet }
alias[trigger:is_terraforming] = bool

### Checks the country's tutorial level (0 off, 1 limited, 2 full)
## scopes = { country }
alias[trigger:is_tutorial_level] == int_value_field

### Checks to see if target scope is valid for the country/planet/army
## scopes = { planet country army }
alias[trigger:is_valid] = scope[any]

### Checks if the country has a specific graphical culture for its city image or the same graphical culture as the target. If the target is a country, this trigger will compare its city graphical culture to the scoped country city graphical culture
## scopes = { country }
alias[trigger:city_graphical_culture] = <graphical_culture>

### Checks if the last policy changed by the country was a specific policy
## scopes = { country }
alias[trigger:last_changed_policy] = <policy>

### Check if the last species rights type changed for the pop_group or leader is of type type
## scopes = { pop_group leader }
alias[trigger:last_changed_species_rights_type] = enum[species_rights_type]


### Checks if the country's last researched technology was a specific tech
## scopes = { country }
alias[trigger:last_increased_tech] = <technology>


### Prints a message to game.log for debugging purposes
## scopes = any
alias[trigger:log] = scalar

### Checks if the local human is logged in to a Pdx account. This WILL cause an out of sync if used for anything that can change the game state
## scopes = any
alias[trigger:logged_in_to_pdx_account] = bool

### Checks the country's max naval capacity in absolute numbers
## scopes = { country }
alias[trigger:max_naval_capacity] == int_value_field

### Checks the country's max starbase capacity
## scopes = { country }
alias[trigger:max_starbase_capacity] == int_value_field


### Checks if the observation post has achieved specific progress in a mission
## scopes = { fleet }
alias[trigger:mission_progress] == value_field[0.0..1.0]

### Checks the country's or planet's number of armies
## scopes = { planet country }
alias[trigger:num_armies] == int_value_field

### Checks the planet's total amount of energy
## scopes = { planet }
alias[trigger:num_energy] == int_value_field

### Checks the planet's total amount of engineering research
## scopes = { planet }
alias[trigger:num_engineering] == int_value_field

### Checks the country's number of fleets
## scopes = { country }
alias[trigger:num_fleets] == int_value_field

### Checks how many of target country's ships that the country has destroyed
## scopes = { country }
alias[trigger:num_killed_ships] = {
    target = scope_group[target_country]
    value = int_value_field
}

### Checks the number of marauder empires specified by the galaxy setup
## scopes = any
alias[trigger:num_marauder_empires_to_spawn] == int_value_field

### Checks the planet's total amount of minerals
## scopes = { planet }
alias[trigger:num_minerals] == value_field

### Checks the planet's number of modifiers
## scopes = { planet }
alias[trigger:num_modifiers] == int_value_field

### Checks the planet's total amount of physics research
## scopes = { planet }
alias[trigger:num_physics] == int_value_field

### Checks the country's number of researched rare technologies
## scopes = { country }
alias[trigger:num_rare_techs] == int_value_field

### Checks the country's number of researched dangerous technologies
## scopes = { country }
alias[trigger:num_dangerous_techs] == int_value_field

### Checks the country's number of researched insight technologies
## scopes = { country }
alias[trigger:num_insight_techs] == int_value_field

### Checks the country's number of researched custom_1 technologies
## scopes = { country }
alias[trigger:num_custom_1_techs] == int_value_field

### Checks the country's number of researched custom_2 technologies
## scopes = { country }
alias[trigger:num_custom_2_techs] == int_value_field

### Checks the country's number of researched custom_3 technologies
## scopes = { country }
alias[trigger:num_custom_3_techs] == int_value_field

### Checks the country's number of researched repeatable technologies
## scopes = { country }
alias[trigger:num_repeatable_techs] == int_value_field

### Checks the country's number of researched technologies
## scopes = { country }
alias[trigger:num_researched_techs] == int_value_field

### Checks the country's number of researched technologies of a certain tier
## scopes = { country }
alias[trigger:num_researched_techs_of_tier] = {
    value = int_value_field
    tier = int
}

### Checks whether the country can research a certain tech tier
## scopes = { country }
alias[trigger:can_research_tier] = {
    area = enum[technology_area]
    tier = int
}

### Checks the country/fleet's number of ships
## scopes = { country ship fleet }
alias[trigger:num_ships] == int_value_field

### Checks the planet's total amount of society research
## scopes = { planet }
alias[trigger:num_society] == int_value_field

### Checks if the number of species on a planet, in an empire or in a pop_group faction is according to the argument. Does not count genetically modified species as unique.
## scopes = { planet country pop_faction }
alias[trigger:num_species] == int_value_field

### Counts the number of starbases owned by the scoped country
## scopes = { country }
alias[trigger:num_starbases] == int_value_field

### Checks how many planets the country has taken from target country
## scopes = { country }
alias[trigger:num_taken_planets] = {
    target = scope_group[target_country]
    value = int_value_field
}

### Checks the country/pop_group/leader/species' number of traits
## scopes = { country pop_group leader species }
alias[trigger:num_traits] == int_value_field

### Checks if the number of species on a planet, in an empire or in a pop_group faction is according to the argument. Counts genetically modified species as unique.
## scopes = { planet country pop_faction }
alias[trigger:num_unique_species] == int_value_field

### Checks how far removed the country/pop_group's ethos is from target's
## scopes = { country pop_group }
alias[trigger:opposing_ethics_divergence] = {
    steps = int_value_field
    who = scope_group[target_country]
    who = scope[pop_group]
}


### Checks if the scoped country controls any system containing a bypass of a specific type
## scopes = { country }
alias[trigger:owns_any_bypass] = <bypass>

### Checks if the pop_group or species is allowed to live on a specified planet
## scopes = { pop_group species }
alias[trigger:can_live_on_planet] = scope_group[target_planet]

# ### Checks if a pop_group, or the pops of a particular species can reproduce
#alias[trigger:pop_can_reproduce] = bool

### Checks the maintenance costs of a pop_group
## scopes = { pop_group }
alias[trigger:pop_maintenance_cost] = {
    resource = <resource>
    value = value_field
}

### Checks the country's running energy credit balance
## scopes = { country }
alias[trigger:running_balance] == value_field

### Checks if the species (or pop_group/empire's dominant species) uses a certain portrait
## scopes = { country pop_group species }
alias[trigger:species_portrait] = <portrait>
### Checks if the species (or pop_group/empire's dominant species) uses a certain portrait
## scopes = { country pop_group species }
alias[trigger:species_portrait] = <portrait_group>

### Checks the country's amount of stored engineering research
### stored_engineering_points
## scopes = { country }
alias[trigger:stored_engineering_points] == int_value_field

### Checks the country's amount of stored physics research
### stored_physics_points
## scopes = { country }
alias[trigger:stored_physics_points] == int_value_field

### Checks the country's amount of stored society research
### stored_society_points
## scopes = { country }
alias[trigger:stored_society_points] == int_value_field

### Checks if the current country is allowed by its overlord to take diplomatic action
## scopes = { country }
alias[trigger:subject_can_diplomacy] = scope_group[target_country]

### Switch case for a trigger
## scopes = any
alias[trigger:switch] = {
    trigger = alias_keys_field[trigger]
    ## cardinality = ~1..inf
    scalar = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    default = single_alias_right[trigger_clause]
}

### Checks if planet is terraformed by country.
## scopes = { planet }
alias[trigger:terraformed_by] = scope_group[target_country]

### For 'desc={trigger={' use. Shows custom text
## scopes = any
alias[trigger:text] = localisation

### Checks target country's opinion value of the current country
## scopes = { country }
alias[trigger:their_opinion] = {
    who = scope_group[target_country]
    value = int_value_field
}

### Checks the country's trust of the target country
## scopes = { country }
alias[trigger:trust] = {
    who = scope_group[target_country]
    value = int_value_field
}

### Checks how many days an upgrading megastructure will take to complete its upgrade.
## scopes = { megastructure }
alias[trigger:upgrade_days_left] == int_value_field

### Checks the country's used naval capacity in absolute numbers
## scopes = { country }
alias[trigger:used_naval_capacity_integer] == int_value_field

### Checks if a war has a specific war goal
## scopes = { war }
alias[trigger:using_war_goal] = {
    type = <war_goal>
    owner = scope_group[target_country]
}

### Checks if a war is a total war
## scopes = { war }
alias[trigger:is_total_war] = bool

### Checks if the scoped fleet can target the given planet with its planet killer weapon
## scopes = { fleet }
alias[trigger:valid_planet_killer_target] = scope_group[target_planet]

### Checks amount of target country's fleets that went MIA when the war began
## scopes = { war }
alias[trigger:war_begun_num_fleets_gone_mia] = {
    who = scope_group[target_country]
    value = int_value_field
}

### Checks if the country would join the side of target country in a hypothetical war
## scopes = { country }
alias[trigger:would_join_war] = {
    attacker = scope_group[target_country]
    defender = scope_group[target_country]
    side = scope_group[target_country]
}

### Checks if the country is currently researching a specific special project
## scopes = { country leader }
alias[trigger:is_researching_special_project] = <special_project>

### Checks the number of starbase modules that are of the specified type or not
## scopes = { country galactic_object starbase }
alias[trigger:count_starbase_modules] =  {
    count = int_value_field
    ## cardinality = 0..1
    type = <starbase_module>
    ## cardinality = 0..1
    include_being_constructed = bool
}
### Checks the number of starbase buildings that are of the specified type or not
## scopes = { country galactic_object starbase }
alias[trigger:count_starbase_buildings] =  {
    count = int_value_field
    ## cardinality = 0..1
    type = <starbase_building>
    ## cardinality = 0..1
    include_being_constructed = bool
}

### Checks if the scoped country has a specified quantity of a starbase size
## scopes = { country }
alias[trigger:count_starbase_sizes] =  {
    count = int_value_field
    starbase_size = <ship_size.starbase>
}

# 2.2

### Checks the scoped faction's approval percentage
## scopes = { pop_faction }
alias[trigger:faction_approval] == value_field[0.0..1.0]

### Check if scoped species is half species of specific/any species
## scopes = { species }
alias[trigger:is_half_species] = any

### Checks if the last building queued/unqueued/built/demolished/upgraded was the specified building
## scopes = { planet }
alias[trigger:last_building_changed] = <building>

### Checks the empire's size. Identical to empire_sprawl trigger.
## scopes = { country }
alias[trigger:empire_size] == int_value_field

### Checks the empire's sprawl. Identical to empire_size trigger.
## scopes = { country }
alias[trigger:empire_sprawl] == int_value_field

### Checks if the last district queued/unqueued/built/demolished/upgraded was the specified district
## scopes = { planet }
alias[trigger:last_district_changed] = <district>

### Checks the planet's available housing
## scopes = { planet }
alias[trigger:free_housing] == int_value_field

### Checks the number of in-game days passed since the 2200.1.1 start
## scopes = any
alias[trigger:days_passed] == int_value_field

### Checks the planet's available amenities
## scopes = { planet }
alias[trigger:free_amenities] == int_value_field

### Checks if the country has a deficit of the defined resource
## scopes = { planet country }
alias[trigger:has_deficit] = <resource>

### Check if the country has a commercial pact with target country
## scopes = { country }
alias[trigger:has_commercial_pact] = scope_group[target_country]

### Checks specific resource stockpile for the country scope:
## scopes = { country }
alias[trigger:resource_stockpile_compare] = {
    resource = <resource>
    value = value_field
    ## cardinality = 0..1
    mult = value_field
    ## cardinality = 0..1
    multiplier = value_field
}

### Checks specific resource income value for the country scope (note: checks profit minus loss, not revenue):
## scopes = { country }
alias[trigger:resource_income_compare] = {
    resource = <resource>
    value = value_field
}

### Checks specific resource expenses value for the country scope:
## scopes = { country }
alias[trigger:resource_expenses_compare] = {
    resource = <resource>
    ### Optional; if not provided, will use sum for all Categories
    ## cardinality = 0..1
    category = <economic_category>
    value = value_field
}

### Checks specific resource revenue value for the country scope:
## scopes = { country }
alias[trigger:resource_revenue_compare] = {
    ### Optional; if not provided, will use sum for all Categories
    ## cardinality = 0..1
    category = <economic_category>
    resource = <resource>
    value = value_field
}

### Checks if the pop_group is being purged
## scopes = { pop_group }
alias[trigger:is_being_assimilated] = bool

### Checks the number of guaranteed colonies defined in setup
## scopes = any
alias[trigger:num_guaranteed_colonies] == int_value_field

### Check if the planet has a branch office owned by target country/any country/no country
## scopes = { planet }
alias[trigger:has_branch_office] = scope_group[target_country]
### Check if the planet has a branch office owned by target country/any country/no country
## scopes = { planet }
alias[trigger:has_branch_office] = bool

### Checks if the country is a criminal syndicate
## scopes = { country }
alias[trigger:is_criminal_syndicate] = bool

### Checks if scoped deposit is a blocker-type
## scopes = { deposit }
alias[trigger:is_blocker] = bool

### Checks the planet's number of branch office slots available for new constructions
## scopes = { planet }
alias[trigger:free_branch_office_building_slots] == int_value_field

### Checks the planet's branch officevalue
## scopes = { planet }
alias[trigger:branch_office_value] = {
    who = scope_group[target_country]
    value = value_field
}

### Checks the number of unassigned jobs on the planet
## scopes = { planet }
alias[trigger:free_jobs] == int_value_field

### Checks the planet's devastation
## scopes = { planet }
alias[trigger:planet_devastation] == value_field[0.0..100.0]

### Checks if the pop_group has the chosen pop_group category
## scopes = { pop_group }
alias[trigger:is_pop_category] = <pop_category>

### Checks if scoped country won the game
## scopes = { country }
alias[trigger:won_the_game] = bool

### Checks the country's percentage of communications with playable empires
## scopes = { country }
alias[trigger:perc_communications_with_playable] == value_field[0.0..1.0]

### Compares the crime present on the planet with the given value
## scopes = { planet }
alias[trigger:planet_crime] == value_field[0.0..100.0]

### Checks if the job has a specific type set.
## scopes = { pop_job }
alias[trigger:has_job_type] = <job>

### Checks if deposit is specified type
## scopes = { deposit }
alias[trigger:is_deposit_type] = <deposit>

### Checks if country has a built species defined
## scopes = { country }
alias[trigger:has_built_species] = bool

### Checks the number the planet has of any, or a specific, building
## scopes = { planet country }
alias[trigger:num_buildings] = {
    type = any
    type = <building>
    value = int_value_field
    ## cardinality = 0..1
    disabled = any
    ## cardinality = 0..1
    disabled = bool
    ## cardinality = 0..1
    in_construction = any
    ## cardinality = 0..1
    in_construction = bool
    ## cardinality = 0..1
    owner_type = normal
    ## cardinality = 0..1
    owner_type = corporate
    ## cardinality = 0..1
    owner_type = subject_holding
}

### Checks the number the planet has of any, or a specific, district
## scopes = { planet country }
alias[trigger:num_districts] = {
    type = any
    type = <district>
    value = int_value_field
}

### Checks the number of available slots the planet has of any, or a specific, district
### Only works for uncapped districts as of 2.2.4
## scopes = { planet }
alias[trigger:num_free_districts] = {
    type = any
    type = <district>
    value = int_value_field
}

### Checks if the pop_group can work a job
## scopes = { pop_group }
alias[trigger:can_work_job] = bool

### Checks if a pop_group's planet has a specific percentage (0.00-1.00) of the same species enslaved
## scopes = { pop_group }
alias[trigger:species_planet_slave_percentage] == value_field[0.0..1.0]

### Checks the country's or sector's number of owned systems
## scopes = { country sector }
alias[trigger:controlled_systems] == int_value_field

### Checks the country has planets that are unexploited (i.e. orbital stations can be built on them)
## scopes = { country }
alias[trigger:exploitable_planets] == int_value_field

### Returns the number of planets within the current country's borders that are habitable but have not been colonized
## scopes = { country }
alias[trigger:controlled_colonizable] == int_value_field

### Checks how many plans the AI have for colonization (lighter than controlled_colonizable for AI)
## scopes = { country }
alias[trigger:ai_colonize_plans] == int_value_field

### Checks how many plans the AI have for terraforming
## scopes = { country }
alias[trigger:ai_terraform_plans] == int_value_field

### Checks the country's number of scientists
## scopes = { country }
alias[trigger:scientist_count] == int_value_field

### Checks the countrys' number of scientists
## scopes = { country }
alias[trigger:scientist_count] = bool

### Checks if resource is enabled on the Galactic Market
## scopes = any
alias[trigger:is_on_market] = <resource>

### Checks if the current country can buy the specified resource on the market or galactic market
## scopes = { country }
alias[trigger:can_buy_on_market] = <resource>

### Checks the country's highest threat against it
## scopes = { country }
alias[trigger:highest_threat] == value_field

### Checks if the target country is the country's rival
## scopes = { country }
alias[trigger:has_rival] = scope_group[target_country]

### Checks if the target country is the country's overlord
## scopes = { country }
alias[trigger:has_overlord] = scope_group[target_country]

### Checks if the target country is a subject of the current country.
## scopes = { country }
alias[trigger:has_subject] = scope_group[target_country]

### Counts the number of sectors owned by the scoped country
## scopes = { country }
alias[trigger:num_sectors] == int_value_field

### Checks the planet's number of slots available for new constructions
## scopes = { planet }
alias[trigger:free_district_slots] == int_value_field

### Checks if the country AI has any plans to expand
## scopes = { country }
alias[trigger:has_ai_expansion_plan] = bool

### Checks if the planet has any, or a specific, district
## scopes = { planet }
alias[trigger:has_district] = <district>
### Checks if the planet has any, or a specific, district
## scopes = { planet }
alias[trigger:has_district] = bool

### Checks if country has active events:
## scopes = { country }
alias[trigger:has_active_event] = {
    ## cardinality = 0..inf
    <event>
}

### Checks the planet's number of slots available for new constructions
## scopes = { planet }
alias[trigger:free_building_slots] == int_value_field

### Checks if species has specified archetype:
## scopes = { species }
alias[trigger:is_archetype] = <species_archetype>

# 2.3

### Checks if the country has any potential claims they can make.
## scopes = { country }
alias[trigger:has_potential_claims] = bool

### Checks if the scoped country has the specified relic
## scopes = { country }
alias[trigger:has_relic] = <relic>

### Checks if the specified relic was the last activated one
## scopes = { country }
alias[trigger:last_activated_relic] = <relic>

### Checks if the specified relic was the last activated one
## scopes = { country }
alias[trigger:last_activated_relic] = <relic>

### Compares the last dice roll.
## scopes = { archaeological_site first_contact astral_rift }
alias[trigger:is_site_last_die_result] == int_value_field

### Compares the current stage difficulty.
## scopes = { archaeological_site first_contact astral_rift }
alias[trigger:is_current_stage_difficulty] == int_value_field

### Compares the current stage index.
## scopes = { archaeological_site }
alias[trigger:is_site_at_stage] == int_value_field

### Compares the current stage clues.
## scopes = { archaeological_site first_contact }
alias[trigger:is_current_stage_clues] == int_value_field

### Compares days to next die roll.
## scopes = { archaeological_site first_contact }
alias[trigger:is_site_days_to_next_die_roll] == int_value_field

### Checks last excavating country.
## scopes = { archaeological_site }
alias[trigger:is_site_last_excavator] = scope_group[target_country]

### Checks the type of the site.
## scopes = { archaeological_site }
alias[trigger:is_site_type] = <archaeological_site_type>

### Checks if the site has been completed.
## scopes = { archaeological_site first_contact }
alias[trigger:is_site_completed] = bool

### Checks if the site is currently being excavated.
### is_site_under_excavation_ = yes/no
## scopes = { archaeological_site }
alias[trigger:is_site_under_excavation] = bool

### Compares the current stage discovery score.
## scopes = { archaeological_site first_contact astral_rift }
alias[trigger:is_site_current_stage_score] == int_value_field
### Compares the current stage discovery score.
## scopes = { archaeological_site first_contact astral_rift }
alias[trigger:is_site_current_stage_score] = lower_insight_score
### Compares the current stage discovery score.
## scopes = { archaeological_site first_contact astral_rift }
alias[trigger:is_site_current_stage_score] = higher_insight_score

### Compares the current stage discovery score excluding the current die roll.
## scopes = { archaeological_site first_contact astral_rift }
alias[trigger:is_site_current_stage_score_no_die] == int_value_field

### Checks last excavating country.
## scopes = { archaeological_site }
alias[trigger:is_site_last_excavator] = scope[fleet]

### Checks the planet's total amount of uncleared blockers
## scopes = { planet }
alias[trigger:num_uncleared_blockers] == int_value_field

### Checks if the country has unlocked all traditions
## scopes = { country }
alias[trigger:has_unlocked_all_traditions] = bool

### Checks currently in the specified scope:
## scopes = any
alias[trigger:is_scope_type] = enum[scope_type_token]

# 2.5.1 (or missing from earlier)

### Checks if Caravaneers are enabled in game setup
## scopes = any
alias[trigger:caravaneers_enabled] = bool

### Checks if the colony is of a certain type
## scopes = { planet }
alias[trigger:colony_type] = <colony_type>
### Checks if the colony is of a certain type
## scopes = { planet }
alias[trigger:colony_type] = scope_group[target_planet]

### Checks if a deposit has specified category
## scopes = { deposit }
alias[trigger:has_deposit_category] = <deposit_category>

### Checks if the sector has a specific type
## scopes = { sector }
alias[trigger:has_sector_type] = <sector_type>

### Checks current excavator fleet.
## scopes = { archaeological_site }
alias[trigger:is_current_excavator_fleet] = scope[fleet]

### Checks if the planet/ship/fleet/system is in frontier space
## scopes = { planet ship fleet galactic_object }
alias[trigger:is_in_frontier_space] = bool

### Checks whether the relic passed in parameter is the last relic lost by the country int the current scope.
## scopes = { country }
alias[trigger:is_last_lost_relic] = <relic>

### Checks whether the relic passed in parameter is the last relic received by the country int the current scope.
## scopes = { country }
alias[trigger:is_last_received_relic] = <relic>

### Checks the number of relics owned by the scoped country
## scopes = { country }
alias[trigger:num_owned_relics] == int_value_field

# 2.6.3

### Checks if the federation has a specific flag
## scopes = { federation }
alias[trigger:has_federation_flag] = value[federation_flag]

### Checks the country's number of envoys sent to its federation
## scopes = { country }
alias[trigger:num_envoys_to_federation] == int_value_field

### Checks the country's number of envoys sent to the galactic community
## scopes = { country }
alias[trigger:num_envoys_to_galcom] == int_value_field

### Checks experience of the federation.
## scopes = { federation }
alias[trigger:federation_experience] == value_field

### Checks cohesion of the federation.
## scopes = { federation }
alias[trigger:federation_cohesion] == value_field

### Checks cohesion growth of the federation.
## scopes = { federation }
alias[trigger:federation_cohesion_growth] == value_field

### Checks if given law has been enacted in scoped federation
## scopes = { federation }
alias[trigger:has_federation_law] = <federation_law>

### Checks if scoped country is part of the Galactic Community
## scopes = { country }
alias[trigger:is_galactic_community_member] = bool

### CChecks how much the empire's sprawl is over its admin capacity
## scopes = { country }
alias[trigger:empire_sprawl_over_cap] == int_value_field

### Checks the empire's sprawl compared to its admin level
## scopes = { country }
alias[trigger:empire_sprawl_cap_fraction] == value_field

### Checks if scoped country is part of the Galactic Council
## scopes = { country }
alias[trigger:is_part_of_galactic_council] = bool

### Checks if given perk has been unlocked in scoped federation
## scopes = { federation }
alias[trigger:has_federation_perk] = <federation_perk>

### Checks if federation has specific federation type
## scopes = { federation }
alias[trigger:has_federation_type] = <federation_type>

### Checks federation level in comparison to given value in scoped federation
## scopes = { federation }
alias[trigger:federation_level] == int_value_field

### Checks if the Galactic Community is currently voting on any, or a specific, resolution
## scopes = any
alias[trigger:is_voting_on_resolution] = any

### Checks if the Galactic Community is currently voting on any, or a specific, resolution
## scopes = any
alias[trigger:is_voting_on_resolution] = <resolution>

### Checks if the scoped country is currently proposing any, or a specific, resolution
## scopes = { country }
alias[trigger:is_proposing_resolution] = any

### Checks if the scoped country is currently proposing any, or a specific, resolution
## scopes = { country }
alias[trigger:is_proposing_resolution] = <resolution>

### Compare with number of years since the formation of the Galactic Community. NOTE: A negative value means it hasn't been formed yet!
### is_years_since_community_formationn >= <int32>
## scopes = any
alias[trigger:is_years_since_community_formation] == int_value_field

### Compares with number of years since the establishment of the Galactic Council. NOTE: A negative value means it hasn't been established yet!
## scopes = any
alias[trigger:is_years_since_council_establishment] == int_value_field

### Checks if the Galactic Community has been formed
## scopes = any
alias[trigger:is_galactic_community_formed] = bool

### Checks if the Galactic Council has been established
## scopes = any
alias[trigger:is_galactic_council_established] = bool

### Checks if scoped country has specified origin
## scopes = { country dlc_recommendation }
alias[trigger:has_origin] = <civic_or_origin.origin>

### Checks if the provided Resolution is active in the Community
## scopes = any
alias[trigger:is_active_resolution] = <resolution>

### Checks if an empire is in breach of any galactic resolution.
## scopes = { country }
alias[trigger:is_in_breach_of_any] = bool

### Checks if the scoped country is in breach of the specified resolution (or would be, were it to be enacted)
## scopes = { country }
alias[trigger:in_breach_of] = <resolution>

### Checks if given setting is on for scoped federation
## scopes = { federation }
alias[trigger:has_federation_setting] = enum[federation_setting]

### Compares the number of council positions in the Galactic Community.
## scopes = any
alias[trigger:num_council_positions] == int_value_field

### Compares empire rank ( sorted by diplomatic weight ) in the Galactic Community. NOTE: If the scoped country isn't part of the community this returns -1.
## scopes = { country }
alias[trigger:galactic_community_rank] == int_value_field[-1..inf]

### Checks if an empire has a permanent seat on the Galactic Council
## scopes = { country }
alias[trigger:is_permanent_councillor] = bool

### Checks the country's opinion of the target country has been changed by envoys
## scopes = { country }
alias[trigger:envoy_opinion_change] = {
    who = scope_group[target_country]
    value = value_field
}

### Checks if the country has an envoy sent to the target country to improve relations
## scopes = { country }
alias[trigger:is_improving_relations_with] = scope_group[target_country]

### Checks if the country has an envoy sent to the target country to harm relations
## scopes = { country }
alias[trigger:is_harming_relations_with] = scope_group[target_country]

### Checks the country's opinion level of the target country (with support for comparison operators)
## scopes = { country }
alias[trigger:opinion_level] = {
    who = scope_group[target_country]
    level = enum[opinion_level]
}

### Check if the species in the scope is a robot species or not
### is_robotic=<yes/no>
## scopes = { species }
alias[trigger:is_robotic] = bool

### Check amount of favors that scoped country can collect from target country:
## scopes = { country }
alias[trigger:num_favors] = {
    target = scope_group[target_country]
    value = int_value_field
}

### Checks the number of ships of a ship size in debris
## scopes = { debris }
alias[trigger:num_ships_in_debris] = {
    ship_size = <ship_size>
    value == int_value_field
}

### Checks whether the galaxy size if of a certain type
### galaxy_size=medium
## scopes = any
alias[trigger:galaxy_size] = <map_setup_scenario>

### Checks the country's diplomatic weight
## scopes = { country }
alias[trigger:diplomacy_weight] == value_field

### Checks the number of fallen empires defined in setup
## scopes = any
alias[trigger:num_fallen_empires_setting] == int_value_field

# 2.7

### Checks the scoped envoy's task.
## scopes = { leader }
alias[trigger:has_envoy_task] = {
    ## cardinality = 0..1
    target = scope[country]
    task = enum[envoy_task]
}

### Checks the scoped envoy currently has a cooldown on its status.
## scopes = { leader }
alias[trigger:has_envoy_cooldown] = bool

### Checks if the scoped fleet is able to enter the system. Note: Avoid overusing this, it is a performance-intensive trigger!
## scopes = { fleet }
alias[trigger:can_access_system] = scope[system]

### Checks the scope leader's age
## scopes = { leader }
alias[trigger:leader_age] == int_value_field

### Checks if the country has completed a specific special project as part of an in-progress event chain
## scopes = { country }
alias[trigger:has_completed_special_project_in_log] = <special_project>

### Checks if the country has failed, timed out or aborted a specific special project as part of an in-progress event chain
## scopes = { country }
alias[trigger:has_failed_special_project_in_log] = <special_project>

### Checks the planet's total housing
## scopes = { planet }
alias[trigger:num_housing] == int_value_field

### Checks the solar system's total number of planets
## scopes = { galactic_object }
alias[trigger:num_planets_in_system] == int_value_field

### Checks if the planet is its sector's capital
## scopes = { planet }
alias[trigger:is_sector_capital] = bool

### Checks if the planet has the specified tag for district usage:
## scopes = { planet }
## severity = warning
alias[trigger:uses_district_set] = enum[district_set]

### Checks specific resource value for scoped planet. Warning: performance-intensive trigger!
## scopes = { planet }
alias[trigger:planet_resource_compare] = {
    ## cardinality = 0..1
    ### Default: Balance
    type = enum[planet_resource_compare_type]
    resource = <resource>
    value = value_field
}

### Checks if given law category has any active law
## scopes = { federation }
alias[trigger:has_any_federation_law_in_category] = <federation_law_category>

### Check that you have available job of a specific type
## scopes = { planet }
alias[trigger:has_available_jobs] = <job>

### Check that you have forbidden job of a specific type
## scopes = { planet }
alias[trigger:has_forbidden_jobs] = <job>

### Checks if the country has been set to be friendly towards target country via set_faction_hostility
## scopes = { country }
alias[trigger:is_forced_friendly] = scope_group[target_country]

### Checks if the country has been set to be neutral towards target country via set_faction_hostility
## scopes = { country }
alias[trigger:is_forced_neutral] = scope_group[target_country]

### Checks if the current pop_group has happiness or not.
## scopes = { pop_group }
alias[trigger:pop_has_happiness] = bool

### Checks if the current pop group has happiness or not.
## scopes = { pop_group }
alias[trigger:pop_group_has_happiness] = bool

### Checks if the size of the pop group is according to the argument.
## scopes = { pop_group }
alias[trigger:pop_group_size] = int_value_field

### Checks if any pops are being purged on the current planet.
## scopes = { planet }
alias[trigger:has_current_purge] = bool

### Checks if the current species has happiness or not when owned by a specified country.
## scopes = { species }
alias[trigger:species_has_happiness_with_owner] = scope_group[target_country]

# 2.8

### Checks the number of pops the planet or country has that work a specific job.
## scopes = { planet country }
alias[trigger:num_assigned_jobs] = {
    job = <job>
    job = unemployed
    value = int_value_field
}

### Checks if the ambient object is a specific type.
## scopes = { ambient_object }
alias[trigger:is_ambient_object_type] = <ambient_object>

### Checks the number of AI empires defined in setup
## scopes = any
alias[trigger:num_ai_empires_setting] == int_value_field

### Checks if a specific name list is used for the a species during empire creation
## scopes = { dlc_recommendation }
alias[trigger:name_list_category] = enum[name_list_category]

# 3.0

### Checks how many organic pops the planet expects to gain in a year on average (through growth and assembly) at the current rate.
## scopes = { planet }
alias[trigger:organic_pops_last_month_growth] == value_field

### Checks how many artificial pops the planet expects to assemble in a year on average at the current rate.
## scopes = { planet }
alias[trigger:artificial_pops_last_month_growth] == value_field

### Checks if the country is allowed to set its policy to a specific one using set_policy effect
## scopes = { country }
alias[trigger:can_set_policy] = {
    policy = <policy>
    option = enum[policy_option]
}

### Checks if the pop_group can work a specific job if a vacancy becomes available
## scopes = { pop_group }
alias[trigger:can_work_specific_job] = <job>

### Checks if the scoped fleet or ship is civilian (as set in ship sizes).
## scopes = { ship fleet }
alias[trigger:is_civilian] = bool

### Checks if a country has a specific Menace Perk unlocked.
## scopes = { country }
alias[trigger:has_menace_perk] = <menace_perk>

### Compares the infiltration level of the network
## scopes = { spy_network }
alias[trigger:has_spy_power] == value_field

### Compares the available infiltration level of the network
## scopes = { spy_network }
alias[trigger:has_available_spy_power] == value_field

### Checks if the scope is of a specific category
## scopes = { espionage_operation }
alias[trigger:has_espionage_category] = <espionage_category>

### Checks if the scope is currently running an espionage operation
## scopes = { country spy_network }
alias[trigger:is_running_espionage_operation] = bool

### Checks if scoped country has any spynetworks with a value > 0
## scopes = { country }
alias[trigger:has_spynetwork] = bool

### Checks if the scope hold an asset of specified type
## scopes = { spy_network espionage_operation }
alias[trigger:has_espionage_asset] = <espionage_asset>

### Checks if the scoped country has an active First Contact site with the target country
## scopes = { country }
alias[trigger:has_active_first_contact_with] = scope_group[target_country]

### Checks if the scoped country is allowed to have a First Contact site with the target country
## scopes = { country }
alias[trigger:can_have_first_contact_site_with] = scope_group[target_country]

### Checks if the planet is artificial (as set in planet_classes)
## scopes = { planet }
alias[trigger:is_artificial] = bool

### Checks if the solar system has its owner's capital
## scopes = { galactic_object }
alias[trigger:is_capital_system] = bool

### Checks if the espionage operation has a certain modifier specific for the current stage
## scopes = { espionage_operation astral_rift }
alias[trigger:has_stage_modifier] = <static_modifier>

### Checks if the Galactic Defense Force or Imperial Armada exists
## scopes = any
alias[trigger:galactic_defense_force_exists] = bool

### Checks a variable for the scope if a certain amount of arithmetic is done to it (note: the variable's value is not changed by this trigger)
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[trigger:check_variable_arithmetic] = {
    which = value_field
    ## cardinality = 0..inf
    enum[math] = value_field
    ### Specify >/< on the value or variable fields
    value = value_field
}

### Checks the value of a specified modifier in the current scope against a value.
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army species design pop_faction spy_network espionage_operation }
alias[trigger:check_modifier_value] = {
    modifier = alias_keys_field[modifier]
    value = value_field
}

### Checks which crisis is allowed to spawn in the current game
## scopes = any
alias[trigger:allowed_crisis_type] = enum[crisis_type]

### Checks if the first contact site has a specific flag
## scopes = { first_contact }
alias[trigger:has_first_contact_flag] = value[first_contact_flag]

### Checks if the scoped first contact is at the specified stage.
## scopes = { first_contact }
alias[trigger:is_current_first_contact_stage] = <first_contact_stage>

### Checks whether the current country is allowed to have the specified technology, i.e. does it fulfil the potential = { } field for that tech, and for any prereq techs that tech has.
## scopes = { country }
alias[trigger:can_research_technology] = <technology>

### Checks whether the target country has a technology the current country can steal via copy_random_tech_from effect
## scopes = { country }
alias[trigger:can_copy_random_tech_from] = {
    who = scope_group[target_country]
    ## cardinality = 0..1
    category = <technology_category>
    ## cardinality = 0..1
    area = enum[research_area]
}

### Checks the country's Intel on the target country
## scopes = { country }
alias[trigger:intel] = {
    who = scope_group[target_country]
    value = value_field
}

### Checks the country's intel level on a category for the target country
## scopes = { country }
alias[trigger:has_intel_level] = {
    who = scope_group[target_country]
    category = <intel_category>
    level = int_value_field
}

### Checks if the country has intel report of at least the specified level on a category for the target country
## scopes = { country }
alias[trigger:has_intel_report] = {
    who = scope_group[target_country]
    category = <intel_category>
    level = int_value_field
}

### Checks if the specified intel is available for the target country (stale intel will not return true)
## scopes = { country }
alias[trigger:has_intel] = {
    who = scope_group[target_country]
    intel = enum[intel_token]
}

### Checks if the specified intel is stale for the target country (available intel will not return true)
## scopes = { country }
alias[trigger:has_stale_intel] = {
    who = scope_group[target_country]
    intel = enum[intel_token]
}

### Checks the number of defensive pacts the current country has.
## scopes = { country }
alias[trigger:num_defensive_pacts] == int_value_field

### Checks the number of empires the current country is supporting the independence of.
## scopes = { country }
alias[trigger:num_support_independence] == int_value_field

### Checks the number of empires the current country is guaranteeing.
## scopes = { country }
alias[trigger:num_guarantees] == int_value_field

### Checks the number of non-aggression pacts the current country has.
## scopes = { country }
alias[trigger:num_non_aggression_pacts] == int_value_field

### Checks the number of commercial pacts the current country has.
## scopes = { country }
alias[trigger:num_commercial_pacts] == int_value_field

### Checks the number of research agreements a country has
## scopes = { country }
alias[trigger:num_research_agreements] == int_value_field

### Checks the number of migration pacts a country has
## scopes = { country }
alias[trigger:num_migration_pacts] == int_value_field

### Checks the number of rivalries a country has
## scopes = { country }
alias[trigger:num_rivals] == int_value_field

### Checks the number of countries the country has closed borders to
## scopes = { country }
alias[trigger:num_closed_borders] == int_value_field

### Checks the number of truces country has
## scopes = { country }
alias[trigger:num_truces] == int_value_field

### Checks if the espionage operation has a specific flag
## scopes = { espionage_operation }
alias[trigger:has_espionage_operation_flag] = value[espionage_operation_flag]

### Checks if the scope is of a specific type
## scopes = { espionage_operation }
alias[trigger:has_espionage_type] = <espionage_operation>

### Divides the encryption value of the scope object with the decryption value of the target and compares with value.
### Target is only used for country scope.
## scopes = { country spy_network espionage_operation }
alias[trigger:relative_encryption_decryption] = {
    ## cardinality = 0..1
    target = scope_group[target_country]
    value = value_field
}

### Compares days to next die roll.
## scopes = { espionage_operation }
alias[trigger:is_espionage_operation_days_to_next_die_roll] == int_value_field

### Compares the current espionage operation chapter index.
## scopes = { espionage_operation }
alias[trigger:is_espionage_operation_chapter] == int_value_field

### Compares the espionage operation difficulty.
## scopes = { espionage_operation }
alias[trigger:is_espionage_operation_difficulty] == int_value_field

### Compares the current espionage score excluding the current die roll.
## scopes = { espionage_operation }
alias[trigger:is_espionage_operation_score_no_die] == int_value_field

### Compares the current espionage score.
## scopes = { espionage_operation }
alias[trigger:is_espionage_operation_score] == int_value_field

### Compares the last dice roll.
## scopes = { espionage_operation }
alias[trigger:is_espionage_operation_last_die_result] == int_value_field

### Checks if scoped espionage operation accepts events automatically when they are ready
## scopes = { espionage_operation }
alias[trigger:is_espionage_operation_auto_accept_events] == bool

### Compares the number of assets associated with the scope object.
## scopes = { spy_network espionage_operation }
alias[trigger:num_espionage_assets] == int_value_field

### Checks if the ship/fleet/design has a specific owner type (country/federation/galactic_community/global_ship_design)
## scopes = { ship fleet design ship_growth_stage }
alias[trigger:has_ship_owner_type] = enum[ship_owner_type]

### Checks if a country has a specific Crisis Level unlocked.
## scopes = { country }
alias[trigger:has_crisis_level] = <crisis_level>

### Compares spy network value of the scoped object
## scopes = { spy_network }
alias[trigger:has_spynetwork_value] == value_field

### Compares spy network level of the scoped object
## scopes = { spy_network }
alias[trigger:is_spynetwork_level] == int_value_field

### Compares counter espionage of the scoped object
## scopes = { country }
alias[trigger:is_counter_espionage] == int_value_field

### Checks if an empire is Custodian of the Galactic Council
## scopes = { country }
alias[trigger:is_galactic_custodian] = bool

### Checks if the Galactic Community has named a Custodian
## scopes = any
alias[trigger:has_galactic_custodian] = bool

### Checks if an empire is the Galactic Emperor
## scopes = { country }
alias[trigger:is_galactic_emperor] = bool

### Checks if the Galactic Emperor has taken over
## scopes = any
alias[trigger:has_galactic_emperor] = bool

### Checks imperial authority.
## scopes = any
alias[trigger:imperial_authority] == value_field

### Checks if the Galactic Defense Force or Imperial Armada exists
## scopes = any
alias[trigger:galactic_defense_force_exists] = bool

### Checks if the espionage operation has a certain modifier specific for the current stage
### has_modifier = <modifier>
## scopes = { espionage_operation astral_rift }
alias[trigger:has_stage_modifier] = <static_modifier>

### Checks the number of unemployed pops on the planet
## scopes = { planet country }
alias[trigger:num_unemployed] == int_value_field

### Checks whether the current scope is closer to a specified object than it is to a second specified object within the same solar system.
## scopes = { megastructure planet ship pop_group fleet galactic_object leader ambient_object starbase deposit archaeological_site first_contact }
alias[trigger:compare_distance] = {
    closer_object = scope_group[celestial_coordinate]
    further_object = scope_group[celestial_coordinate]
}

### Checks market price of a specific resource for the current country:
## scopes = { country }
alias[trigger:market_resource_price] = {
    resource = <resource_name>
    ## cardinality = 0..1
    ### Default = 1; basically a mult factor
    amount = int #no variables here
    ## cardinality = 0..1
    ### market_buy/market_sell/not_set (i.e. price without market fees)
    trade_type = enum[trade_type]
    value = value_field
}

### Checks number of members in scoped federation
## scopes = { federation }
alias[trigger:num_members] == int_value_field

### Checks number of associates in scoped federation
## scopes = { federation }
alias[trigger:num_associates] == int_value_field

### Checks if the army is defensive
## scopes = { army }
alias[trigger:is_defensive_army] = bool

### Checks if the job has a specific category set.
## scopes = { pop_job }
alias[trigger:has_job_category] = <pop_category>

### Checks the value for a specific option from the galaxy setup
## scopes = any
alias[trigger:check_galaxy_setup_value] = {
    setting = enum[galaxy_setup_value]
    value = value_field
}

### Checks if the scoped fleet can move.
## scopes = { fleet }
alias[trigger:is_mobile] = bool

# 3.1

### Checks if the starbase is currently building a specific module
## scopes = { starbase }
alias[trigger:is_starbase_building_module] = <starbase_module>

### Checks if the starbase is currently building a specific building
## scopes = { starbase }
alias[trigger:is_starbase_building_building] = <starbase_building>

### Check if the first buildable is in the starbase building queue before the second buildable (for prerequisites, mostly)
### Returns false if the first one, or both aren't in the queue. Returns true if the first one is in, but the second isn't.
## scopes = { starbase }
alias[trigger:starbase_buildable_is_in_queue_before] = {
    first = <starbase_module>
    first = <starbase_building>
    second = <starbase_module>
    second = <starbase_building>
}

### Checks if the planet's climate is set to a specified string in planet_classes:
## scopes = { planet }
alias[trigger:has_climate] = localisation

### Check if the country has an embassy with the target country
## scopes = { country }
alias[trigger:has_embassy] = scope_group[target_country]

# 3.2

### Checks if the planet is ideal (as set in planet_classes)
## scopes = { planet }
alias[trigger:is_ideal] = bool

### Checks if the specified ship, fleet, planet or system can be seen by the scoped country.
## scopes = { country }
alias[trigger:is_in_sensor_range] = scope[ship]

### Checks if the specified ship, fleet, planet or system can be seen by the scoped country.
## scopes = { country }
alias[trigger:is_in_sensor_range] = scope[fleet]

### Checks if the specified ship, fleet, planet or system is within sensor range of the scoped country.
## scopes = { country }
alias[trigger:is_in_sensor_range] = scope[planet]

### Checks if the specified ship, fleet, planet or system is within sensor range of the scoped country.
## scopes = { country }
alias[trigger:is_in_sensor_range] = scope[galactic_object]

### Checks if the scoped ship, fleet, planet or system can be seen by the specified country.
## scopes = { planet ship fleet galactic_object }
alias[trigger:is_in_sensor_range_of_country] = scope_group[target_country]

# 3.3

### Checks if the scoped situation's progress is a certain value.
## scopes = { situation }
alias[trigger:situation_progress] == value_field

### Checks if the scoped situation's monthly progress is a certain value. Returns the cached value from the last monthly tick.
## scopes = { situation }
alias[trigger:situation_monthly_progress] == value_field

### Checks if the specified approach has been picked on the scoped situation.
## scopes = { situation }
alias[trigger:current_situation_approach] = enum[situation_approach]

### Checks if the specified approach is allowed to be picked (according to potential and allow triggers) on the scoped situation.
## scopes = { situation }
alias[trigger:can_set_situation_approach] = enum[situation_approach]

# ### Checks if the specified severity level is currently active in the scoped situation.
### Checks if the specified stage is currently active in the scoped situation.
## scopes = { situation }
alias[trigger:current_stage] = enum[situation_stage]

### Checks if the scoped situation is a certain type.
## scopes = { situation }
alias[trigger:is_situation_type] = <situation_type>

### Checks the country's number of owned (recruited) non-envoy leaders (includes the ruler)
## scopes = { country }
alias[trigger:num_owned_leaders] == int_value_field

### Checks if scoped starbase would evaluate to be a certain starbase_type for its current owner.
## scopes = { starbase }
alias[trigger:is_starbase_type] = <starbase_type>

### Checks if the planet's ascension tier is as specified:
## scopes = { planet }
alias[trigger:has_planetary_ascension_tier] == int_value_field

### Checks number of star systems in the galaxy
## scopes = any
alias[trigger:num_galaxy_systems] == int_value_field

# 3.4

### Checks the planet's army strength (as calculated by all armies including offensive or defensive owned by its current controller). Warning: moderately intensive trigger:
## scopes = { planet }
alias[trigger:planet_garrison_strength] == value_field

### Checks ratio between the country's income and expenditures for a specific resource. E.g. if it makes 80 energy and spends 100, its ratio is 0.8.
## scopes = { country }
alias[trigger:resource_income_to_expenditure_balance_ratio] = {
    ## cardinality = 0..1
    resource = <resource>
    ### Optional; if not provided, will use sum for all Categories
    ## cardinality = 0..1
    category = enum[resource_category]
    value = value_field
}

### Checks the value of economic production modifiers a pop_group has for producing a certain resource via a certain job. Can specify checking all modifiers or just those from traits. WARNING: expensive trigger
## scopes = { planet pop_group }
alias[trigger:check_economic_production_modifier_for_job] = {
    job = <job>
    resource = <resource>
    resource = {
        ## cardinality = 1..inf
        <resource> = float
    }
    ## cardinality = 0..1
    species_modifiers_only = bool
    value = value_field
}

### Checks if the planet has any, or a specific, holding
## scopes = { planet }
alias[trigger:has_holding] = {
    holding = any
    holding = none
    holding = <building.corporate>
    holding = <building.holding>
    owner = scope_group[target_country]
}

### Checks if the agreement has the specified preset
## scopes = { agreement }
alias[trigger:agreement_preset] = <agreement_preset>

### Checks if the scoped fleet is leased.
## scopes = { fleet }
alias[trigger:is_leased] = bool

### Checks the number of days left before fleet lease contract is finished
## scopes = { fleet }
alias[trigger:lease_days] == int_value_field

### Checks the subject's current loyalty to its overlord.
## scopes = { country }
alias[trigger:has_loyalty] == int_value_field[-100..100]

### Checks the subject's current monthly loyalty gain/loss.
## scopes = { country }
alias[trigger:has_monthly_loyalty] == int_value_field[-100..100]

### Checks if the country has the specified AI behavior towards another country
## scopes = { country }
alias[trigger:has_attitude_behavior] = {
    target = scope_group[target_country]
    behavior = enum[ai_attitude_behaviour]
}

### Checks if the agreement has a specific specialist perk active
## scopes = { agreement }
alias[trigger:has_specialist_perk] = <specialist_subject_perk>

### Checks if the agreement has an active specialization of the specified type, or of any type if 'any' is specified
## scopes = { agreement }
alias[trigger:has_active_specialization] = <agreement_term_value.specialist_type>
### Checks if the agreement has an active specialization of the specified type, or of any type if 'any' is specified
## scopes = { agreement }
alias[trigger:has_active_specialization] = any

### Checks the specialization tier of the subject of the agreement.
## scopes = { agreement }
alias[trigger:specialist_tier] == int_value_field

### Checks if the country has a secret fealty with the other country (in either direction)
## scopes = { country }
alias[trigger:has_secret_fealty_with] = scope_group[target_country]

### Checks if current country's capital is connected to target's capital through hyper relay network
## scopes = { country }
alias[trigger:is_capitals_connected_through_relay_network] = scope_group[target_country]

### Checks if target system is connected to own capitals through hyper relay network
## scopes = { galactic_object }
alias[trigger:is_system_connected_to_relay_network] = bool

### Checks if the country AI wants to renegotiate any existing agreements
## scopes = { country }
alias[trigger:ai_wants_to_negotiate_agreement] = bool

### Checks if the country has an overlord
## scopes = { country }
alias[trigger:has_any_overlord] = bool

### Checks if the agreement has a specific term
## scopes = { agreement }
alias[trigger:has_term_value] = {
    term = <agreement_term>
    value = <agreement_term_value>
}

### Check if a trade action is already active in a trade deal with the specified empire (or with any empire if so specified)
## scopes = { country }
alias[trigger:is_action_active] = {
    action = <action_key>
    with_country = scope_group[target_country]
    with_country = any
}

### Checks if terms of the special offer between scoped and target countries is not obsolete
### Only works in certain parts of the script marked with ai_trade_facility.
## scopes = { country }
alias[trigger:is_offer_terms_actual] = {
    target = scope_group[target_country]
}

### Checks if the scoped country can afford the offer given by the target country.
### Only works in certain parts of the script marked with ai_trade_facility.
## scopes = { country }
alias[trigger:can_afford_special_offer] = {
    target = scope_group[target_country]
}

### Checks if the design has a specific flag
## scopes = { design }
alias[trigger:has_design_flag] = value[design_flag]

### Checks if L-Gates are enabled in game setup
## scopes = any
alias[trigger:lgate_enabled] = bool

### Checks if the leader is immortal (either by script effect or species characteristics)
## scopes = { leader }
alias[trigger:is_immortal] = bool

### Checks the planet's total number of deposits
## scopes = { planet }
alias[trigger:num_deposits] == int_value_field

### Checks the country's free enclave number capacity in absolute numbers
## scopes = { country }
alias[trigger:enclave_capacity_left] == int_value_field[0..inf]

# 3.7

### Checks the degree to which multiply_crisis_strength effect is increasing the strength of endgame crises
## scopes = any
alias[trigger:additional_crisis_strength] == int_value_field[0..inf]

### Checks the country's number of civics
## scopes = { country }
alias[trigger:civics_count] == int_value_field[0..inf]

### Checks if the empire has activated as many ascension tiers as specified:
## scopes = { country }
alias[trigger:num_planetary_ascension_tiers] == int_value_field[0..inf]

### Checks if a job is of a certain pop_group category. Note that the result for this trigger is not dependent on where it is used - so it's for use in e.g. templated script values.
## scopes = any
alias[trigger:is_job_of_pop_category] = {
    job = <job>
    category = <pop_category>
}

### Compares the former migration control type with the given one.
## scopes = { pop_group }
alias[trigger:former_colonization_control_type] = <colonization_control>

### Checks if the scoped megastructure is built on a planet
## scopes = { megastructure }
alias[trigger:built_on_planet] = bool

### Checks if the last resolution the Galactic Community voted on or otherwise passed or failed is as specified.
## scopes = any
alias[trigger:last_resolution_changed] = <resolution>

### Checks if the current country is supporting, opposing or abstaining from the currently proposed galcom resolution.
## scopes = { country }
alias[trigger:position_on_current_resolution] = enum[resolution_position]

### Checks if the current country was supporting, opposing or abstaining from the last proposed galcom resolution.
## scopes = { country }
alias[trigger:position_on_last_resolution] = enum[resolution_position]

enums = {
    enum[resolution_position] = {
        support
        oppose
        abstain
    }
}

### Checks whether the galaxy shape if of a certain shape
## scopes = any
alias[trigger:galaxy_shape] = <galaxy_shape>

### Compares spy network max level of the scoped object
## scopes = { spy_network }
alias[trigger:is_spynetwork_max_level] = int

### Checks if country is under societal enlightenment
## scopes = { country }
alias[trigger:is_under_societal_enlightenment] = scope[country]

### Checks if country is under open technological enlightenment
## scopes = { country }
alias[trigger:is_under_open_technological_enlightenment] = scope[country]

### Checks if country is under stratified technological enlightenment
## scopes = { country }
alias[trigger:is_under_stratified_technological_enlightenment] = scope[country]

### Checks if country has pre-ftl trade
## scopes = { country }
alias[trigger:has_pre_ftl_trade] = scope[country]

### Checks ship design has a certain role
## scopes = { ship_growth_stage design }
alias[trigger:has_role] = enum[component_tag]

### Checks if a fleet or ship is cloaked.
## scopes = { ship fleet }
alias[trigger:is_cloaked] = bool

### Compares cloaking strength value of the scoped fleet or ship.
## scopes = { ship fleet }
alias[trigger:has_cloaking_strength] = int_value_field

### Compares cloaking detection value of the scoped fleet or ship.
## scopes = { ship fleet }
alias[trigger:has_cloaking_detection] = int_value_field

### Checks the country's awareness if it's pre-FTL
## scopes = { country }
alias[trigger:has_awareness] = int_value_field

### Checks the country's awareness level if it's pre-FTL
## scopes = { country }
alias[trigger:current_awareness_level] = enum[awareness_level]

enums = {
    enum[awareness_level] = {
        none
        low
        medium
        high
        full
    }
}

### Checks if the country is a pre-FTL civilization and has another pre-FTL tech age after its current one
## scopes = { country }
alias[trigger:has_next_pre_ftl_age] = yes

### Checks if the country is a pre-FTL civilization and is in the specified age
## scopes = { country }
alias[trigger:has_pre_ftl_age] = <pre_ftl_age>

# 3.8

### Checks the scope leader's years of service
## scopes = { leader }
alias[trigger:leader_years_of_service] = int

### Checks the number of leader traits or total tiers of traits for a specific leader
## scopes = { leader }
alias[trigger:num_leader_traits] = {
    value = value_field
    ### default: any
    ## cardinality = 0..1
    is_councilor = enum[any_or_bool]
    ## default: yes
    ## cardinality = 0..1
    is_subclass = bool
    ### default: any
    ## cardinality = 0..1
    negative = enum[any_or_bool]
    ### default: no
    ## cardinality = 0..1
    count_tiers = bool
    ## cardinality = 0..1
    ### filters on whether the trait has a modifier that contains the specified string
    contains_modifier = {
        string = scalar
        type = enum[any_or_bool]
        is_subclass = enum[any_or_bool]
    }
}

### Checks if scoped leader is the Ruler of the Empire
## scopes = { leader }
alias[trigger:is_ruler] = bool

### Checks if scoped leader is the Heir of the Empire
## scopes = { leader }
alias[trigger:is_heir] = bool

### Get the level of a specific councilor
## scopes = { country }
alias[trigger:get_councilor_level] = {
    type = <councilor>
}

### Checks if the leader holds a specific Councilor type
## scopes = { leader }
alias[trigger:is_councilor_type] = <councilor>

### Checks if any Councilor has a given ethic.
## scopes = { country }
alias[trigger:is_ethic_represented_on_council] = <ethic>

### Checks if the country has a civic in a slot
## scopes = { country }
alias[trigger:has_civic_in_slot] = {
    civic = <civic_or_origin.civic>
    index = int[0..inf]
}

### Compares the amount of total civic points.
## scopes = { country }
alias[trigger:has_total_civic_points] == value_field

### Compares the amount of unused civic points.
## scopes = { country }
alias[trigger:has_unused_civic_points] == value_field

### Compares the number of times an election candidate was supported.
## scopes = { leader }
alias[trigger:num_candidate_supported] == value_field

### Compares the progress (0-1) of the current Agenda.
## scopes = { country }
alias[trigger:council_agenda_progress_percent] == value_field

### Checks if the country has a specific Council Agenda selected, or any at all
## scopes = { country }
alias[trigger:has_agenda_selected] = enum[any_or_none_or_bool]
### Checks if the country has a specific Council Agenda selected, or any at all
## scopes = { country }
alias[trigger:has_agenda_selected] = <agenda>

### Compares the amount of unlocked council positions, typically from 'unlock_council_slots'
## scopes = { country }
alias[trigger:has_unlocked_council_positions] == value_field

### Checks if the leader's background contains a specific previous job, or any job if set to yes
## scopes = { leader }
alias[trigger:has_background_job] = <job>
### Checks if the leader's background contains a specific previous job, or any job if set to yes
## scopes = { leader }
alias[trigger:has_background_job] = yes

### Checks if the army is currently in the frontline of a combat
## scopes = { army }
alias[trigger:is_in_frontline] = bool

### Check if a planet is the background planet of a leader
## scopes = { leader }
alias[trigger:is_background_planet] = scope[planet]

### Checks if scoped leader is a member of the Empire Council or the Ruler
## scopes = { leader }
alias[trigger:is_councilor] = bool

# 3.9.1

### Checks the progress of the current Agenda.
## scopes = { country }
alias[trigger:council_agenda_progress] == value_field

### Checks if the leader is hidden from the player
## scopes = { leader }
alias[trigger:is_hidden] = bool

### Checks if the scoped fleet is a garrison.
## scopes = { fleet }
alias[trigger:is_garrison] = bool

### Checks the country/pop_group/leader/species' number of positive traits (traits with a cost strictly greater than 0 count as positive)
## scopes = { country pop_group leader species }
alias[trigger:num_positive_traits] = int

### Checks the country/pop_group/leader/species' number of negative traits (traits with a cost strictly lower than 0 count as negative)
## scopes = { country pop_group leader species }
alias[trigger:num_negative_traits] = int

### Checks if the current player is currently viewing the galaxy map.
## scopes = { planet country ship pop_group fleet }
alias[trigger:is_on_galaxy_map] = bool

### Checks if the current player is currently paused.
## scopes = { planet country ship pop_group fleet }
alias[trigger:is_paused] = bool

# 3.10.0

### Checks the scope leader's lifespan
## scopes = { leader }
alias[trigger:leader_lifespan] = int_value_field

### Checks if the specified relic was the last lost one
## scopes = { country }
alias[trigger:last_lost_relic] = <relic>

### Checks if the specified relic was the last received one
## scopes = { country }
alias[trigger:last_received_relic] = <relic>

### Checks if the planet is an astral scar
## scopes = { planet }
alias[trigger:is_astral_scar] = bool

### Returns true if the Bypass Lock can be renewed
## scopes = { bypass }
alias[trigger:can_lock_be_renewed] = bool

### Checks current value for council legitimacy for the scoped country.
## scopes = { country }
alias[trigger:council_legitimacy] = int_value_field

### Checks if the astral rift has a specific flag
## scopes = { astral_rift }
alias[trigger:has_astral_rift_flag] = value[astral_rift_flag]

### Checks if the country has completed a specific event chain
## scopes = { country }
alias[trigger:has_completed_event_chain] = <event_chain>

### Checks the distance of a controlled system to its owner's capital
## scopes = { planet galactic_object }
alias[trigger:distance_to_capital] = int_value_field

### Returns true if the astral rift starting event pool is empty
## scopes = { country }
alias[trigger:is_astral_rift_pool_empty] = bool

### Returns true if the scopes system contains at least one astral rift
## scopes = { galactic_object }
alias[trigger:has_astral_rift] = bool

### Checks if an archaeological site has progression locked or not.
## scopes = { archaeological_site }
alias[trigger:is_site_locked] = bool

### Checks the number of days left for the Relics Triumph
## scopes = { country }
alias[trigger:triumph_days_left] = int_value_field

### Checks the difference between an explorer's level and an Astral Rift current difficulty
## scopes = { astral_rift }
alias[trigger:astral_rift_relative_difficulty] = int_value_field

### Return how many Astral Rifts were completed by the country
## scopes = { country }
alias[trigger:astral_rifts_completed] = int_value_field

### Returns true if the astral rift with the given id is or was explored by the scoped country
## scopes = { country }
alias[trigger:is_astral_rift_explored] = <astral_rift>

### Returns true if the scope bypass is of type <type>
## scopes = { bypass }
alias[trigger:is_bypass_type] = <bypass>

### Returns true if the bypass is locked by a dimensional lock
## scopes = { bypass }
alias[trigger:has_lock] = bool

### Checks if the scoped fleet can go MIA.
## scopes = { fleet }
alias[trigger:can_go_mia] = bool

# 3.11.1

### Checks if the last resolution the Galactic Community voted on or otherwise passed or failed is part of the specified category.
## scopes = any
alias[trigger:last_resolution_category_changed] = <resolution_category>

# scope links

### Iterate through all playable countries - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = country
alias[trigger:any_playable_country] = single_alias_right[trigger_clause]

### Finds the closest system within the given hyperlane steps and limit = { <triggers> }. If this system does not exist, it returns false. If it does exist, it is checked against the triggers outside of the limit = {}.
### Conditions outside of the limit = { } will check whether these conditions are true for *the closest* system for which the trigger conditions and min_steps conditions.
## scopes = any
## push_scope = system
alias[trigger:closest_system] = {
    ## cardinality = 0..1
    min_steps = int
    ## cardinality = 0..1
    max_steps = int
    ## cardinality = 0..1
    use_bypasses = bool
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    alias_name[trigger] = alias_match_left[trigger]
}

### Iterate through each fleet owned by the country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = fleet
alias[trigger:any_owned_fleet] = single_alias_right[trigger_clause]

### Iterate through each orbital station owned by the current country or in the current system - checks whether the enclosed triggers return true for any of them
## scopes = { country galactic_object }
## push_scope = fleet
alias[trigger:any_orbital_station] = single_alias_right[trigger_clause]

### Iterate through each planet within the current empire's borders - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = planet
alias[trigger:any_planet_within_border] = single_alias_right[trigger_clause]

### Iterate through each ship in the fleet or controlled by the country - checks whether the enclosed triggers return true for any of them
## scopes = { country fleet }
## push_scope = ship
alias[trigger:any_owned_ship] = single_alias_right[trigger_clause]

### Iterate through each moon of the planet - checks whether the enclosed triggers return true for any of them
## scopes = { planet }
## push_scope = planet
alias[trigger:any_moon] = single_alias_right[trigger_clause]

### Iterate through all wars the country is engaged in - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = war
alias[trigger:any_war] = single_alias_right[trigger_clause]

### Iterate through all defenders in the current war - checks whether the enclosed triggers return true for any of them
## scopes = { war }
## push_scope = country
alias[trigger:any_defender] = single_alias_right[trigger_clause]

### Iterate through all attackers in the current war - checks whether the enclosed triggers return true for any of them
## scopes = { war }
## push_scope = country
alias[trigger:any_attacker] = single_alias_right[trigger_clause]

### Iterate through each planet (colony or not) in the current system - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = planet
alias[trigger:any_system_planet] = single_alias_right[trigger_clause]

### Iterate through each fleet orbiting the current planet/starbase/megastructure - checks whether the enclosed triggers return true for any of them
## scopes = { megastructure planet starbase }
## push_scope = fleet
alias[trigger:any_fleet_in_orbit] = single_alias_right[trigger_clause]

### Iterate through all countries - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = country
alias[trigger:any_country] = single_alias_right[trigger_clause]

### Checks if any of the planet/species/pop_group faction pops meet the specified criteria. Warning: deprecated, use any_owned_pop/any_species_pop
## scopes = { planet species pop_faction }
## push_scope = pop_group
alias[trigger:any_pop] = single_alias_right[trigger_clause]

### Checks the number of pops in the scope that fulfill the specified criteria. Warning: deprecated, use count_owned_pop/count_species_pop
## scopes = { planet species pop_faction }
alias[trigger:count_pops] = {
    ## cardinality = 0..1
    ## push_scope = pop_group
    limit = single_alias_right[trigger_clause]
    count = int
}

### Iterate through each deposit on the planet - checks whether the enclosed triggers return true for any of them
## scopes = { planet }
## push_scope = deposit
alias[trigger:any_deposit] = single_alias_right[trigger_clause]

### Iterate through all rim systems - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = system
alias[trigger:any_rim_system] = single_alias_right[trigger_clause]

### Iterate through each ship in the current system - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = ship
alias[trigger:any_ship_in_system] = single_alias_right[trigger_clause]

### Iterate through each leader that is owned by the country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = leader
alias[trigger:any_owned_leader] = single_alias_right[trigger_clause]

### Iterate through all owned pops - checks whether the enclosed triggers return true for any of them
## scopes = { planet country pop_faction sector }
## push_scope = pop_group
alias[trigger:any_owned_pop_group] = single_alias_right[trigger_clause]

### Iterate through all owned pop groups - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet country pop_faction }
alias[trigger:count_owned_pop_group] = {
    ## cardinality = 0..1
    ## push_scope = pop_group
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Sums all pop amounts - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet country pop_faction sector }
alias[trigger:count_owned_pop_amount] = {
    ## cardinality = 0..1
    ## push_scope = pop_group
    limit = single_alias_right[trigger_clause]
    ## cardinality = ~1..1
    count = int_value_field
}

### Checks the number of deposits on the planet that meet the specified criteria
## scopes = { planet }
alias[trigger:count_deposits] =  {
    ## cardinality = 0..1
    type = <deposit>
    ## cardinality = 0..1
    category = <deposit_category>
    count = int_value_field
}

### Iterate through every ambient object in the game - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = ambient_object
alias[trigger:any_ambient_object] = single_alias_right[trigger_clause]

### Iterate through every ambient object in the solar system - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = ambient_object
alias[trigger:any_system_ambient_object] = single_alias_right[trigger_clause]

### Iterate through each member of the federation - checks whether the enclosed triggers return true for any of them
## scopes = { federation }
## push_scope = country
alias[trigger:any_member] = single_alias_right[trigger_clause]

### Checks the number of participants in the war on a specific side that meet the specified criteria
## scopes = { war }
alias[trigger:count_war_participants] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    side = scope[country]
    count = int_value_field
}

# Side should be one of the previous two scopes
### Checks the amount of potential war participants in a specific war that meet the specified criteria
## scopes = any
alias[trigger:count_potential_war_participants] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    attacker = scope[country]
    defender = scope[country]
    side = scope[country]
    count = int_value_field
}

### Iterate through all a system's neighboring systems by hyperlane - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = system
alias[trigger:any_neighbor_system] = single_alias_right[trigger_clause]

### Iterate through all subjects of the scoped country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = country
alias[trigger:any_subject] = single_alias_right[trigger_clause]

### Iterate through all relations - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = country
alias[trigger:any_relation] = single_alias_right[trigger_clause]

### Counts the number of species in the scope that fulfill the specified criteria, not counting sub-species as unique.
## scopes = { planet country }
alias[trigger:count_species] = {
    ## cardinality = 0..1
    ## push_scope = species
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Counts the number of species in the scope that fulfill the specified criteria, counting sub-species as unique.
## scopes = { planet country }
alias[trigger:count_exact_species] = {
    ## cardinality = 0..1
    ## push_scope = species
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Check if any of the species <on the planet/in the country> meet the specified criteria - checks whether the enclosed triggers return true for any of them
## scopes = { planet country }
## push_scope = species
alias[trigger:any_owned_species] = single_alias_right[trigger_clause]

### Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - checks whether the enclosed triggers return true for any of them
## scopes = { planet country }
## push_scope = species
alias[trigger:any_enslaved_species] = single_alias_right[trigger_clause]

### Iterate through each agreement - checks whether the enclosed triggers return true for any of them
## scopes = { country no_scope }
## push_scope = agreement
alias[trigger:any_agreement] = single_alias_right[trigger_clause]

### Iterate through each agreement - checks whether the enclosed triggers return true for X/all of them
## scopes = { country no_scope }
alias[trigger:count_agreement] = {
    ## cardinality = 0..1
    ## push_scope = agreement
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every ambient object in the game - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_ambient_object] = {
    ## cardinality = 0..1
    ## push_scope = ambient_object
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every ambient object in the solar system - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_system_ambient_object] = {
    ## cardinality = 0..1
    ## push_scope = ambient_object
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every archaeological sites - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = archaeological_site
alias[trigger:any_archaeological_site] = single_alias_right[trigger_clause]

### Iterate through every archaeological sites - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_archaeological_site] = {
    ## cardinality = 0..1
    ## push_scope = archaeological_site
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each army that is owned by the country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = army
alias[trigger:any_owned_army] = single_alias_right[trigger_clause]

### Iterate through each army that is owned by the country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_army] = {
    ## cardinality = 0..1
    ## push_scope = army
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each army on the planet (not in ground combat), regardless of owner. - checks whether the enclosed triggers return true for any of them
## scopes = { planet }
## push_scope = army
alias[trigger:any_planet_army] = single_alias_right[trigger_clause]

### Iterate through each army on the planet (not in ground combat), regardless of owner. - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet }
alias[trigger:count_planet_army] = {
    ## cardinality = 0..1
    ## push_scope = army
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each army currently defending the planet in ground combat - checks whether the enclosed triggers return true for any of them
## scopes = { planet }
## push_scope = army
alias[trigger:any_ground_combat_defender] = single_alias_right[trigger_clause]

### Iterate through each army currently defending the planet in ground combat - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet }
alias[trigger:count_ground_combat_defender] = {
    ## cardinality = 0..1
    ## push_scope = army
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each army currently attacking the planet in ground combat - checks whether the enclosed triggers return true for any of them
## scopes = { planet }
## push_scope = army
alias[trigger:any_ground_combat_attacker] = single_alias_right[trigger_clause]

### Iterate through each army currently attacking the planet in ground combat - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet }
alias[trigger:count_ground_combat_attacker] = {
    ## cardinality = 0..1
    ## push_scope = army
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all countries - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_country] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all relations - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_relation] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all neighbor countries - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = country
alias[trigger:any_neighbor_country] = single_alias_right[trigger_clause]

### Iterate through all neighbor countries - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_neighbor_country] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all countries that own system 1 jump away from current system (bypasses included) - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = country
alias[trigger:any_country_neighbor_to_system] = single_alias_right[trigger_clause]

### Iterate through all countries that own system 1 jump away from current system (bypasses included) - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_country_neighbor_to_system] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all countries rivalled by the scoped country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = country
alias[trigger:any_rival_country] = single_alias_right[trigger_clause]

### Iterate through all countries rivalled by the scoped country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_rival_country] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all countries in a federation with the scoped country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = country
alias[trigger:any_federation_ally] = single_alias_right[trigger_clause]

### Iterate through all countries in a federation with the scoped country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_federation_ally] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all playable countries - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_playable_country] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all subjects of the scoped country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_subject] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all debris belong to available special projects of the scoped country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = debris
alias[trigger:any_available_debris] = single_alias_right[trigger_clause]

### Iterate through all debris belong to available special projects of the scoped country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_available_debris] = {
    ## cardinality = 0..1
    ## push_scope = debris
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all designs owned by the current country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = design
alias[trigger:any_owned_design] = single_alias_right[trigger_clause]

### Iterate through all designs owned by the current country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_design] = {
    ## cardinality = 0..1
    ## push_scope = design
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each spynetwork - checks whether the enclosed triggers return true for any of them
## scopes = { country no_scope }
## push_scope = spy_network
alias[trigger:any_spynetwork] = single_alias_right[trigger_clause]

### Iterate through each spynetwork - checks whether the enclosed triggers return true for X/all of them
## scopes = { country no_scope }
alias[trigger:count_spynetwork] = {
    ## cardinality = 0..1
    ## push_scope = spy_network
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each espionage operation - checks whether the enclosed triggers return true for any of them
## scopes = { country no_scope spy_network }
## push_scope = espionage_operation
alias[trigger:any_espionage_operation] = single_alias_right[trigger_clause]

### Iterate through each espionage operation - checks whether the enclosed triggers return true for X/all of them
## scopes = { country no_scope spy_network }
alias[trigger:count_espionage_operation] = {
    ## cardinality = 0..1
    ## push_scope = espionage_operation
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each espionage asset - checks whether the enclosed triggers return true for any of them
## scopes = { no_scope spy_network espionage_operation }
## push_scope = espionage_asset
alias[trigger:any_espionage_asset] = single_alias_right[trigger_clause]

### Iterate through each espionage asset - checks whether the enclosed triggers return true for X/all of them
## scopes = { no_scope spy_network espionage_operation }
alias[trigger:count_espionage_asset] = {
    ## cardinality = 0..1
    ## push_scope = espionage_asset
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each federation - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = federation
alias[trigger:any_federation] = single_alias_right[trigger_clause]

### Iterate through each federation - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_federation] = {
    ## cardinality = 0..1
    ## push_scope = federation
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each first contact (both active and complete) that this country is engaging in - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = first_contact
alias[trigger:any_first_contact] = single_alias_right[trigger_clause]

### Iterate through each first contact (both active and complete) that this country is engaging in - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_first_contact] = {
    ## cardinality = 0..1
    ## push_scope = first_contact
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each active (non-completed) first contact that this country is engaging in - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = first_contact
alias[trigger:any_active_first_contact] = single_alias_right[trigger_clause]

### Iterate through each active (non-completed) first contact that this country is engaging in - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_active_first_contact] = {
    ## cardinality = 0..1
    ## push_scope = first_contact
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each fleet in the entire game - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = fleet
alias[trigger:any_galaxy_fleet] = single_alias_right[trigger_clause]

### Iterate through each fleet in the entire game - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_galaxy_fleet] = {
    ## cardinality = 0..1
    ## push_scope = fleet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each fleet this fleet is in combat with - checks whether the enclosed triggers return true for any of them
## scopes = { fleet }
## push_scope = fleet
alias[trigger:any_combatant_fleet] = single_alias_right[trigger_clause]

### Iterate through each fleet this fleet is in combat with - checks whether the enclosed triggers return true for X/all of them
## scopes = { fleet }
alias[trigger:count_combatant_fleet] = {
    ## cardinality = 0..1
    ## push_scope = fleet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each fleet in the current system - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = fleet
alias[trigger:any_fleet_in_system] = single_alias_right[trigger_clause]

### Iterate through each fleet in the current system - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_fleet_in_system] = {
    ## cardinality = 0..1
    ## push_scope = fleet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each fleet owned by the country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_fleet] = {
    ## cardinality = 0..1
    ## push_scope = fleet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each fleet controlled by the country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = fleet
alias[trigger:any_controlled_fleet] = single_alias_right[trigger_clause]

### Iterate through each fleet controlled by the country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_controlled_fleet] = {
    ## cardinality = 0..1
    ## push_scope = fleet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each fleet orbiting the current planet/starbase/megastructure - checks whether the enclosed triggers return true for X/all of them
## scopes = { megastructure planet starbase }
alias[trigger:count_fleet_in_orbit] = {
    ## cardinality = 0..1
    ## push_scope = fleet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each orbital station owned by the current country or in the current system - checks whether the enclosed triggers return true for X/all of them
## scopes = { country galactic_object }
alias[trigger:count_orbital_station] = {
    ## cardinality = 0..1
    ## push_scope = fleet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each member of the galactic community - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = country
alias[trigger:any_galcom_member] = single_alias_right[trigger_clause]

### Iterate through each member of the galactic community - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_galcom_member] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each member of the galactic council - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = country
alias[trigger:any_council_member] = single_alias_right[trigger_clause]

### Iterate through each member of the galactic council - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_council_member] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each leader that is owned by the country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_leader] = {
    ## cardinality = 0..1
    ## push_scope = leader
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each leader that is recruitable for the country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = leader
alias[trigger:any_pool_leader] = single_alias_right[trigger_clause]

### Iterate through each leader that is recruitable for the country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_pool_leader] = {
    ## cardinality = 0..1
    ## push_scope = leader
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each envoy available to the country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = leader
alias[trigger:any_envoy] = single_alias_right[trigger_clause]

### Iterate through each envoy available to the country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_envoy] = {
    ## cardinality = 0..1
    ## push_scope = leader
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each megastructure - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = megastructure
alias[trigger:any_megastructure] = single_alias_right[trigger_clause]

### Iterate through each megastructure - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_megastructure] = {
    ## cardinality = 0..1
    ## push_scope = megastructure
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each owned megastructure - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = megastructure
alias[trigger:any_owned_megastructure] = single_alias_right[trigger_clause]

### Iterate through each owned megastructure - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_megastructure] = {
    ## cardinality = 0..1
    ## push_scope = megastructure
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each megastructure in system - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = megastructure
alias[trigger:any_system_megastructure] = single_alias_right[trigger_clause]

### Iterate through each megastructure in system - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_system_megastructure] = {
    ## cardinality = 0..1
    ## push_scope = megastructure
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each member of the federation - checks whether the enclosed triggers return true for X/all of them
## scopes = { federation }
alias[trigger:count_member] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each associate member of the federation - checks whether the enclosed triggers return true for any of them
## scopes = { federation }
## push_scope = country
alias[trigger:any_associate] = single_alias_right[trigger_clause]

### Iterate through each associate member of the federation - checks whether the enclosed triggers return true for X/all of them
## scopes = { federation }
alias[trigger:count_associate] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each planet (colony or not) in the current system - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_system_planet] = {
    ## cardinality = 0..1
    ## push_scope = planet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each colony in the current system - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = planet
alias[trigger:any_system_colony] = single_alias_right[trigger_clause]

### Iterate through each colony in the current system - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_system_colony] = {
    ## cardinality = 0..1
    ## push_scope = planet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each planet within the current empire's borders - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_planet_within_border] = {
    ## cardinality = 0..1
    ## push_scope = planet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each inhabited planet owned by the current empire - checks whether the enclosed triggers return true for any of them
## scopes = { country sector }
## push_scope = planet
alias[trigger:any_owned_planet] = single_alias_right[trigger_clause]

### Iterate through each inhabited planet owned by the current empire - checks whether the enclosed triggers return true for X/all of them
## scopes = { country sector }
alias[trigger:count_owned_planet] = {
    ## cardinality = 0..1
    ## push_scope = planet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each inhabited planet controlled by the current empire - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = planet
alias[trigger:any_controlled_planet] = single_alias_right[trigger_clause]

### Iterate through each inhabited planet controlled by the current empire - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_controlled_planet] = {
    ## cardinality = 0..1
    ## push_scope = planet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each planet ANYWHERE in the game; warning: resource intensive! - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = planet
alias[trigger:any_galaxy_planet] = single_alias_right[trigger_clause]

### Iterate through each planet ANYWHERE in the game; warning: resource intensive! - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_galaxy_planet] = {
    ## cardinality = 0..1
    ## push_scope = planet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each deposit on the planet - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet }
alias[trigger:count_deposit] = {
    ## cardinality = 0..1
    ## push_scope = deposit
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each moon of the planet - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet }
alias[trigger:count_moon] = {
    ## cardinality = 0..1
    ## push_scope = planet
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each pop_group that belongs to this species; warning: resource-intensive! - checks whether the enclosed triggers return true for any of them
## scopes = { species }
## push_scope = pop_group
alias[trigger:any_species_pop_group] = single_alias_right[trigger_clause]

### Iterate through each pop_group that belongs to this species; warning: resource-intensive! - checks whether the enclosed triggers return true for X/all of them
## scopes = { species }
alias[trigger:count_species_pop_group] = {
    ## cardinality = 0..1
    ## push_scope = pop_group
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all owned pop jobs - checks whether the enclosed triggers return true for any of them
## scopes = { planet country sector }
## push_scope = pop_job
alias[trigger:any_owned_pop_job] = single_alias_right[trigger_clause]

### Iterate through all owned pop jobs - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet country sector }
alias[trigger:count_owned_pop_job] = {
    ## cardinality = 0..1
    ## push_scope = pop_job
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Sums all workforce - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet country sector }
alias[trigger:count_owned_workforce] = {
    ## cardinality = 0..1
    ## push_scope = pop_job
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all the country's pop_group factions - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = pop_faction
alias[trigger:any_pop_faction] = single_alias_right[trigger_clause]

### Iterate through all the country's pop_group factions - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_pop_faction] = {
    ## cardinality = 0..1
    ## push_scope = pop_faction
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all sectors in the game - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = sector
alias[trigger:any_galaxy_sector] = single_alias_right[trigger_clause]

### Iterate through all sectors in the game - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_galaxy_sector] = {
    ## cardinality = 0..1
    ## push_scope = sector
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every owned sector - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = sector
alias[trigger:any_owned_sector] = single_alias_right[trigger_clause]

### Iterate through every owned sector - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_sector] = {
    ## cardinality = 0..1
    ## push_scope = sector
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each ship in the fleet or controlled by the country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country fleet }
alias[trigger:count_owned_ship] = {
    ## cardinality = 0..1
    ## push_scope = ship
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each ship in the fleet or controlled by the country - checks whether the enclosed triggers return true for any of them
## scopes = { country fleet }
## push_scope = ship
alias[trigger:any_controlled_ship] = single_alias_right[trigger_clause]

### Iterate through each ship in the fleet or controlled by the country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country fleet }
alias[trigger:count_controlled_ship] = {
    ## cardinality = 0..1
    ## push_scope = ship
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each ship in the current system - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_ship_in_system] = {
    ## cardinality = 0..1
    ## push_scope = ship
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each situation a country is experiencing - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = situation
alias[trigger:any_situation] = single_alias_right[trigger_clause]

### Iterate through each situation a country is experiencing - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_situation] = {
    ## cardinality = 0..1
    ## push_scope = situation
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each situation that is targeting the current planet - checks whether the enclosed triggers return true for any of them
## scopes = { planet }
## push_scope = situation
alias[trigger:any_targeting_situation] = single_alias_right[trigger_clause]

### Iterate through each situation that is targeting the current planet - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet }
alias[trigger:count_targeting_situation] = {
    ## cardinality = 0..1
    ## push_scope = situation
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each species of a country's owned pops - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = species
alias[trigger:any_owned_pop_species] = single_alias_right[trigger_clause]

### Iterate through each species of a country's owned pops - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_pop_species] = {
    ## cardinality = 0..1
    ## push_scope = species
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Check if any species in the galaxy meet the specified criteria - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = species
alias[trigger:any_galaxy_species] = single_alias_right[trigger_clause]

### Check if any species in the galaxy meet the specified criteria - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_galaxy_species] = {
    ## cardinality = 0..1
    ## push_scope = species
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Check if any of the species <on the planet/in the country> meet the specified criteria - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet country }
alias[trigger:count_owned_species] = {
    ## cardinality = 0..1
    ## push_scope = species
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - checks whether the enclosed triggers return true for X/all of them
## scopes = { planet country }
alias[trigger:count_enslaved_species] = {
    ## cardinality = 0..1
    ## push_scope = species
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all existing species traits in the game - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = country
alias[trigger:any_existing_species_traits] = single_alias_right[trigger_clause]

### Iterate through all existing species traits in the game - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_existing_species_traits] = {
    ## cardinality = 0..1
    ## push_scope = trait
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through each trait that the scoped species has. Checks whether the enclosed triggers return true for any of them
## scopes = { pop_group leader species }
## push_scope = trait
alias[trigger:any_trait_of_species] = single_alias_right[trigger_clause]

### Iterate through each trait that the scoped species has. checks whether the enclosed triggers return true for X/all of them
## scopes = { pop_group leader species }
alias[trigger:count_trait_of_species] = {
    ## cardinality = 0..1
    ## push_scope = trait
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all species traits and check if scope species doesn't have this trait. checks whether the enclosed triggers return true for any of them
## scopes = { pop_group leader species }
alias[trigger:any_trait_available_for_species] = { <triggers> }

### Iterate through all species traits and check if scope species doesn't have this trait. checks whether the enclosed triggers return true for X/all of them
## scopes = { pop_group leader species }
alias[trigger:count_trait_available_for_species] = {
    ## cardinality = 0..1
    ## push_scope = trait
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every owned primary starbase - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = starbase
alias[trigger:any_owned_starbase] = single_alias_right[trigger_clause]

### Iterate through every owned primary starbase - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_starbase] = {
    ## cardinality = 0..1
    ## push_scope = starbase
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = starbase
alias[trigger:any_owned_nonprimary_starbase] = single_alias_right[trigger_clause]

### Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_nonprimary_starbase] = {
    ## cardinality = 0..1
    ## push_scope = starbase
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every starbase in the scoped galactic object. - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = starbase
alias[trigger:any_starbase_in_system] = single_alias_right[trigger_clause]

### Iterate through every starbase in the scoped galactic object. - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_starbase_in_system] = {
    ## cardinality = 0..1
    ## push_scope = starbase
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all systems - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = system
alias[trigger:any_system] = single_alias_right[trigger_clause]

### Iterate through all systems - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_system] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all rim systems - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_rim_system] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all systems within the country's or sector's borders - checks whether the enclosed triggers return true for any of them
## scopes = { country sector }
## push_scope = system
alias[trigger:any_system_within_border] = single_alias_right[trigger_clause]

### Iterate through all systems within the country's or sector's borders - checks whether the enclosed triggers return true for X/all of them
## scopes = { country sector }
alias[trigger:count_system_within_border] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all a system's neighboring systems by hyperlane - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_neighbor_system] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = system
alias[trigger:any_neighbor_system_euclidean] = single_alias_right[trigger_clause]

### Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_neighbor_system_euclidean] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all war participants - checks whether the enclosed triggers return true for any of them
## scopes = { war }
## push_scope = country
alias[trigger:any_war_participant] = single_alias_right[trigger_clause]

### Iterate through all war participants - checks whether the enclosed triggers return true for X/all of them
## scopes = { war }
alias[trigger:count_war_participant] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all attackers in the current war - checks whether the enclosed triggers return true for X/all of them
## scopes = { war }
alias[trigger:count_attacker] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all defenders in the current war - checks whether the enclosed triggers return true for X/all of them
## scopes = { war }
alias[trigger:count_defender] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all wars the country is engaged in - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_war] = {
    ## cardinality = 0..1
    ## push_scope = war
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all pre-ftl countries within the country's or sector's borders - checks whether the enclosed triggers return true for any of them
## scopes = { country sector }
## push_scope = country
alias[trigger:any_pre_ftl_within_border] = single_alias_right[trigger_clause]

### Iterate through all pre-ftl countries within the country's or sector's borders - checks whether the enclosed triggers return true for X/all of them
## scopes = { country sector }
alias[trigger:count_pre_ftl_within_border] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - checks whether the enclosed triggers return true for any of them
## scopes = { country sector }
## push_scope = country
alias[trigger:any_observed_pre_ftl_within_border] = single_alias_right[trigger_clause]

### Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - checks whether the enclosed triggers return true for X/all of them
## scopes = { country sector }
alias[trigger:count_observed_pre_ftl_within_border] = {
    ## cardinality = 0..1
    ## push_scope = country
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every astral rift - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = astral_rift
alias[trigger:any_astral_rift] = single_alias_right[trigger_clause]

### Iterate through every astral rift - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_astral_rift] = {
    ## cardinality = 0..1
    ## push_scope = astral_rift
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every bypass - checks whether the enclosed triggers return true for any of them
## scopes = any
## push_scope = bypass
alias[trigger:any_bypass] = single_alias_right[trigger_clause]

### Iterate through every bypass - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_bypass] = {
    ## cardinality = 0..1
    ## push_scope = bypass
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through every bypass in the scoped galactic object. - checks whether the enclosed triggers return true for any of them
## scopes = { galactic_object }
## push_scope = bypass
alias[trigger:any_bypass_in_system] = single_alias_right[trigger_clause]

### Iterate through every bypass in the scoped galactic object. - checks whether the enclosed triggers return true for X/all of them
## scopes = { galactic_object }
alias[trigger:count_bypass_in_system] = {
    ## cardinality = 0..1
    ## push_scope = bypass
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}


### Check how many free jobs there are of a specific jobtype or pop_group category on a planet
## scopes = { planet }
alias[trigger:free_jobs_of_type] = {
    ## cardinality = 0..1
    job = <job>
    ## cardinality = 0..1
    category = <pop_category>
    ### default = no
    ## cardinality = 0..1
    include_deprioritized_jobs = bool
    ## cardinality = 0..1
    value = value_field

}

### Checks number of tradition categories the country has picked
## scopes = { country }
alias[trigger:num_tradition_categories] = int

### Checks if a country has a specific Crisis Perk unlocked.
## scopes = { country }
alias[trigger:has_crisis_perk] = <menace_perk>

### Checks the number of unique traits within the set parameters on a species or pop_group
## scopes = { pop_group species }
alias[trigger:count_traits] = {
    ## push_scope = trait
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    category = enum[auto_mod_category]
    ## cardinality = 0..1
    cost = int

    count = int_value_field
    count = all
}

### Checks the number of unique traits within the set parameters on a species or pop_group
## scopes = { pop_group species }
alias[trigger:count_species_traits] = {
    ## push_scope = trait
    ## cardinality = 0..1
    limit = single_alias_right[trigger_clause]
    ## cardinality = 0..1
    category = enum[auto_mod_category]
    ## cardinality = 0..1
    cost = int

    count = int_value_field
    count = all
}

### Checks if the scoped pop_group faction is extorted
## scopes = { pop_faction }
alias[trigger:is_faction_extorted] = bool

### Checks if the the country has an extorted faction
## scopes = { country }
alias[trigger:has_extorted_faction] = bool

### Checks if pop_group in the scope is being sold on the slave market:
## scopes = { pop_group }
alias[trigger:is_on_slave_market] = bool

### v3.13.0

### Checks the ship's shield hit points
## scopes = { ship }
alias[trigger:has_shield_hp] == value_field

### Checks if the system is inside any storm or a specific storm type.
## scopes = { galactic_object }
alias[trigger:is_inside_storm] = bool
### Checks if the system is inside any storm or a specific storm type.
## scopes = { galactic_object }
alias[trigger:is_inside_storm] = <storm_types>

### Checks if the system is on a countries border
## scopes = { galactic_object }
alias[trigger:is_on_border] = bool

### Checks if the pop_group/species has any trait with infertile
## scopes = { pop_group species }
alias[trigger:is_infertile] = bool

### Returns the amount of influence on a system
## Scopes = { galactic_object }
alias[trigger:cosmic_storm_influence_value] == value_field

### Checks the amount of currently active cosmic storms.
## scopes = any
alias[trigger:num_cosmic_storms] == int_value_field

### Checks the systems total cosmic storm influence
## scopes = { galactic_object }
alias[trigger:cosmic_storm_system_influence] == int_value_field

### Checks if the planet is colonized (in planet scope) or the system has an owner (in system scope)
## scopes = { galactic_object }
alias[trigger:is_influence_center] = bool

### Checks if the cosmic storm has a specific flag (note: one can use e.g. my_flag@from to track relationships between objects)
## scopes = { cosmic_storm }
alias[trigger:has_storm_flag] = value[storm_flag]

### Checks the system's number of asteroid belts
## scopes = { galactic_object }
alias[trigger:num_asteroid_belts] == int_value_field

### Checks if a star system has any environmental effects
## scopes = { galactic_object }
alias[trigger:has_environmental_effects] = bool

### Returns the amount of all storms the country was affected by. Storms that leave stop affecting the country to return to it later are counted as multiple
## scopes = { country }
alias[trigger:num_cosmic_storms_encountered] == int_value_field

### Returns the amount of all unique storms the country was affected by. Storms that leave stop affecting the country to return to it later are counted as one
## scopes = { country }
alias[trigger:num_unique_cosmic_storms_encountered] == int_value_field

### Checks the number of cosmic storm exploitation buildings with positive effects on a country
## scopes = { planet country }
alias[trigger:num_storm_exploitation_buildings] == int_value_field

### Checks if there is currently a storm active within the storm sector that this system belongs to. The galaxy is split up in multiple storm sectors, which we use to avoid spawning storms too close to each other.
## scopes = { galactic_object }
alias[trigger:is_storm_active_in_storm_sector] = bool

### Checks the spawn storm chance scale in early game for cosmic storms
## scopes = any
alias[trigger:num_cosmic_storm_early_game_spawn_chance_scale_setting] == int_value_field

### Checks the spawn storm chance scale in mid game for cosmic storms
## scopes = any
alias[trigger:num_cosmic_storm_mid_game_spawn_chance_scale_setting] == int_value_field

### Checks the spawn storm chance scale in late game for cosmic storms
## scopes = any
alias[trigger:num_cosmic_storm_late_game_spawn_chance_scale_setting] == int_value_field

### Checks the spawn storm max cap in early game for cosmic storms
## scopes = any
alias[trigger:num_cosmic_storm_early_game_spawn_max_cap_setting] == int_value_field

### Checks the spawn storm max cap in mid game for cosmic storms
## scopes = any
alias[trigger:num_cosmic_storm_mid_game_spawn_max_cap_setting] == int_value_field

### Checks the spawn storm max cap in late game for cosmic storms
## scopes = any
alias[trigger:num_cosmic_storm_late_game_spawn_max_cap_setting] == int_value_field

### Checks the spawn storm cooldown scale for cosmic storms
## scopes = any
alias[trigger:num_cosmic_storm_spawn_cooldown_scale_setting] == int_value_field

### Checks if the scoped Cosmic Storm's type is equal to <type>
## scopes = cosmic_storm
alias[trigger:is_storm_type] = <storm_types>

### Compares ship size multiplier of the scoped design or ship.
## scopes = { ship design ship_growth_stage }
alias[trigger:ship_size_multiplier] == value_field

### Iterate through all cosmic storms in the galaxy - checks whether the enclosed triggers return true for any of them
## scopes = any
alias[trigger:any_cosmic_storm] = single_alias_right[trigger_clause]

### Iterate through all cosmic storms in the galaxy - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_cosmic_storm] = {
    ## cardinality = 0..1
    ## push_scope = cosmic_storm
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all systems within the storm - checks whether the enclosed triggers return true for any of them
## scopes = { cosmic_storm }
alias[trigger:any_system_within_storm] = single_alias_right[trigger_clause]

### Iterate through all systems within the storm - checks whether the enclosed triggers return true for X/all of them
## scopes = { cosmic_storm }
alias[trigger:count_system_within_storm] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all systems valid to be a storms start position - checks whether the enclosed triggers return true for any of them
## scopes = any
alias[trigger:any_cosmic_storm_start_position] = single_alias_right[trigger_clause]

### Iterate through all systems valid to be a storms start position - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_cosmic_storm_start_position] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all systems valid to be a storms end position - checks whether the enclosed triggers return true for any of them
## scopes = any
alias[trigger:any_cosmic_storm_end_position] = { <triggers> }

### Iterate through all systems valid to be a storms end position - checks whether the enclosed triggers return true for X/all of them
## scopes = any
alias[trigger:count_cosmic_storm_end_position] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all systems added to the storm - checks whether the enclosed triggers return true for any of them
## scopes = { cosmic_storm }
alias[trigger:any_system_added_to_storm] = single_alias_right[trigger_clause]

### Iterate through all systems added to the storm - checks whether the enclosed triggers return true for X/all of them
## scopes = { cosmic_storm }
alias[trigger:count_system_added_to_storm] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all systems removed from storm - checks whether the enclosed triggers return true for any of them
## scopes = { cosmic_storm }
alias[trigger:any_system_removed_from_storm] = single_alias_right[trigger_clause]

### Iterate through all systems removed from storm - checks whether the enclosed triggers return true for X/all of them
## scopes = { cosmic_storm }
alias[trigger:count_system_removed_from_storm] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all influence fields owned by a country - checks whether the enclosed triggers return true for any of them
## scopes = { country }
alias[trigger:any_owned_storm_influence_field] = single_alias_right[trigger_clause]

### Iterate through all influence fields owned by a country - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
alias[trigger:count_owned_storm_influence_field] = {
    ## cardinality = 0..1
    ## push_scope = cosmic_storm
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### Iterate through all influence fields owned by a country - checks whether the enclosed triggers return true for any of them
## scopes = { cosmic_storm_influence_field }
alias[trigger:any_system_in_cosmic_storm_influence_field] = single_alias_right[trigger_clause]

### Iterate through all influence fields owned by a country - checks whether the enclosed triggers return true for X/all of them
## scopes = { cosmic_storm_influence_field }
alias[trigger:count_system_in_cosmic_storm_influence_field] = {
    ## cardinality = 0..1
    ## push_scope = system
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}

### version v3.14.1

### Checks if the scoped fleet or ship is reanimated (as set in ship sizes).
## scopes = { ship fleet design ship_growth_stage }
alias[trigger:is_reanimated] = bool

### Returns the country's acquired specimens count
## scopes = { country }
alias[trigger:acquired_specimen_count] == int_value_field

### Checks if any Flag has been set to the given scope
## scopes = any
alias[trigger:has_any_flag] = bool

### Checks if the debris is set as "must scavenge"
## scopes = { debris }
alias[trigger:must_scavenge] = bool

### Checks if the debris is set as "must research"
## scopes = { debris }
alias[trigger:must_research] = bool

### Checks Voidworms presence scaling in game setup
## scopes = any
alias[trigger:voidworms_scaling] == value_field

### Checks Cutholoids presence scaling in game setup
## scopes = any
alias[trigger:cutholoids_scaling] == value_field

### Checks if a pop has already picked an auto modded habitability trait.
## scopes = { pop_group }
alias[trigger:has_picked_auto_mod_habitability] = bool

### Checks if the country has the highest technology score
## scopes = { country }
alias[trigger:has_highest_technology_score] = bool

### Checks if the ship growth progress has maxed out.
## scopes = { ship }
alias[trigger:is_growth_complete] = bool

### Checks if a ship is orbiting a star
## scopes = { ship fleet }
alias[trigger:is_orbiting_star] = bool

### Checks the ship's max hull points
## scopes = { ship }
alias[trigger:has_max_hp] == value_field

### Checks the ship's max armor hit points
## scopes = { ship }
alias[trigger:has_max_armor_hp] == value_field

### Checks the scoped object for the remaining days left of the specified timed flag (note: one can use e.g. my_flag@from to track relationships between objects)
## scopes = { megastructure planet country ship pop_group fleet galactic_object leader army ambient_object species pop_faction war federation starbase deposit sector no_scope archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift }
alias[trigger:timed_flag_days_left] = {

    flag = value[megastructure_flag]
    flag = value[planet_flag]
    flag = value[country_flag]
    flag = value[ship_flag]
    flag = value[pop_group_flag]
    flag = value[fleet_flag]
    flag = value[star_flag]
    flag = value[leader_flag]
    flag = value[army_flag]
    flag = value[ambient_object_flag]
    flag = value[species_flag]
    flag = value[pop_faction_flag]
    flag = value[war_flag]
    flag = value[federation_flag]
    flag = value[starbase_flag]
    flag = value[deposit_flag]
    flag = value[sector_flag]
    flag = value[global_flag]
    flag = value[archaeology_flag]
    flag = value[first_contact_flag]
    flag = value[spynetwork_flag]
    flag = value[espionage_operation_flag]
    flag = value[espionage_asset_flag]
    flag = value[agreement_flag]
    flag = value[situation_flag]
    flag = value[astral_rift_flag]

    value = int_value_field
}

### Returns true if the scoped galactic object has an asteroid belt.
## scopes = { galactic_object }
alias[trigger:has_asteroid_belt] = bool

### Checks if the specified specimen was the last acquired one
## scopes = { country }
alias[trigger:last_acquired_specimen] = <specimen>

### Checks if can give a specific specimen. Checks if specimen is already given and if there is an available exhibit slot
## scopes = { country }
alias[trigger:can_give_specimen] = <specimen>

### Check if the scoped exhibit is active
## scopes = { exhibit }
alias[trigger:is_exhibit_active] = bool

### Returns the country's used Vivarium slots
## scopes = { country }
alias[trigger:num_vivarium_slots] == int_value_field

### Checks if the scoped country has the specified specimen
## scopes = { country }
alias[trigger:has_specimen] = <specimen>

### Checks if the scoped country has the specified specimen
## scopes = { country }
alias[trigger:has_specimen] = scope[exhibit]

### Checks if the scoped fleet or ship is space fauna (as set in ship sizes).
## scopes = { ship fleet design ship_growth_stage }
alias[trigger:is_space_fauna] = bool

### Checks if the ship/design can be reanimated.
## scopes = { ship design ship_growth_stage }
alias[trigger:can_be_reanimated] = bool

### Checks if the ship/fleet/design is a specific ship category
## scopes = { ship fleet design ship_growth_stage }
alias[trigger:is_ship_category] = <ship_categories>

### Checks if the specified specimen contained by the scoped exhibit is of indicated rarity
## scopes = { exhibit }
alias[trigger:is_specimen_rarity] = enum[specimens_rarity]

### Checks if the specified specimen contained by the scoped exhibit is of indicated collection category
## scopes = { exhibit }
alias[trigger:is_specimen_category] = enum[specimen_types]

### Checks used naval cap by the scoped country or fleet's controlled ships which fulfill the specified criteria.
## scopes = { country fleet }
## push_scope = fleet
alias[trigger:count_used_naval_cap] = {
    limit = single_alias_right[trigger_clause]
    count = all
    count = int_value_field
}

### Retrieves the percentage of usage of a given resource in the ship size. If the ship size cost is 100 food and 300 minerals, the value when checking for food is 0.25
### Only use in trigger value(complex_trigger_modifier export_trigger_value_to_variable )
## scopes = { ship design ship_growth_stage }
alias[trigger:ship_size_cost_resource_percent] = { resource = <resource> }

### Check if dna has been acquired for the given category
## scopes = { country }
alias[trigger:has_dna] = {
    ship_category = <ship_categories>
    ## cardinality = 0..1
    rarity = enum[ship_rarity]
}

### Checks if the last acquired specimen is of the given rarity
## scopes = { country }
alias[trigger:is_last_acquired_specimen_rarity] = enum[specimens_rarity]

### Checks if a trait has all tags in the list
## scopes = { trait }
alias[trigger:trait_has_all_tags] = {
    ## cardinality = 0..inf
    enum[trait_tag]
}

### Checks if the last acquired specimen is of the given rarity
## scopes = { trait }
alias[trigger:trait_has_any_tag] = {
    ## cardinality = 0..inf
    enum[trait_tag]
}

### Checks if the last acquired specimen is of the given rarity
## scopes = { country }
alias[trigger:uses_ship_category] = <ship_categories>

### Checks if the last acquired specimen was acquired through a trade deal
## scopes = { country }
alias[trigger:is_last_acquired_specimen_from_trade] = bool

### checks if the scoped country has the target species set a default for its species group.
## scopes = { country }
alias[trigger:is_default_species] = scope[species]

### Checks if a species has a particular species right that enabled sub-species integration
## scopes = { species }
alias[trigger:is_being_integrated_by] = scope[country]

### Checks if a country has a particular focus card active active
## scopes = { country }
alias[trigger:has_active_focus] = <country_focus_cards>

### Checks if a country has a particular focus card completed
## scopes = { country }
alias[trigger:has_completed_focus] = <country_focus_cards>

### Checks the number the planet has of any, or a specific, zone
## scopes = { planet country }
alias[trigger:num_zones] = {
    type = any
    type = <zone>
    value == value_field
}

### Checks if the bioship can get growth progress.
## scopes = { ship }
alias[trigger:bioship_can_grow] = bool

### Checks how many pops that has jobs with all given tags in a planet
## scopes = { planet }
alias[trigger:num_pops_with_job_tag] = {
    tags = {
        ## cardinality = 0..inf
        enum[job_tag]
    }
    value = int_value_field
}

### Checks how many pops that has jobs with all given tags in a country
## scopes = { country }
alias[trigger:num_country_pops_with_job_tag] = {
    tags = {
        ## cardinality = 0..inf
        enum[job_tag]
    }
    value = int_value_field
}

### Iterate through every exhibit - checks whether the enclosed triggers return true for any of them
## scopes = { country }
## push_scope = exhibit
alias[trigger:any_exhibit] = single_alias_right[trigger_clause]

### Iterate through every exhibit - checks whether the enclosed triggers return true for X/all of them
## scopes = { country }
## push_scope = exhibit
alias[trigger:count_exhibit] = {
    ## cardinality = 0..1
    ### push_scope = exhibit
    limit = single_alias_right[trigger_clause]
    count = int_value_field
    count = all
}


